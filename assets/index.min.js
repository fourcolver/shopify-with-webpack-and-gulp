!function(t){var i={};function o(e){if(i[e])return i[e].exports;var n=i[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=i,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)o.d(t,i,function(e){return n[e]}.bind(null,i));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="",o(o.s="./src/js/build/index.js")}({"./node_modules/desandro-matches-selector/matches-selector.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * matchesSelector v2.0.2\n * matchesSelector( element, '.selector' )\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n\n(function (window, factory) {\n  /*global define: false, module: false */\n  'use strict';\n  // universal module definition\n\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory() {\n  'use strict';\n\n  var matchesMethod = function () {\n    var ElemProto = window.Element.prototype;\n    // check for the standard method name first\n    if (ElemProto.matches) {\n      return 'matches';\n    }\n    // check un-prefixed\n    if (ElemProto.matchesSelector) {\n      return 'matchesSelector';\n    }\n    // check vendor prefixes\n    var prefixes = ['webkit', 'moz', 'ms', 'o'];\n\n    for (var i = 0; i < prefixes.length; i++) {\n      var prefix = prefixes[i];\n      var method = prefix + 'MatchesSelector';\n      if (ElemProto[method]) {\n        return method;\n      }\n    }\n  }();\n\n  return function matchesSelector(elem, selector) {\n    return elem[matchesMethod](selector);\n  };\n});\n\n//# sourceURL=webpack:///./node_modules/desandro-matches-selector/matches-selector.js?")},"./node_modules/ev-emitter/ev-emitter.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * EvEmitter v1.1.0\n * Lil' event emitter\n * MIT License\n */\n\n/* jshint unused: true, undef: true, strict: true */\n\n(function (global, factory) {\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, window */\n  if (true) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(typeof window != 'undefined' ? window : this, function () {\n\n  \"use strict\";\n\n  function EvEmitter() {}\n\n  var proto = EvEmitter.prototype;\n\n  proto.on = function (eventName, listener) {\n    if (!eventName || !listener) {\n      return;\n    }\n    // set events hash\n    var events = this._events = this._events || {};\n    // set listeners array\n    var listeners = events[eventName] = events[eventName] || [];\n    // only add once\n    if (listeners.indexOf(listener) == -1) {\n      listeners.push(listener);\n    }\n\n    return this;\n  };\n\n  proto.once = function (eventName, listener) {\n    if (!eventName || !listener) {\n      return;\n    }\n    // add event\n    this.on(eventName, listener);\n    // set once flag\n    // set onceEvents hash\n    var onceEvents = this._onceEvents = this._onceEvents || {};\n    // set onceListeners object\n    var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};\n    // set flag\n    onceListeners[listener] = true;\n\n    return this;\n  };\n\n  proto.off = function (eventName, listener) {\n    var listeners = this._events && this._events[eventName];\n    if (!listeners || !listeners.length) {\n      return;\n    }\n    var index = listeners.indexOf(listener);\n    if (index != -1) {\n      listeners.splice(index, 1);\n    }\n\n    return this;\n  };\n\n  proto.emitEvent = function (eventName, args) {\n    var listeners = this._events && this._events[eventName];\n    if (!listeners || !listeners.length) {\n      return;\n    }\n    // copy over to avoid interference if .off() in listener\n    listeners = listeners.slice(0);\n    args = args || [];\n    // once stuff\n    var onceListeners = this._onceEvents && this._onceEvents[eventName];\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      var isOnce = onceListeners && onceListeners[listener];\n      if (isOnce) {\n        // remove listener\n        // remove before trigger to prevent recursion\n        this.off(eventName, listener);\n        // unset once flag\n        delete onceListeners[listener];\n      }\n      // trigger listener\n      listener.apply(this, args);\n    }\n\n    return this;\n  };\n\n  proto.allOff = function () {\n    delete this._events;\n    delete this._onceEvents;\n  };\n\n  return EvEmitter;\n});\n\n//# sourceURL=webpack:///./node_modules/ev-emitter/ev-emitter.js?")},"./node_modules/fizzy-ui-utils/utils.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Fizzy UI utils v2.0.7\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n(function (window, factory) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! desandro-matches-selector/matches-selector */ \"./node_modules/desandro-matches-selector/matches-selector.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (matchesSelector) {\n      return factory(window, matchesSelector);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, matchesSelector) {\n\n  'use strict';\n\n  var utils = {};\n\n  // ----- extend ----- //\n\n  // extends objects\n  utils.extend = function (a, b) {\n    for (var prop in b) {\n      a[prop] = b[prop];\n    }\n    return a;\n  };\n\n  // ----- modulo ----- //\n\n  utils.modulo = function (num, div) {\n    return (num % div + div) % div;\n  };\n\n  // ----- makeArray ----- //\n\n  var arraySlice = Array.prototype.slice;\n\n  // turn element or nodeList into an array\n  utils.makeArray = function (obj) {\n    if (Array.isArray(obj)) {\n      // use object if already an array\n      return obj;\n    }\n    // return empty array if undefined or null. #6\n    if (obj === null || obj === undefined) {\n      return [];\n    }\n\n    var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';\n    if (isArrayLike) {\n      // convert nodeList to array\n      return arraySlice.call(obj);\n    }\n\n    // array of single index\n    return [obj];\n  };\n\n  // ----- removeFrom ----- //\n\n  utils.removeFrom = function (ary, obj) {\n    var index = ary.indexOf(obj);\n    if (index != -1) {\n      ary.splice(index, 1);\n    }\n  };\n\n  // ----- getParent ----- //\n\n  utils.getParent = function (elem, selector) {\n    while (elem.parentNode && elem != document.body) {\n      elem = elem.parentNode;\n      if (matchesSelector(elem, selector)) {\n        return elem;\n      }\n    }\n  };\n\n  // ----- getQueryElement ----- //\n\n  // use element as selector string\n  utils.getQueryElement = function (elem) {\n    if (typeof elem == 'string') {\n      return document.querySelector(elem);\n    }\n    return elem;\n  };\n\n  // ----- handleEvent ----- //\n\n  // enable .ontype to trigger from .addEventListener( elem, 'type' )\n  utils.handleEvent = function (event) {\n    var method = 'on' + event.type;\n    if (this[method]) {\n      this[method](event);\n    }\n  };\n\n  // ----- filterFindElements ----- //\n\n  utils.filterFindElements = function (elems, selector) {\n    // make array of elems\n    elems = utils.makeArray(elems);\n    var ffElems = [];\n\n    elems.forEach(function (elem) {\n      // check that elem is an actual element\n      if (!(elem instanceof HTMLElement)) {\n        return;\n      }\n      // add elem if no selector\n      if (!selector) {\n        ffElems.push(elem);\n        return;\n      }\n      // filter & find items if we have a selector\n      // filter\n      if (matchesSelector(elem, selector)) {\n        ffElems.push(elem);\n      }\n      // find children\n      var childElems = elem.querySelectorAll(selector);\n      // concat childElems to filterFound array\n      for (var i = 0; i < childElems.length; i++) {\n        ffElems.push(childElems[i]);\n      }\n    });\n\n    return ffElems;\n  };\n\n  // ----- debounceMethod ----- //\n\n  utils.debounceMethod = function (_class, methodName, threshold) {\n    threshold = threshold || 100;\n    // original method\n    var method = _class.prototype[methodName];\n    var timeoutName = methodName + 'Timeout';\n\n    _class.prototype[methodName] = function () {\n      var timeout = this[timeoutName];\n      clearTimeout(timeout);\n\n      var args = arguments;\n      var _this = this;\n      this[timeoutName] = setTimeout(function () {\n        method.apply(_this, args);\n        delete _this[timeoutName];\n      }, threshold);\n    };\n  };\n\n  // ----- docReady ----- //\n\n  utils.docReady = function (callback) {\n    var readyState = document.readyState;\n    if (readyState == 'complete' || readyState == 'interactive') {\n      // do async to allow for other scripts to run. metafizzy/flickity#441\n      setTimeout(callback);\n    } else {\n      document.addEventListener('DOMContentLoaded', callback);\n    }\n  };\n\n  // ----- htmlInit ----- //\n\n  // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/\n  utils.toDashed = function (str) {\n    return str.replace(/(.)([A-Z])/g, function (match, $1, $2) {\n      return $1 + '-' + $2;\n    }).toLowerCase();\n  };\n\n  var console = window.console;\n  /**\n   * allow user to initialize classes via [data-namespace] or .js-namespace class\n   * htmlInit( Widget, 'widgetName' )\n   * options are parsed from data-namespace-options\n   */\n  utils.htmlInit = function (WidgetClass, namespace) {\n    utils.docReady(function () {\n      var dashedNamespace = utils.toDashed(namespace);\n      var dataAttr = 'data-' + dashedNamespace;\n      var dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');\n      var jsDashElems = document.querySelectorAll('.js-' + dashedNamespace);\n      var elems = utils.makeArray(dataAttrElems).concat(utils.makeArray(jsDashElems));\n      var dataOptionsAttr = dataAttr + '-options';\n      var jQuery = window.jQuery;\n\n      elems.forEach(function (elem) {\n        var attr = elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);\n        var options;\n        try {\n          options = attr && JSON.parse(attr);\n        } catch (error) {\n          // log error, do not initialize\n          if (console) {\n            console.error('Error parsing ' + dataAttr + ' on ' + elem.className + ': ' + error);\n          }\n          return;\n        }\n        // initialize\n        var instance = new WidgetClass(elem, options);\n        // make available via $().data('namespace')\n        if (jQuery) {\n          jQuery.data(elem, namespace, instance);\n        }\n      });\n    });\n  };\n\n  // -----  ----- //\n\n  return utils;\n});\n\n//# sourceURL=webpack:///./node_modules/fizzy-ui-utils/utils.js?")},"./node_modules/flickity/js/add-remove-cell.js":function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n// add, remove cell\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['./flickity', 'fizzy-ui-utils/utils'], function (Flickity, utils) {\n      return factory(window, Flickity, utils);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! fizzy-ui-utils */ \"./node_modules/fizzy-ui-utils/utils.js\"));\n  } else {\n    // browser global\n    factory(window, window.Flickity, window.fizzyUIUtils);\n  }\n})(window, function factory(window, Flickity, utils) {\n\n  'use strict';\n\n  // append cells to a document fragment\n\n  function getCellsFragment(cells) {\n    var fragment = document.createDocumentFragment();\n    cells.forEach(function (cell) {\n      fragment.appendChild(cell.element);\n    });\n    return fragment;\n  }\n\n  // -------------------------- add/remove cell prototype -------------------------- //\n\n  var proto = Flickity.prototype;\n\n  /**\n   * Insert, prepend, or append cells\n   * @param {Element, Array, NodeList} elems\n   * @param {Integer} index\n   */\n  proto.insert = function (elems, index) {\n    var cells = this._makeCells(elems);\n    if (!cells || !cells.length) {\n      return;\n    }\n    var len = this.cells.length;\n    // default to append\n    index = index === undefined ? len : index;\n    // add cells with document fragment\n    var fragment = getCellsFragment(cells);\n    // append to slider\n    var isAppend = index == len;\n    if (isAppend) {\n      this.slider.appendChild(fragment);\n    } else {\n      var insertCellElement = this.cells[index].element;\n      this.slider.insertBefore(fragment, insertCellElement);\n    }\n    // add to this.cells\n    if (index === 0) {\n      // prepend, add to start\n      this.cells = cells.concat(this.cells);\n    } else if (isAppend) {\n      // append, add to end\n      this.cells = this.cells.concat(cells);\n    } else {\n      // insert in this.cells\n      var endCells = this.cells.splice(index, len - index);\n      this.cells = this.cells.concat(cells).concat(endCells);\n    }\n\n    this._sizeCells(cells);\n    this.cellChange(index, true);\n  };\n\n  proto.append = function (elems) {\n    this.insert(elems, this.cells.length);\n  };\n\n  proto.prepend = function (elems) {\n    this.insert(elems, 0);\n  };\n\n  /**\n   * Remove cells\n   * @param {Element, Array, NodeList} elems\n   */\n  proto.remove = function (elems) {\n    var cells = this.getCells(elems);\n    if (!cells || !cells.length) {\n      return;\n    }\n\n    var minCellIndex = this.cells.length - 1;\n    // remove cells from collection & DOM\n    cells.forEach(function (cell) {\n      cell.remove();\n      var index = this.cells.indexOf(cell);\n      minCellIndex = Math.min(index, minCellIndex);\n      utils.removeFrom(this.cells, cell);\n    }, this);\n\n    this.cellChange(minCellIndex, true);\n  };\n\n  /**\n   * logic to be run after a cell's size changes\n   * @param {Element} elem - cell's element\n   */\n  proto.cellSizeChange = function (elem) {\n    var cell = this.getCell(elem);\n    if (!cell) {\n      return;\n    }\n    cell.getSize();\n\n    var index = this.cells.indexOf(cell);\n    this.cellChange(index);\n  };\n\n  /**\n   * logic any time a cell is changed: added, removed, or size changed\n   * @param {Integer} changedCellIndex - index of the changed cell, optional\n   */\n  proto.cellChange = function (changedCellIndex, isPositioningSlider) {\n    var prevSelectedElem = this.selectedElement;\n    this._positionCells(changedCellIndex);\n    this._getWrapShiftCells();\n    this.setGallerySize();\n    // update selectedIndex\n    // try to maintain position & select previous selected element\n    var cell = this.getCell(prevSelectedElem);\n    if (cell) {\n      this.selectedIndex = this.getCellSlideIndex(cell);\n    }\n    this.selectedIndex = Math.min(this.slides.length - 1, this.selectedIndex);\n\n    this.emitEvent('cellChange', [changedCellIndex]);\n    // position slider\n    this.select(this.selectedIndex);\n    // do not position slider after lazy load\n    if (isPositioningSlider) {\n      this.positionSliderAtSelected();\n    }\n  };\n\n  // -----  ----- //\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/add-remove-cell.js?")},"./node_modules/flickity/js/animate.js":function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n// animate\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['fizzy-ui-utils/utils'], function (utils) {\n      return factory(window, utils);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, __webpack_require__(/*! fizzy-ui-utils */ \"./node_modules/fizzy-ui-utils/utils.js\"));\n  } else {\n    // browser global\n    window.Flickity = window.Flickity || {};\n    window.Flickity.animatePrototype = factory(window, window.fizzyUIUtils);\n  }\n})(window, function factory(window, utils) {\n\n  'use strict';\n\n  // -------------------------- animate -------------------------- //\n\n  var proto = {};\n\n  proto.startAnimation = function () {\n    if (this.isAnimating) {\n      return;\n    }\n\n    this.isAnimating = true;\n    this.restingFrames = 0;\n    this.animate();\n  };\n\n  proto.animate = function () {\n    this.applyDragForce();\n    this.applySelectedAttraction();\n\n    var previousX = this.x;\n\n    this.integratePhysics();\n    this.positionSlider();\n    this.settle(previousX);\n    // animate next frame\n    if (this.isAnimating) {\n      var _this = this;\n      requestAnimationFrame(function animateFrame() {\n        _this.animate();\n      });\n    }\n  };\n\n  proto.positionSlider = function () {\n    var x = this.x;\n    // wrap position around\n    if (this.options.wrapAround && this.cells.length > 1) {\n      x = utils.modulo(x, this.slideableWidth);\n      x = x - this.slideableWidth;\n      this.shiftWrapCells(x);\n    }\n\n    x = x + this.cursorPosition;\n    // reverse if right-to-left and using transform\n    x = this.options.rightToLeft ? -x : x;\n    var value = this.getPositionValue(x);\n    // use 3D tranforms for hardware acceleration on iOS\n    // but use 2D when settled, for better font-rendering\n    this.slider.style.transform = this.isAnimating ? 'translate3d(' + value + ',0,0)' : 'translateX(' + value + ')';\n\n    // scroll event\n    var firstSlide = this.slides[0];\n    if (firstSlide) {\n      var positionX = -this.x - firstSlide.target;\n      var progress = positionX / this.slidesWidth;\n      this.dispatchEvent('scroll', null, [progress, positionX]);\n    }\n  };\n\n  proto.positionSliderAtSelected = function () {\n    if (!this.cells.length) {\n      return;\n    }\n    this.x = -this.selectedSlide.target;\n    this.velocity = 0; // stop wobble\n    this.positionSlider();\n  };\n\n  proto.getPositionValue = function (position) {\n    if (this.options.percentPosition) {\n      // percent position, round to 2 digits, like 12.34%\n      return Math.round(position / this.size.innerWidth * 10000) * 0.01 + '%';\n    } else {\n      // pixel positioning\n      return Math.round(position) + 'px';\n    }\n  };\n\n  proto.settle = function (previousX) {\n    // keep track of frames where x hasn't moved\n    if (!this.isPointerDown && Math.round(this.x * 100) == Math.round(previousX * 100)) {\n      this.restingFrames++;\n    }\n    // stop animating if resting for 3 or more frames\n    if (this.restingFrames > 2) {\n      this.isAnimating = false;\n      delete this.isFreeScrolling;\n      // render position with translateX when settled\n      this.positionSlider();\n      this.dispatchEvent('settle', null, [this.selectedIndex]);\n    }\n  };\n\n  proto.shiftWrapCells = function (x) {\n    // shift before cells\n    var beforeGap = this.cursorPosition + x;\n    this._shiftCells(this.beforeShiftCells, beforeGap, -1);\n    // shift after cells\n    var afterGap = this.size.innerWidth - (x + this.slideableWidth + this.cursorPosition);\n    this._shiftCells(this.afterShiftCells, afterGap, 1);\n  };\n\n  proto._shiftCells = function (cells, gap, shift) {\n    for (var i = 0; i < cells.length; i++) {\n      var cell = cells[i];\n      var cellShift = gap > 0 ? shift : 0;\n      cell.wrapShift(cellShift);\n      gap -= cell.size.outerWidth;\n    }\n  };\n\n  proto._unshiftCells = function (cells) {\n    if (!cells || !cells.length) {\n      return;\n    }\n    for (var i = 0; i < cells.length; i++) {\n      cells[i].wrapShift(0);\n    }\n  };\n\n  // -------------------------- physics -------------------------- //\n\n  proto.integratePhysics = function () {\n    this.x += this.velocity;\n    this.velocity *= this.getFrictionFactor();\n  };\n\n  proto.applyForce = function (force) {\n    this.velocity += force;\n  };\n\n  proto.getFrictionFactor = function () {\n    return 1 - this.options[this.isFreeScrolling ? 'freeScrollFriction' : 'friction'];\n  };\n\n  proto.getRestingPosition = function () {\n    // my thanks to Steven Wittens, who simplified this math greatly\n    return this.x + this.velocity / (1 - this.getFrictionFactor());\n  };\n\n  proto.applyDragForce = function () {\n    if (!this.isDraggable || !this.isPointerDown) {\n      return;\n    }\n    // change the position to drag position by applying force\n    var dragVelocity = this.dragX - this.x;\n    var dragForce = dragVelocity - this.velocity;\n    this.applyForce(dragForce);\n  };\n\n  proto.applySelectedAttraction = function () {\n    // do not attract if pointer down or no slides\n    var dragDown = this.isDraggable && this.isPointerDown;\n    if (dragDown || this.isFreeScrolling || !this.slides.length) {\n      return;\n    }\n    var distance = this.selectedSlide.target * -1 - this.x;\n    var force = distance * this.options.selectedAttraction;\n    this.applyForce(force);\n  };\n\n  return proto;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/animate.js?")},"./node_modules/flickity/js/cell.js":function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n// Flickity.Cell\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['get-size/get-size'], function (getSize) {\n      return factory(window, getSize);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, __webpack_require__(/*! get-size */ \"./node_modules/get-size/get-size.js\"));\n  } else {\n    // browser global\n    window.Flickity = window.Flickity || {};\n    window.Flickity.Cell = factory(window, window.getSize);\n  }\n})(window, function factory(window, getSize) {\n\n  'use strict';\n\n  function Cell(elem, parent) {\n    this.element = elem;\n    this.parent = parent;\n\n    this.create();\n  }\n\n  var proto = Cell.prototype;\n\n  proto.create = function () {\n    this.element.style.position = 'absolute';\n    this.element.setAttribute('aria-selected', 'false');\n    this.x = 0;\n    this.shift = 0;\n  };\n\n  proto.destroy = function () {\n    // reset style\n    this.element.style.position = '';\n    var side = this.parent.originSide;\n    this.element.removeAttribute('aria-selected');\n    this.element.style[side] = '';\n  };\n\n  proto.getSize = function () {\n    this.size = getSize(this.element);\n  };\n\n  proto.setPosition = function (x) {\n    this.x = x;\n    this.updateTarget();\n    this.renderPosition(x);\n  };\n\n  // setDefaultTarget v1 method, backwards compatibility, remove in v3\n  proto.updateTarget = proto.setDefaultTarget = function () {\n    var marginProperty = this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';\n    this.target = this.x + this.size[marginProperty] + this.size.width * this.parent.cellAlign;\n  };\n\n  proto.renderPosition = function (x) {\n    // render position of cell with in slider\n    var side = this.parent.originSide;\n    this.element.style[side] = this.parent.getPositionValue(x);\n  };\n\n  /**\n   * @param {Integer} factor - 0, 1, or -1\n  **/\n  proto.wrapShift = function (shift) {\n    this.shift = shift;\n    this.renderPosition(this.x + this.parent.slideableWidth * shift);\n  };\n\n  proto.remove = function () {\n    this.element.parentNode.removeChild(this.element);\n  };\n\n  return Cell;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/cell.js?")},"./node_modules/flickity/js/drag.js":function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n// drag\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['./flickity', 'unidragger/unidragger', 'fizzy-ui-utils/utils'], function (Flickity, Unidragger, utils) {\n      return factory(window, Flickity, Unidragger, utils);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! unidragger */ \"./node_modules/unidragger/unidragger.js\"), __webpack_require__(/*! fizzy-ui-utils */ \"./node_modules/fizzy-ui-utils/utils.js\"));\n  } else {\n    // browser global\n    window.Flickity = factory(window, window.Flickity, window.Unidragger, window.fizzyUIUtils);\n  }\n})(window, function factory(window, Flickity, Unidragger, utils) {\n\n  'use strict';\n\n  // ----- defaults ----- //\n\n  utils.extend(Flickity.defaults, {\n    draggable: '>1',\n    dragThreshold: 3\n  });\n\n  // ----- create ----- //\n\n  Flickity.createMethods.push('_createDrag');\n\n  // -------------------------- drag prototype -------------------------- //\n\n  var proto = Flickity.prototype;\n  utils.extend(proto, Unidragger.prototype);\n  proto._touchActionValue = 'pan-y';\n\n  // --------------------------  -------------------------- //\n\n  var isTouch = 'createTouch' in document;\n  var isTouchmoveScrollCanceled = false;\n\n  proto._createDrag = function () {\n    this.on('activate', this.onActivateDrag);\n    this.on('uiChange', this._uiChangeDrag);\n    this.on('childUIPointerDown', this._childUIPointerDownDrag);\n    this.on('deactivate', this.onDeactivateDrag);\n    this.on('cellChange', this.updateDraggable);\n    // TODO updateDraggable on resize? if groupCells & slides change\n    // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior\n    // #457, RubaXa/Sortable#973\n    if (isTouch && !isTouchmoveScrollCanceled) {\n      window.addEventListener('touchmove', function () {});\n      isTouchmoveScrollCanceled = true;\n    }\n  };\n\n  proto.onActivateDrag = function () {\n    this.handles = [this.viewport];\n    this.bindHandles();\n    this.updateDraggable();\n  };\n\n  proto.onDeactivateDrag = function () {\n    this.unbindHandles();\n    this.element.classList.remove('is-draggable');\n  };\n\n  proto.updateDraggable = function () {\n    // disable dragging if less than 2 slides. #278\n    if (this.options.draggable == '>1') {\n      this.isDraggable = this.slides.length > 1;\n    } else {\n      this.isDraggable = this.options.draggable;\n    }\n    if (this.isDraggable) {\n      this.element.classList.add('is-draggable');\n    } else {\n      this.element.classList.remove('is-draggable');\n    }\n  };\n\n  // backwards compatibility\n  proto.bindDrag = function () {\n    this.options.draggable = true;\n    this.updateDraggable();\n  };\n\n  proto.unbindDrag = function () {\n    this.options.draggable = false;\n    this.updateDraggable();\n  };\n\n  proto._uiChangeDrag = function () {\n    delete this.isFreeScrolling;\n  };\n\n  proto._childUIPointerDownDrag = function (event) {\n    // allow focus & preventDefault even when not draggable\n    // so child UI elements keep focus on carousel. #721\n    event.preventDefault();\n    this.pointerDownFocus(event);\n  };\n\n  // -------------------------- pointer events -------------------------- //\n\n  proto.pointerDown = function (event, pointer) {\n    if (!this.isDraggable) {\n      this._pointerDownDefault(event, pointer);\n      return;\n    }\n    var isOkay = this.okayPointerDown(event);\n    if (!isOkay) {\n      return;\n    }\n\n    this._pointerDownPreventDefault(event);\n    this.pointerDownFocus(event);\n    // blur\n    if (document.activeElement != this.element) {\n      // do not blur if already focused\n      this.pointerDownBlur();\n    }\n\n    // stop if it was moving\n    this.dragX = this.x;\n    this.viewport.classList.add('is-pointer-down');\n    // track scrolling\n    this.pointerDownScroll = getScrollPosition();\n    window.addEventListener('scroll', this);\n\n    this._pointerDownDefault(event, pointer);\n  };\n\n  // default pointerDown logic, used for staticClick\n  proto._pointerDownDefault = function (event, pointer) {\n    // track start event position\n    this.pointerDownPointer = pointer;\n    // bind move and end events\n    this._bindPostStartEvents(event);\n    this.dispatchEvent('pointerDown', event, [pointer]);\n  };\n\n  var focusNodes = {\n    INPUT: true,\n    TEXTAREA: true,\n    SELECT: true\n  };\n\n  proto.pointerDownFocus = function (event) {\n    var isFocusNode = focusNodes[event.target.nodeName];\n    if (!isFocusNode) {\n      this.focus();\n    }\n  };\n\n  proto._pointerDownPreventDefault = function (event) {\n    var isTouchStart = event.type == 'touchstart';\n    var isTouchPointer = event.pointerType == 'touch';\n    var isFocusNode = focusNodes[event.target.nodeName];\n    if (!isTouchStart && !isTouchPointer && !isFocusNode) {\n      event.preventDefault();\n    }\n  };\n\n  // ----- move ----- //\n\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > this.options.dragThreshold;\n  };\n\n  // ----- up ----- //\n\n  proto.pointerUp = function (event, pointer) {\n    delete this.isTouchScrolling;\n    this.viewport.classList.remove('is-pointer-down');\n    this.dispatchEvent('pointerUp', event, [pointer]);\n    this._dragPointerUp(event, pointer);\n  };\n\n  proto.pointerDone = function () {\n    window.removeEventListener('scroll', this);\n    delete this.pointerDownScroll;\n  };\n\n  // -------------------------- dragging -------------------------- //\n\n  proto.dragStart = function (event, pointer) {\n    if (!this.isDraggable) {\n      return;\n    }\n    this.dragStartPosition = this.x;\n    this.startAnimation();\n    window.removeEventListener('scroll', this);\n    this.dispatchEvent('dragStart', event, [pointer]);\n  };\n\n  proto.pointerMove = function (event, pointer) {\n    var moveVector = this._dragPointerMove(event, pointer);\n    this.dispatchEvent('pointerMove', event, [pointer, moveVector]);\n    this._dragMove(event, pointer, moveVector);\n  };\n\n  proto.dragMove = function (event, pointer, moveVector) {\n    if (!this.isDraggable) {\n      return;\n    }\n    event.preventDefault();\n\n    this.previousDragX = this.dragX;\n    // reverse if right-to-left\n    var direction = this.options.rightToLeft ? -1 : 1;\n    if (this.options.wrapAround) {\n      // wrap around move. #589\n      moveVector.x = moveVector.x % this.slideableWidth;\n    }\n    var dragX = this.dragStartPosition + moveVector.x * direction;\n\n    if (!this.options.wrapAround && this.slides.length) {\n      // slow drag\n      var originBound = Math.max(-this.slides[0].target, this.dragStartPosition);\n      dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;\n      var endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);\n      dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;\n    }\n\n    this.dragX = dragX;\n\n    this.dragMoveTime = new Date();\n    this.dispatchEvent('dragMove', event, [pointer, moveVector]);\n  };\n\n  proto.dragEnd = function (event, pointer) {\n    if (!this.isDraggable) {\n      return;\n    }\n    if (this.options.freeScroll) {\n      this.isFreeScrolling = true;\n    }\n    // set selectedIndex based on where flick will end up\n    var index = this.dragEndRestingSelect();\n\n    if (this.options.freeScroll && !this.options.wrapAround) {\n      // if free-scroll & not wrap around\n      // do not free-scroll if going outside of bounding slides\n      // so bounding slides can attract slider, and keep it in bounds\n      var restingX = this.getRestingPosition();\n      this.isFreeScrolling = -restingX > this.slides[0].target && -restingX < this.getLastSlide().target;\n    } else if (!this.options.freeScroll && index == this.selectedIndex) {\n      // boost selection if selected index has not changed\n      index += this.dragEndBoostSelect();\n    }\n    delete this.previousDragX;\n    // apply selection\n    // TODO refactor this, selecting here feels weird\n    // HACK, set flag so dragging stays in correct direction\n    this.isDragSelect = this.options.wrapAround;\n    this.select(index);\n    delete this.isDragSelect;\n    this.dispatchEvent('dragEnd', event, [pointer]);\n  };\n\n  proto.dragEndRestingSelect = function () {\n    var restingX = this.getRestingPosition();\n    // how far away from selected slide\n    var distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex));\n    // get closet resting going up and going down\n    var positiveResting = this._getClosestResting(restingX, distance, 1);\n    var negativeResting = this._getClosestResting(restingX, distance, -1);\n    // use closer resting for wrap-around\n    var index = positiveResting.distance < negativeResting.distance ? positiveResting.index : negativeResting.index;\n    return index;\n  };\n\n  /**\n   * given resting X and distance to selected cell\n   * get the distance and index of the closest cell\n   * @param {Number} restingX - estimated post-flick resting position\n   * @param {Number} distance - distance to selected cell\n   * @param {Integer} increment - +1 or -1, going up or down\n   * @returns {Object} - { distance: {Number}, index: {Integer} }\n   */\n  proto._getClosestResting = function (restingX, distance, increment) {\n    var index = this.selectedIndex;\n    var minDistance = Infinity;\n    var condition = this.options.contain && !this.options.wrapAround ?\n    // if contain, keep going if distance is equal to minDistance\n    function (d, md) {\n      return d <= md;\n    } : function (d, md) {\n      return d < md;\n    };\n    while (condition(distance, minDistance)) {\n      // measure distance to next cell\n      index += increment;\n      minDistance = distance;\n      distance = this.getSlideDistance(-restingX, index);\n      if (distance === null) {\n        break;\n      }\n      distance = Math.abs(distance);\n    }\n    return {\n      distance: minDistance,\n      // selected was previous index\n      index: index - increment\n    };\n  };\n\n  /**\n   * measure distance between x and a slide target\n   * @param {Number} x\n   * @param {Integer} index - slide index\n   */\n  proto.getSlideDistance = function (x, index) {\n    var len = this.slides.length;\n    // wrap around if at least 2 slides\n    var isWrapAround = this.options.wrapAround && len > 1;\n    var slideIndex = isWrapAround ? utils.modulo(index, len) : index;\n    var slide = this.slides[slideIndex];\n    if (!slide) {\n      return null;\n    }\n    // add distance for wrap-around slides\n    var wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;\n    return x - (slide.target + wrap);\n  };\n\n  proto.dragEndBoostSelect = function () {\n    // do not boost if no previousDragX or dragMoveTime\n    if (this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100) {\n      return 0;\n    }\n\n    var distance = this.getSlideDistance(-this.dragX, this.selectedIndex);\n    var delta = this.previousDragX - this.dragX;\n    if (distance > 0 && delta > 0) {\n      // boost to next if moving towards the right, and positive velocity\n      return 1;\n    } else if (distance < 0 && delta < 0) {\n      // boost to previous if moving towards the left, and negative velocity\n      return -1;\n    }\n    return 0;\n  };\n\n  // ----- staticClick ----- //\n\n  proto.staticClick = function (event, pointer) {\n    // get clickedCell, if cell was clicked\n    var clickedCell = this.getParentCell(event.target);\n    var cellElem = clickedCell && clickedCell.element;\n    var cellIndex = clickedCell && this.cells.indexOf(clickedCell);\n    this.dispatchEvent('staticClick', event, [pointer, cellElem, cellIndex]);\n  };\n\n  // ----- scroll ----- //\n\n  proto.onscroll = function () {\n    var scroll = getScrollPosition();\n    var scrollMoveX = this.pointerDownScroll.x - scroll.x;\n    var scrollMoveY = this.pointerDownScroll.y - scroll.y;\n    // cancel click/tap if scroll is too much\n    if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {\n      this._pointerDone();\n    }\n  };\n\n  // ----- utils ----- //\n\n  function getScrollPosition() {\n    return {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n\n  // -----  ----- //\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/drag.js?")},"./node_modules/flickity/js/flickity.js":function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n// Flickity main\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['ev-emitter/ev-emitter', 'get-size/get-size', 'fizzy-ui-utils/utils', './cell', './slide', './animate'], function (EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {\n      return factory(window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, __webpack_require__(/*! ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\"), __webpack_require__(/*! get-size */ \"./node_modules/get-size/get-size.js\"), __webpack_require__(/*! fizzy-ui-utils */ \"./node_modules/fizzy-ui-utils/utils.js\"), __webpack_require__(/*! ./cell */ \"./node_modules/flickity/js/cell.js\"), __webpack_require__(/*! ./slide */ \"./node_modules/flickity/js/slide.js\"), __webpack_require__(/*! ./animate */ \"./node_modules/flickity/js/animate.js\"));\n  } else {\n    // browser global\n    var _Flickity = window.Flickity;\n\n    window.Flickity = factory(window, window.EvEmitter, window.getSize, window.fizzyUIUtils, _Flickity.Cell, _Flickity.Slide, _Flickity.animatePrototype);\n  }\n})(window, function factory(window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {\n\n  'use strict';\n\n  // vars\n\n  var jQuery = window.jQuery;\n  var getComputedStyle = window.getComputedStyle;\n  var console = window.console;\n\n  function moveElements(elems, toElem) {\n    elems = utils.makeArray(elems);\n    while (elems.length) {\n      toElem.appendChild(elems.shift());\n    }\n  }\n\n  // -------------------------- Flickity -------------------------- //\n\n  // globally unique identifiers\n  var GUID = 0;\n  // internal store of all Flickity intances\n  var instances = {};\n\n  function Flickity(element, options) {\n    var queryElement = utils.getQueryElement(element);\n    if (!queryElement) {\n      if (console) {\n        console.error('Bad element for Flickity: ' + (queryElement || element));\n      }\n      return;\n    }\n    this.element = queryElement;\n    // do not initialize twice on same element\n    if (this.element.flickityGUID) {\n      var instance = instances[this.element.flickityGUID];\n      instance.option(options);\n      return instance;\n    }\n\n    // add jQuery\n    if (jQuery) {\n      this.$element = jQuery(this.element);\n    }\n    // options\n    this.options = utils.extend({}, this.constructor.defaults);\n    this.option(options);\n\n    // kick things off\n    this._create();\n  }\n\n  Flickity.defaults = {\n    accessibility: true,\n    // adaptiveHeight: false,\n    cellAlign: 'center',\n    // cellSelector: undefined,\n    // contain: false,\n    freeScrollFriction: 0.075, // friction when free-scrolling\n    friction: 0.28, // friction when selecting\n    namespaceJQueryEvents: true,\n    // initialIndex: 0,\n    percentPosition: true,\n    resize: true,\n    selectedAttraction: 0.025,\n    setGallerySize: true\n    // watchCSS: false,\n    // wrapAround: false\n  };\n\n  // hash of methods triggered on _create()\n  Flickity.createMethods = [];\n\n  var proto = Flickity.prototype;\n  // inherit EventEmitter\n  utils.extend(proto, EvEmitter.prototype);\n\n  proto._create = function () {\n    // add id for Flickity.data\n    var id = this.guid = ++GUID;\n    this.element.flickityGUID = id; // expando\n    instances[id] = this; // associate via id\n    // initial properties\n    this.selectedIndex = 0;\n    // how many frames slider has been in same position\n    this.restingFrames = 0;\n    // initial physics properties\n    this.x = 0;\n    this.velocity = 0;\n    this.originSide = this.options.rightToLeft ? 'right' : 'left';\n    // create viewport & slider\n    this.viewport = document.createElement('div');\n    this.viewport.className = 'flickity-viewport';\n    this._createSlider();\n\n    if (this.options.resize || this.options.watchCSS) {\n      window.addEventListener('resize', this);\n    }\n\n    // add listeners from on option\n    for (var eventName in this.options.on) {\n      var listener = this.options.on[eventName];\n      this.on(eventName, listener);\n    }\n\n    Flickity.createMethods.forEach(function (method) {\n      this[method]();\n    }, this);\n\n    if (this.options.watchCSS) {\n      this.watchCSS();\n    } else {\n      this.activate();\n    }\n  };\n\n  /**\n   * set options\n   * @param {Object} opts\n   */\n  proto.option = function (opts) {\n    utils.extend(this.options, opts);\n  };\n\n  proto.activate = function () {\n    if (this.isActive) {\n      return;\n    }\n    this.isActive = true;\n    this.element.classList.add('flickity-enabled');\n    if (this.options.rightToLeft) {\n      this.element.classList.add('flickity-rtl');\n    }\n\n    this.getSize();\n    // move initial cell elements so they can be loaded as cells\n    var cellElems = this._filterFindCellElements(this.element.children);\n    moveElements(cellElems, this.slider);\n    this.viewport.appendChild(this.slider);\n    this.element.appendChild(this.viewport);\n    // get cells from children\n    this.reloadCells();\n\n    if (this.options.accessibility) {\n      // allow element to focusable\n      this.element.tabIndex = 0;\n      // listen for key presses\n      this.element.addEventListener('keydown', this);\n    }\n\n    this.emitEvent('activate');\n\n    var index;\n    var initialIndex = this.options.initialIndex;\n    if (this.isInitActivated) {\n      index = this.selectedIndex;\n    } else if (initialIndex !== undefined) {\n      index = this.cells[initialIndex] ? initialIndex : 0;\n    } else {\n      index = 0;\n    }\n    // select instantly\n    this.select(index, false, true);\n    // flag for initial activation, for using initialIndex\n    this.isInitActivated = true;\n    // ready event. #493\n    this.dispatchEvent('ready');\n  };\n\n  // slider positions the cells\n  proto._createSlider = function () {\n    // slider element does all the positioning\n    var slider = document.createElement('div');\n    slider.className = 'flickity-slider';\n    slider.style[this.originSide] = 0;\n    this.slider = slider;\n  };\n\n  proto._filterFindCellElements = function (elems) {\n    return utils.filterFindElements(elems, this.options.cellSelector);\n  };\n\n  // goes through all children\n  proto.reloadCells = function () {\n    // collection of item elements\n    this.cells = this._makeCells(this.slider.children);\n    this.positionCells();\n    this._getWrapShiftCells();\n    this.setGallerySize();\n  };\n\n  /**\n   * turn elements into Flickity.Cells\n   * @param {Array or NodeList or HTMLElement} elems\n   * @returns {Array} items - collection of new Flickity Cells\n   */\n  proto._makeCells = function (elems) {\n    var cellElems = this._filterFindCellElements(elems);\n\n    // create new Flickity for collection\n    var cells = cellElems.map(function (cellElem) {\n      return new Cell(cellElem, this);\n    }, this);\n\n    return cells;\n  };\n\n  proto.getLastCell = function () {\n    return this.cells[this.cells.length - 1];\n  };\n\n  proto.getLastSlide = function () {\n    return this.slides[this.slides.length - 1];\n  };\n\n  // positions all cells\n  proto.positionCells = function () {\n    // size all cells\n    this._sizeCells(this.cells);\n    // position all cells\n    this._positionCells(0);\n  };\n\n  /**\n   * position certain cells\n   * @param {Integer} index - which cell to start with\n   */\n  proto._positionCells = function (index) {\n    index = index || 0;\n    // also measure maxCellHeight\n    // start 0 if positioning all cells\n    this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;\n    var cellX = 0;\n    // get cellX\n    if (index > 0) {\n      var startCell = this.cells[index - 1];\n      cellX = startCell.x + startCell.size.outerWidth;\n    }\n    var len = this.cells.length;\n    for (var i = index; i < len; i++) {\n      var cell = this.cells[i];\n      cell.setPosition(cellX);\n      cellX += cell.size.outerWidth;\n      this.maxCellHeight = Math.max(cell.size.outerHeight, this.maxCellHeight);\n    }\n    // keep track of cellX for wrap-around\n    this.slideableWidth = cellX;\n    // slides\n    this.updateSlides();\n    // contain slides target\n    this._containSlides();\n    // update slidesWidth\n    this.slidesWidth = len ? this.getLastSlide().target - this.slides[0].target : 0;\n  };\n\n  /**\n   * cell.getSize() on multiple cells\n   * @param {Array} cells\n   */\n  proto._sizeCells = function (cells) {\n    cells.forEach(function (cell) {\n      cell.getSize();\n    });\n  };\n\n  // --------------------------  -------------------------- //\n\n  proto.updateSlides = function () {\n    this.slides = [];\n    if (!this.cells.length) {\n      return;\n    }\n\n    var slide = new Slide(this);\n    this.slides.push(slide);\n    var isOriginLeft = this.originSide == 'left';\n    var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';\n\n    var canCellFit = this._getCanCellFit();\n\n    this.cells.forEach(function (cell, i) {\n      // just add cell if first cell in slide\n      if (!slide.cells.length) {\n        slide.addCell(cell);\n        return;\n      }\n\n      var slideWidth = slide.outerWidth - slide.firstMargin + (cell.size.outerWidth - cell.size[nextMargin]);\n\n      if (canCellFit.call(this, i, slideWidth)) {\n        slide.addCell(cell);\n      } else {\n        // doesn't fit, new slide\n        slide.updateTarget();\n\n        slide = new Slide(this);\n        this.slides.push(slide);\n        slide.addCell(cell);\n      }\n    }, this);\n    // last slide\n    slide.updateTarget();\n    // update .selectedSlide\n    this.updateSelectedSlide();\n  };\n\n  proto._getCanCellFit = function () {\n    var groupCells = this.options.groupCells;\n    if (!groupCells) {\n      return function () {\n        return false;\n      };\n    } else if (typeof groupCells == 'number') {\n      // group by number. 3 -> [0,1,2], [3,4,5], ...\n      var number = parseInt(groupCells, 10);\n      return function (i) {\n        return i % number !== 0;\n      };\n    }\n    // default, group by width of slide\n    // parse '75%\n    var percentMatch = typeof groupCells == 'string' && groupCells.match(/^(\\d+)%$/);\n    var percent = percentMatch ? parseInt(percentMatch[1], 10) / 100 : 1;\n    return function (i, slideWidth) {\n      return slideWidth <= (this.size.innerWidth + 1) * percent;\n    };\n  };\n\n  // alias _init for jQuery plugin .flickity()\n  proto._init = proto.reposition = function () {\n    this.positionCells();\n    this.positionSliderAtSelected();\n  };\n\n  proto.getSize = function () {\n    this.size = getSize(this.element);\n    this.setCellAlign();\n    this.cursorPosition = this.size.innerWidth * this.cellAlign;\n  };\n\n  var cellAlignShorthands = {\n    // cell align, then based on origin side\n    center: {\n      left: 0.5,\n      right: 0.5\n    },\n    left: {\n      left: 0,\n      right: 1\n    },\n    right: {\n      right: 0,\n      left: 1\n    }\n  };\n\n  proto.setCellAlign = function () {\n    var shorthand = cellAlignShorthands[this.options.cellAlign];\n    this.cellAlign = shorthand ? shorthand[this.originSide] : this.options.cellAlign;\n  };\n\n  proto.setGallerySize = function () {\n    if (this.options.setGallerySize) {\n      var height = this.options.adaptiveHeight && this.selectedSlide ? this.selectedSlide.height : this.maxCellHeight;\n      this.viewport.style.height = height + 'px';\n    }\n  };\n\n  proto._getWrapShiftCells = function () {\n    // only for wrap-around\n    if (!this.options.wrapAround) {\n      return;\n    }\n    // unshift previous cells\n    this._unshiftCells(this.beforeShiftCells);\n    this._unshiftCells(this.afterShiftCells);\n    // get before cells\n    // initial gap\n    var gapX = this.cursorPosition;\n    var cellIndex = this.cells.length - 1;\n    this.beforeShiftCells = this._getGapCells(gapX, cellIndex, -1);\n    // get after cells\n    // ending gap between last cell and end of gallery viewport\n    gapX = this.size.innerWidth - this.cursorPosition;\n    // start cloning at first cell, working forwards\n    this.afterShiftCells = this._getGapCells(gapX, 0, 1);\n  };\n\n  proto._getGapCells = function (gapX, cellIndex, increment) {\n    // keep adding cells until the cover the initial gap\n    var cells = [];\n    while (gapX > 0) {\n      var cell = this.cells[cellIndex];\n      if (!cell) {\n        break;\n      }\n      cells.push(cell);\n      cellIndex += increment;\n      gapX -= cell.size.outerWidth;\n    }\n    return cells;\n  };\n\n  // ----- contain ----- //\n\n  // contain cell targets so no excess sliding\n  proto._containSlides = function () {\n    if (!this.options.contain || this.options.wrapAround || !this.cells.length) {\n      return;\n    }\n    var isRightToLeft = this.options.rightToLeft;\n    var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';\n    var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';\n    var contentWidth = this.slideableWidth - this.getLastCell().size[endMargin];\n    // content is less than gallery size\n    var isContentSmaller = contentWidth < this.size.innerWidth;\n    // bounds\n    var beginBound = this.cursorPosition + this.cells[0].size[beginMargin];\n    var endBound = contentWidth - this.size.innerWidth * (1 - this.cellAlign);\n    // contain each cell target\n    this.slides.forEach(function (slide) {\n      if (isContentSmaller) {\n        // all cells fit inside gallery\n        slide.target = contentWidth * this.cellAlign;\n      } else {\n        // contain to bounds\n        slide.target = Math.max(slide.target, beginBound);\n        slide.target = Math.min(slide.target, endBound);\n      }\n    }, this);\n  };\n\n  // -----  ----- //\n\n  /**\n   * emits events via eventEmitter and jQuery events\n   * @param {String} type - name of event\n   * @param {Event} event - original event\n   * @param {Array} args - extra arguments\n   */\n  proto.dispatchEvent = function (type, event, args) {\n    var emitArgs = event ? [event].concat(args) : args;\n    this.emitEvent(type, emitArgs);\n\n    if (jQuery && this.$element) {\n      // default trigger with type if no event\n      type += this.options.namespaceJQueryEvents ? '.flickity' : '';\n      var $event = type;\n      if (event) {\n        // create jQuery event\n        var jQEvent = jQuery.Event(event);\n        jQEvent.type = type;\n        $event = jQEvent;\n      }\n      this.$element.trigger($event, args);\n    }\n  };\n\n  // -------------------------- select -------------------------- //\n\n  /**\n   * @param {Integer} index - index of the slide\n   * @param {Boolean} isWrap - will wrap-around to last/first if at the end\n   * @param {Boolean} isInstant - will immediately set position at selected cell\n   */\n  proto.select = function (index, isWrap, isInstant) {\n    if (!this.isActive) {\n      return;\n    }\n    index = parseInt(index, 10);\n    this._wrapSelect(index);\n\n    if (this.options.wrapAround || isWrap) {\n      index = utils.modulo(index, this.slides.length);\n    }\n    // bail if invalid index\n    if (!this.slides[index]) {\n      return;\n    }\n    var prevIndex = this.selectedIndex;\n    this.selectedIndex = index;\n    this.updateSelectedSlide();\n    if (isInstant) {\n      this.positionSliderAtSelected();\n    } else {\n      this.startAnimation();\n    }\n    if (this.options.adaptiveHeight) {\n      this.setGallerySize();\n    }\n    // events\n    this.dispatchEvent('select', null, [index]);\n    // change event if new index\n    if (index != prevIndex) {\n      this.dispatchEvent('change', null, [index]);\n    }\n    // old v1 event name, remove in v3\n    this.dispatchEvent('cellSelect');\n  };\n\n  // wraps position for wrapAround, to move to closest slide. #113\n  proto._wrapSelect = function (index) {\n    var len = this.slides.length;\n    var isWrapping = this.options.wrapAround && len > 1;\n    if (!isWrapping) {\n      return index;\n    }\n    var wrapIndex = utils.modulo(index, len);\n    // go to shortest\n    var delta = Math.abs(wrapIndex - this.selectedIndex);\n    var backWrapDelta = Math.abs(wrapIndex + len - this.selectedIndex);\n    var forewardWrapDelta = Math.abs(wrapIndex - len - this.selectedIndex);\n    if (!this.isDragSelect && backWrapDelta < delta) {\n      index += len;\n    } else if (!this.isDragSelect && forewardWrapDelta < delta) {\n      index -= len;\n    }\n    // wrap position so slider is within normal area\n    if (index < 0) {\n      this.x -= this.slideableWidth;\n    } else if (index >= len) {\n      this.x += this.slideableWidth;\n    }\n  };\n\n  proto.previous = function (isWrap, isInstant) {\n    this.select(this.selectedIndex - 1, isWrap, isInstant);\n  };\n\n  proto.next = function (isWrap, isInstant) {\n    this.select(this.selectedIndex + 1, isWrap, isInstant);\n  };\n\n  proto.updateSelectedSlide = function () {\n    var slide = this.slides[this.selectedIndex];\n    // selectedIndex could be outside of slides, if triggered before resize()\n    if (!slide) {\n      return;\n    }\n    // unselect previous selected slide\n    this.unselectSelectedSlide();\n    // update new selected slide\n    this.selectedSlide = slide;\n    slide.select();\n    this.selectedCells = slide.cells;\n    this.selectedElements = slide.getCellElements();\n    // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility\n    // Remove in v3?\n    this.selectedCell = slide.cells[0];\n    this.selectedElement = this.selectedElements[0];\n  };\n\n  proto.unselectSelectedSlide = function () {\n    if (this.selectedSlide) {\n      this.selectedSlide.unselect();\n    }\n  };\n\n  /**\n   * select slide from number or cell element\n   * @param {Element or Number} elem\n   */\n  proto.selectCell = function (value, isWrap, isInstant) {\n    // get cell\n    var cell = this.queryCell(value);\n    if (!cell) {\n      return;\n    }\n\n    var index = this.getCellSlideIndex(cell);\n    this.select(index, isWrap, isInstant);\n  };\n\n  proto.getCellSlideIndex = function (cell) {\n    // get index of slides that has cell\n    for (var i = 0; i < this.slides.length; i++) {\n      var slide = this.slides[i];\n      var index = slide.cells.indexOf(cell);\n      if (index != -1) {\n        return i;\n      }\n    }\n  };\n\n  // -------------------------- get cells -------------------------- //\n\n  /**\n   * get Flickity.Cell, given an Element\n   * @param {Element} elem\n   * @returns {Flickity.Cell} item\n   */\n  proto.getCell = function (elem) {\n    // loop through cells to get the one that matches\n    for (var i = 0; i < this.cells.length; i++) {\n      var cell = this.cells[i];\n      if (cell.element == elem) {\n        return cell;\n      }\n    }\n  };\n\n  /**\n   * get collection of Flickity.Cells, given Elements\n   * @param {Element, Array, NodeList} elems\n   * @returns {Array} cells - Flickity.Cells\n   */\n  proto.getCells = function (elems) {\n    elems = utils.makeArray(elems);\n    var cells = [];\n    elems.forEach(function (elem) {\n      var cell = this.getCell(elem);\n      if (cell) {\n        cells.push(cell);\n      }\n    }, this);\n    return cells;\n  };\n\n  /**\n   * get cell elements\n   * @returns {Array} cellElems\n   */\n  proto.getCellElements = function () {\n    return this.cells.map(function (cell) {\n      return cell.element;\n    });\n  };\n\n  /**\n   * get parent cell from an element\n   * @param {Element} elem\n   * @returns {Flickit.Cell} cell\n   */\n  proto.getParentCell = function (elem) {\n    // first check if elem is cell\n    var cell = this.getCell(elem);\n    if (cell) {\n      return cell;\n    }\n    // try to get parent cell elem\n    elem = utils.getParent(elem, '.flickity-slider > *');\n    return this.getCell(elem);\n  };\n\n  /**\n   * get cells adjacent to a slide\n   * @param {Integer} adjCount - number of adjacent slides\n   * @param {Integer} index - index of slide to start\n   * @returns {Array} cells - array of Flickity.Cells\n   */\n  proto.getAdjacentCellElements = function (adjCount, index) {\n    if (!adjCount) {\n      return this.selectedSlide.getCellElements();\n    }\n    index = index === undefined ? this.selectedIndex : index;\n\n    var len = this.slides.length;\n    if (1 + adjCount * 2 >= len) {\n      return this.getCellElements();\n    }\n\n    var cellElems = [];\n    for (var i = index - adjCount; i <= index + adjCount; i++) {\n      var slideIndex = this.options.wrapAround ? utils.modulo(i, len) : i;\n      var slide = this.slides[slideIndex];\n      if (slide) {\n        cellElems = cellElems.concat(slide.getCellElements());\n      }\n    }\n    return cellElems;\n  };\n\n  /**\n   * select slide from number or cell element\n   * @param {Element, Selector String, or Number} selector\n   */\n  proto.queryCell = function (selector) {\n    if (typeof selector == 'number') {\n      // use number as index\n      return this.cells[selector];\n    }\n    if (typeof selector == 'string') {\n      // use string as selector, get element\n      selector = this.element.querySelector(selector);\n    }\n    // get cell from element\n    return this.getCell(selector);\n  };\n\n  // -------------------------- events -------------------------- //\n\n  proto.uiChange = function () {\n    this.emitEvent('uiChange');\n  };\n\n  proto.childUIPointerDown = function (event) {\n    this.emitEvent('childUIPointerDown', [event]);\n  };\n\n  // ----- resize ----- //\n\n  proto.onresize = function () {\n    this.watchCSS();\n    this.resize();\n  };\n\n  utils.debounceMethod(Flickity, 'onresize', 150);\n\n  proto.resize = function () {\n    if (!this.isActive) {\n      return;\n    }\n    this.getSize();\n    // wrap values\n    if (this.options.wrapAround) {\n      this.x = utils.modulo(this.x, this.slideableWidth);\n    }\n    this.positionCells();\n    this._getWrapShiftCells();\n    this.setGallerySize();\n    this.emitEvent('resize');\n    // update selected index for group slides, instant\n    // TODO: position can be lost between groups of various numbers\n    var selectedElement = this.selectedElements && this.selectedElements[0];\n    this.selectCell(selectedElement, false, true);\n  };\n\n  // watches the :after property, activates/deactivates\n  proto.watchCSS = function () {\n    var watchOption = this.options.watchCSS;\n    if (!watchOption) {\n      return;\n    }\n\n    var afterContent = getComputedStyle(this.element, ':after').content;\n    // activate if :after { content: 'flickity' }\n    if (afterContent.indexOf('flickity') != -1) {\n      this.activate();\n    } else {\n      this.deactivate();\n    }\n  };\n\n  // ----- keydown ----- //\n\n  // go previous/next if left/right keys pressed\n  proto.onkeydown = function (event) {\n    // only work if element is in focus\n    var isNotFocused = document.activeElement && document.activeElement != this.element;\n    if (!this.options.accessibility || isNotFocused) {\n      return;\n    }\n\n    var handler = Flickity.keyboardHandlers[event.keyCode];\n    if (handler) {\n      handler.call(this);\n    }\n  };\n\n  Flickity.keyboardHandlers = {\n    // left arrow\n    37: function () {\n      var leftMethod = this.options.rightToLeft ? 'next' : 'previous';\n      this.uiChange();\n      this[leftMethod]();\n    },\n    // right arrow\n    39: function () {\n      var rightMethod = this.options.rightToLeft ? 'previous' : 'next';\n      this.uiChange();\n      this[rightMethod]();\n    }\n  };\n\n  // ----- focus ----- //\n\n  proto.focus = function () {\n    // TODO remove scrollTo once focus options gets more support\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#Browser_compatibility\n    var prevScrollY = window.pageYOffset;\n    this.element.focus({ preventScroll: true });\n    // hack to fix scroll jump after focus, #76\n    if (window.pageYOffset != prevScrollY) {\n      window.scrollTo(window.pageXOffset, prevScrollY);\n    }\n  };\n\n  // -------------------------- destroy -------------------------- //\n\n  // deactivate all Flickity functionality, but keep stuff available\n  proto.deactivate = function () {\n    if (!this.isActive) {\n      return;\n    }\n    this.element.classList.remove('flickity-enabled');\n    this.element.classList.remove('flickity-rtl');\n    this.unselectSelectedSlide();\n    // destroy cells\n    this.cells.forEach(function (cell) {\n      cell.destroy();\n    });\n    this.element.removeChild(this.viewport);\n    // move child elements back into element\n    moveElements(this.slider.children, this.element);\n    if (this.options.accessibility) {\n      this.element.removeAttribute('tabIndex');\n      this.element.removeEventListener('keydown', this);\n    }\n    // set flags\n    this.isActive = false;\n    this.emitEvent('deactivate');\n  };\n\n  proto.destroy = function () {\n    this.deactivate();\n    window.removeEventListener('resize', this);\n    this.emitEvent('destroy');\n    if (jQuery && this.$element) {\n      jQuery.removeData(this.element, 'flickity');\n    }\n    delete this.element.flickityGUID;\n    delete instances[this.guid];\n  };\n\n  // -------------------------- prototype -------------------------- //\n\n  utils.extend(proto, animatePrototype);\n\n  // -------------------------- extras -------------------------- //\n\n  /**\n   * get Flickity instance from element\n   * @param {Element} elem\n   * @returns {Flickity}\n   */\n  Flickity.data = function (elem) {\n    elem = utils.getQueryElement(elem);\n    var id = elem && elem.flickityGUID;\n    return id && instances[id];\n  };\n\n  utils.htmlInit(Flickity, 'flickity');\n\n  if (jQuery && jQuery.bridget) {\n    jQuery.bridget('flickity', Flickity);\n  }\n\n  // set internal jQuery, for Webpack + jQuery v3, #478\n  Flickity.setJQuery = function (jq) {\n    jQuery = jq;\n  };\n\n  Flickity.Cell = Cell;\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/flickity.js?")},"./node_modules/flickity/js/index.js":function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n/*!\n * Flickity v2.1.2\n * Touch, responsive, flickable carousels\n *\n * Licensed GPLv3 for open source use\n * or Flickity Commercial License for commercial use\n *\n * https://flickity.metafizzy.co\n * Copyright 2015-2018 Metafizzy\n */\n\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['./flickity', './drag', './prev-next-button', './page-dots', './player', './add-remove-cell', './lazyload'], factory);\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(__webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! ./drag */ \"./node_modules/flickity/js/drag.js\"), __webpack_require__(/*! ./prev-next-button */ \"./node_modules/flickity/js/prev-next-button.js\"), __webpack_require__(/*! ./page-dots */ \"./node_modules/flickity/js/page-dots.js\"), __webpack_require__(/*! ./player */ \"./node_modules/flickity/js/player.js\"), __webpack_require__(/*! ./add-remove-cell */ \"./node_modules/flickity/js/add-remove-cell.js\"), __webpack_require__(/*! ./lazyload */ \"./node_modules/flickity/js/lazyload.js\"));\n  }\n})(window, function factory(Flickity) {\n  /*jshint strict: false*/\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/index.js?")},"./node_modules/flickity/js/lazyload.js":function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n// lazyload\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['./flickity', 'fizzy-ui-utils/utils'], function (Flickity, utils) {\n      return factory(window, Flickity, utils);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! fizzy-ui-utils */ \"./node_modules/fizzy-ui-utils/utils.js\"));\n  } else {\n    // browser global\n    factory(window, window.Flickity, window.fizzyUIUtils);\n  }\n})(window, function factory(window, Flickity, utils) {\n  'use strict';\n\n  Flickity.createMethods.push('_createLazyload');\n  var proto = Flickity.prototype;\n\n  proto._createLazyload = function () {\n    this.on('select', this.lazyLoad);\n  };\n\n  proto.lazyLoad = function () {\n    var lazyLoad = this.options.lazyLoad;\n    if (!lazyLoad) {\n      return;\n    }\n    // get adjacent cells, use lazyLoad option for adjacent count\n    var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;\n    var cellElems = this.getAdjacentCellElements(adjCount);\n    // get lazy images in those cells\n    var lazyImages = [];\n    cellElems.forEach(function (cellElem) {\n      var lazyCellImages = getCellLazyImages(cellElem);\n      lazyImages = lazyImages.concat(lazyCellImages);\n    });\n    // load lazy images\n    lazyImages.forEach(function (img) {\n      new LazyLoader(img, this);\n    }, this);\n  };\n\n  function getCellLazyImages(cellElem) {\n    // check if cell element is lazy image\n    if (cellElem.nodeName == 'IMG') {\n      var lazyloadAttr = cellElem.getAttribute('data-flickity-lazyload');\n      var srcAttr = cellElem.getAttribute('data-flickity-lazyload-src');\n      var srcsetAttr = cellElem.getAttribute('data-flickity-lazyload-srcset');\n      if (lazyloadAttr || srcAttr || srcsetAttr) {\n        return [cellElem];\n      }\n    }\n    // select lazy images in cell\n    var lazySelector = 'img[data-flickity-lazyload], ' + 'img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]';\n    var imgs = cellElem.querySelectorAll(lazySelector);\n    return utils.makeArray(imgs);\n  }\n\n  // -------------------------- LazyLoader -------------------------- //\n\n  /**\n   * class to handle loading images\n   */\n  function LazyLoader(img, flickity) {\n    this.img = img;\n    this.flickity = flickity;\n    this.load();\n  }\n\n  LazyLoader.prototype.handleEvent = utils.handleEvent;\n\n  LazyLoader.prototype.load = function () {\n    this.img.addEventListener('load', this);\n    this.img.addEventListener('error', this);\n    // get src & srcset\n    var src = this.img.getAttribute('data-flickity-lazyload') || this.img.getAttribute('data-flickity-lazyload-src');\n    var srcset = this.img.getAttribute('data-flickity-lazyload-srcset');\n    // set src & serset\n    this.img.src = src;\n    if (srcset) {\n      this.img.setAttribute('srcset', srcset);\n    }\n    // remove attr\n    this.img.removeAttribute('data-flickity-lazyload');\n    this.img.removeAttribute('data-flickity-lazyload-src');\n    this.img.removeAttribute('data-flickity-lazyload-srcset');\n  };\n\n  LazyLoader.prototype.onload = function (event) {\n    this.complete(event, 'flickity-lazyloaded');\n  };\n\n  LazyLoader.prototype.onerror = function (event) {\n    this.complete(event, 'flickity-lazyerror');\n  };\n\n  LazyLoader.prototype.complete = function (event, className) {\n    // unbind events\n    this.img.removeEventListener('load', this);\n    this.img.removeEventListener('error', this);\n\n    var cell = this.flickity.getParentCell(this.img);\n    var cellElem = cell && cell.element;\n    this.flickity.cellSizeChange(cellElem);\n\n    this.img.classList.add(className);\n    this.flickity.dispatchEvent('lazyLoad', event, cellElem);\n  };\n\n  // -----  ----- //\n\n  Flickity.LazyLoader = LazyLoader;\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/lazyload.js?")},"./node_modules/flickity/js/page-dots.js":function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n// page dots\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['./flickity', 'tap-listener/tap-listener', 'fizzy-ui-utils/utils'], function (Flickity, TapListener, utils) {\n      return factory(window, Flickity, TapListener, utils);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! tap-listener */ \"./node_modules/tap-listener/tap-listener.js\"), __webpack_require__(/*! fizzy-ui-utils */ \"./node_modules/fizzy-ui-utils/utils.js\"));\n  } else {\n    // browser global\n    factory(window, window.Flickity, window.TapListener, window.fizzyUIUtils);\n  }\n})(window, function factory(window, Flickity, TapListener, utils) {\n\n  // -------------------------- PageDots -------------------------- //\n\n  'use strict';\n\n  function PageDots(parent) {\n    this.parent = parent;\n    this._create();\n  }\n\n  PageDots.prototype = new TapListener();\n\n  PageDots.prototype._create = function () {\n    // create holder element\n    this.holder = document.createElement('ol');\n    this.holder.className = 'flickity-page-dots';\n    // create dots, array of elements\n    this.dots = [];\n    // events\n    this.on('tap', this.onTap);\n    this.on('pointerDown', this.parent.childUIPointerDown.bind(this.parent));\n  };\n\n  PageDots.prototype.activate = function () {\n    this.setDots();\n    this.bindTap(this.holder);\n    // add to DOM\n    this.parent.element.appendChild(this.holder);\n  };\n\n  PageDots.prototype.deactivate = function () {\n    // remove from DOM\n    this.parent.element.removeChild(this.holder);\n    TapListener.prototype.destroy.call(this);\n  };\n\n  PageDots.prototype.setDots = function () {\n    // get difference between number of slides and number of dots\n    var delta = this.parent.slides.length - this.dots.length;\n    if (delta > 0) {\n      this.addDots(delta);\n    } else if (delta < 0) {\n      this.removeDots(-delta);\n    }\n  };\n\n  PageDots.prototype.addDots = function (count) {\n    var fragment = document.createDocumentFragment();\n    var newDots = [];\n    var length = this.dots.length;\n    var max = length + count;\n\n    for (var i = length; i < max; i++) {\n      var dot = document.createElement('li');\n      dot.className = 'dot';\n      dot.setAttribute('aria-label', 'Page dot ' + (i + 1));\n      fragment.appendChild(dot);\n      newDots.push(dot);\n    }\n\n    this.holder.appendChild(fragment);\n    this.dots = this.dots.concat(newDots);\n  };\n\n  PageDots.prototype.removeDots = function (count) {\n    // remove from this.dots collection\n    var removeDots = this.dots.splice(this.dots.length - count, count);\n    // remove from DOM\n    removeDots.forEach(function (dot) {\n      this.holder.removeChild(dot);\n    }, this);\n  };\n\n  PageDots.prototype.updateSelected = function () {\n    // remove selected class on previous\n    if (this.selectedDot) {\n      this.selectedDot.className = 'dot';\n      this.selectedDot.removeAttribute('aria-current');\n    }\n    // don't proceed if no dots\n    if (!this.dots.length) {\n      return;\n    }\n    this.selectedDot = this.dots[this.parent.selectedIndex];\n    this.selectedDot.className = 'dot is-selected';\n    this.selectedDot.setAttribute('aria-current', 'step');\n  };\n\n  PageDots.prototype.onTap = function (event) {\n    var target = event.target;\n    // only care about dot clicks\n    if (target.nodeName != 'LI') {\n      return;\n    }\n\n    this.parent.uiChange();\n    var index = this.dots.indexOf(target);\n    this.parent.select(index);\n  };\n\n  PageDots.prototype.destroy = function () {\n    this.deactivate();\n  };\n\n  Flickity.PageDots = PageDots;\n\n  // -------------------------- Flickity -------------------------- //\n\n  utils.extend(Flickity.defaults, {\n    pageDots: true\n  });\n\n  Flickity.createMethods.push('_createPageDots');\n\n  var proto = Flickity.prototype;\n\n  proto._createPageDots = function () {\n    if (!this.options.pageDots) {\n      return;\n    }\n    this.pageDots = new PageDots(this);\n    // events\n    this.on('activate', this.activatePageDots);\n    this.on('select', this.updateSelectedPageDots);\n    this.on('cellChange', this.updatePageDots);\n    this.on('resize', this.updatePageDots);\n    this.on('deactivate', this.deactivatePageDots);\n  };\n\n  proto.activatePageDots = function () {\n    this.pageDots.activate();\n  };\n\n  proto.updateSelectedPageDots = function () {\n    this.pageDots.updateSelected();\n  };\n\n  proto.updatePageDots = function () {\n    this.pageDots.setDots();\n  };\n\n  proto.deactivatePageDots = function () {\n    this.pageDots.deactivate();\n  };\n\n  // -----  ----- //\n\n  Flickity.PageDots = PageDots;\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/page-dots.js?")},"./node_modules/flickity/js/player.js":function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n// player & autoPlay\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['ev-emitter/ev-emitter', 'fizzy-ui-utils/utils', './flickity'], function (EvEmitter, utils, Flickity) {\n      return factory(EvEmitter, utils, Flickity);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(__webpack_require__(/*! ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\"), __webpack_require__(/*! fizzy-ui-utils */ \"./node_modules/fizzy-ui-utils/utils.js\"), __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"));\n  } else {\n    // browser global\n    factory(window.EvEmitter, window.fizzyUIUtils, window.Flickity);\n  }\n})(window, function factory(EvEmitter, utils, Flickity) {\n\n  'use strict';\n\n  // -------------------------- Player -------------------------- //\n\n  function Player(parent) {\n    this.parent = parent;\n    this.state = 'stopped';\n    // visibility change event handler\n    this.onVisibilityChange = this.visibilityChange.bind(this);\n    this.onVisibilityPlay = this.visibilityPlay.bind(this);\n  }\n\n  Player.prototype = Object.create(EvEmitter.prototype);\n\n  // start play\n  Player.prototype.play = function () {\n    if (this.state == 'playing') {\n      return;\n    }\n    // do not play if page is hidden, start playing when page is visible\n    var isPageHidden = document.hidden;\n    if (isPageHidden) {\n      document.addEventListener('visibilitychange', this.onVisibilityPlay);\n      return;\n    }\n\n    this.state = 'playing';\n    // listen to visibility change\n    document.addEventListener('visibilitychange', this.onVisibilityChange);\n    // start ticking\n    this.tick();\n  };\n\n  Player.prototype.tick = function () {\n    // do not tick if not playing\n    if (this.state != 'playing') {\n      return;\n    }\n\n    var time = this.parent.options.autoPlay;\n    // default to 3 seconds\n    time = typeof time == 'number' ? time : 3000;\n    var _this = this;\n    // HACK: reset ticks if stopped and started within interval\n    this.clear();\n    this.timeout = setTimeout(function () {\n      _this.parent.next(true);\n      _this.tick();\n    }, time);\n  };\n\n  Player.prototype.stop = function () {\n    this.state = 'stopped';\n    this.clear();\n    // remove visibility change event\n    document.removeEventListener('visibilitychange', this.onVisibilityChange);\n  };\n\n  Player.prototype.clear = function () {\n    clearTimeout(this.timeout);\n  };\n\n  Player.prototype.pause = function () {\n    if (this.state == 'playing') {\n      this.state = 'paused';\n      this.clear();\n    }\n  };\n\n  Player.prototype.unpause = function () {\n    // re-start play if paused\n    if (this.state == 'paused') {\n      this.play();\n    }\n  };\n\n  // pause if page visibility is hidden, unpause if visible\n  Player.prototype.visibilityChange = function () {\n    var isPageHidden = document.hidden;\n    this[isPageHidden ? 'pause' : 'unpause']();\n  };\n\n  Player.prototype.visibilityPlay = function () {\n    this.play();\n    document.removeEventListener('visibilitychange', this.onVisibilityPlay);\n  };\n\n  // -------------------------- Flickity -------------------------- //\n\n  utils.extend(Flickity.defaults, {\n    pauseAutoPlayOnHover: true\n  });\n\n  Flickity.createMethods.push('_createPlayer');\n  var proto = Flickity.prototype;\n\n  proto._createPlayer = function () {\n    this.player = new Player(this);\n\n    this.on('activate', this.activatePlayer);\n    this.on('uiChange', this.stopPlayer);\n    this.on('pointerDown', this.stopPlayer);\n    this.on('deactivate', this.deactivatePlayer);\n  };\n\n  proto.activatePlayer = function () {\n    if (!this.options.autoPlay) {\n      return;\n    }\n    this.player.play();\n    this.element.addEventListener('mouseenter', this);\n  };\n\n  // Player API, don't hate the ... thanks I know where the door is\n\n  proto.playPlayer = function () {\n    this.player.play();\n  };\n\n  proto.stopPlayer = function () {\n    this.player.stop();\n  };\n\n  proto.pausePlayer = function () {\n    this.player.pause();\n  };\n\n  proto.unpausePlayer = function () {\n    this.player.unpause();\n  };\n\n  proto.deactivatePlayer = function () {\n    this.player.stop();\n    this.element.removeEventListener('mouseenter', this);\n  };\n\n  // ----- mouseenter/leave ----- //\n\n  // pause auto-play on hover\n  proto.onmouseenter = function () {\n    if (!this.options.pauseAutoPlayOnHover) {\n      return;\n    }\n    this.player.pause();\n    this.element.addEventListener('mouseleave', this);\n  };\n\n  // resume auto-play on hover off\n  proto.onmouseleave = function () {\n    this.player.unpause();\n    this.element.removeEventListener('mouseleave', this);\n  };\n\n  // -----  ----- //\n\n  Flickity.Player = Player;\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/player.js?")},"./node_modules/flickity/js/prev-next-button.js":function(module,exports,__webpack_require__){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n// prev/next buttons\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['./flickity', 'tap-listener/tap-listener', 'fizzy-ui-utils/utils'], function (Flickity, TapListener, utils) {\n      return factory(window, Flickity, TapListener, utils);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! tap-listener */ \"./node_modules/tap-listener/tap-listener.js\"), __webpack_require__(/*! fizzy-ui-utils */ \"./node_modules/fizzy-ui-utils/utils.js\"));\n  } else {\n    // browser global\n    factory(window, window.Flickity, window.TapListener, window.fizzyUIUtils);\n  }\n})(window, function factory(window, Flickity, TapListener, utils) {\n  'use strict';\n\n  var svgURI = 'http://www.w3.org/2000/svg';\n\n  // -------------------------- PrevNextButton -------------------------- //\n\n  function PrevNextButton(direction, parent) {\n    this.direction = direction;\n    this.parent = parent;\n    this._create();\n  }\n\n  PrevNextButton.prototype = Object.create(TapListener.prototype);\n\n  PrevNextButton.prototype._create = function () {\n    // properties\n    this.isEnabled = true;\n    this.isPrevious = this.direction == -1;\n    var leftDirection = this.parent.options.rightToLeft ? 1 : -1;\n    this.isLeft = this.direction == leftDirection;\n\n    var element = this.element = document.createElement('button');\n    element.className = 'flickity-button flickity-prev-next-button';\n    element.className += this.isPrevious ? ' previous' : ' next';\n    // prevent button from submitting form http://stackoverflow.com/a/10836076/182183\n    element.setAttribute('type', 'button');\n    // init as disabled\n    this.disable();\n\n    element.setAttribute('aria-label', this.isPrevious ? 'Previous' : 'Next');\n\n    // create arrow\n    var svg = this.createSVG();\n    element.appendChild(svg);\n    // events\n    this.on('tap', this.onTap);\n    this.parent.on('select', this.update.bind(this));\n    this.on('pointerDown', this.parent.childUIPointerDown.bind(this.parent));\n  };\n\n  PrevNextButton.prototype.activate = function () {\n    this.bindTap(this.element);\n    // click events from keyboard\n    this.element.addEventListener('click', this);\n    // add to DOM\n    this.parent.element.appendChild(this.element);\n  };\n\n  PrevNextButton.prototype.deactivate = function () {\n    // remove from DOM\n    this.parent.element.removeChild(this.element);\n    // do regular TapListener destroy\n    TapListener.prototype.destroy.call(this);\n    // click events from keyboard\n    this.element.removeEventListener('click', this);\n  };\n\n  PrevNextButton.prototype.createSVG = function () {\n    var svg = document.createElementNS(svgURI, 'svg');\n    svg.setAttribute('class', 'flickity-button-icon');\n    svg.setAttribute('viewBox', '0 0 100 100');\n    var path = document.createElementNS(svgURI, 'path');\n    var pathMovements = getArrowMovements(this.parent.options.arrowShape);\n    path.setAttribute('d', pathMovements);\n    path.setAttribute('class', 'arrow');\n    // rotate arrow\n    if (!this.isLeft) {\n      path.setAttribute('transform', 'translate(100, 100) rotate(180) ');\n    }\n    svg.appendChild(path);\n    return svg;\n  };\n\n  // get SVG path movmement\n  function getArrowMovements(shape) {\n    // use shape as movement if string\n    if (typeof shape == 'string') {\n      return shape;\n    }\n    // create movement string\n    return 'M ' + shape.x0 + ',50' + ' L ' + shape.x1 + ',' + (shape.y1 + 50) + ' L ' + shape.x2 + ',' + (shape.y2 + 50) + ' L ' + shape.x3 + ',50 ' + ' L ' + shape.x2 + ',' + (50 - shape.y2) + ' L ' + shape.x1 + ',' + (50 - shape.y1) + ' Z';\n  }\n\n  PrevNextButton.prototype.onTap = function () {\n    if (!this.isEnabled) {\n      return;\n    }\n    this.parent.uiChange();\n    var method = this.isPrevious ? 'previous' : 'next';\n    this.parent[method]();\n  };\n\n  PrevNextButton.prototype.handleEvent = utils.handleEvent;\n\n  PrevNextButton.prototype.onclick = function (event) {\n    // only allow clicks from keyboard\n    var focused = document.activeElement;\n    if (focused && focused == this.element) {\n      this.onTap(event, event);\n    }\n  };\n\n  // -----  ----- //\n\n  PrevNextButton.prototype.enable = function () {\n    if (this.isEnabled) {\n      return;\n    }\n    this.element.disabled = false;\n    this.isEnabled = true;\n  };\n\n  PrevNextButton.prototype.disable = function () {\n    if (!this.isEnabled) {\n      return;\n    }\n    this.element.disabled = true;\n    this.isEnabled = false;\n  };\n\n  PrevNextButton.prototype.update = function () {\n    // index of first or last slide, if previous or next\n    var slides = this.parent.slides;\n    // enable is wrapAround and at least 2 slides\n    if (this.parent.options.wrapAround && slides.length > 1) {\n      this.enable();\n      return;\n    }\n    var lastIndex = slides.length ? slides.length - 1 : 0;\n    var boundIndex = this.isPrevious ? 0 : lastIndex;\n    var method = this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';\n    this[method]();\n  };\n\n  PrevNextButton.prototype.destroy = function () {\n    this.deactivate();\n  };\n\n  // -------------------------- Flickity prototype -------------------------- //\n\n  utils.extend(Flickity.defaults, {\n    prevNextButtons: true,\n    arrowShape: {\n      x0: 10,\n      x1: 60, y1: 50,\n      x2: 70, y2: 40,\n      x3: 30\n    }\n  });\n\n  Flickity.createMethods.push('_createPrevNextButtons');\n  var proto = Flickity.prototype;\n\n  proto._createPrevNextButtons = function () {\n    if (!this.options.prevNextButtons) {\n      return;\n    }\n\n    this.prevButton = new PrevNextButton(-1, this);\n    this.nextButton = new PrevNextButton(1, this);\n\n    this.on('activate', this.activatePrevNextButtons);\n  };\n\n  proto.activatePrevNextButtons = function () {\n    this.prevButton.activate();\n    this.nextButton.activate();\n    this.on('deactivate', this.deactivatePrevNextButtons);\n  };\n\n  proto.deactivatePrevNextButtons = function () {\n    this.prevButton.deactivate();\n    this.nextButton.deactivate();\n    this.off('deactivate', this.deactivatePrevNextButtons);\n  };\n\n  // --------------------------  -------------------------- //\n\n  Flickity.PrevNextButton = PrevNextButton;\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/prev-next-button.js?")},"./node_modules/flickity/js/slide.js":function(module,exports){eval("/*** IMPORTS FROM imports-loader ***/\nvar define = undefined;\n\n// slide\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(factory);\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory();\n  } else {\n    // browser global\n    window.Flickity = window.Flickity || {};\n    window.Flickity.Slide = factory();\n  }\n})(window, function factory() {\n  'use strict';\n\n  function Slide(parent) {\n    this.parent = parent;\n    this.isOriginLeft = parent.originSide == 'left';\n    this.cells = [];\n    this.outerWidth = 0;\n    this.height = 0;\n  }\n\n  var proto = Slide.prototype;\n\n  proto.addCell = function (cell) {\n    this.cells.push(cell);\n    this.outerWidth += cell.size.outerWidth;\n    this.height = Math.max(cell.size.outerHeight, this.height);\n    // first cell stuff\n    if (this.cells.length == 1) {\n      this.x = cell.x; // x comes from first cell\n      var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';\n      this.firstMargin = cell.size[beginMargin];\n    }\n  };\n\n  proto.updateTarget = function () {\n    var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';\n    var lastCell = this.getLastCell();\n    var lastMargin = lastCell ? lastCell.size[endMargin] : 0;\n    var slideWidth = this.outerWidth - (this.firstMargin + lastMargin);\n    this.target = this.x + this.firstMargin + slideWidth * this.parent.cellAlign;\n  };\n\n  proto.getLastCell = function () {\n    return this.cells[this.cells.length - 1];\n  };\n\n  proto.select = function () {\n    this.changeSelected(true);\n  };\n\n  proto.unselect = function () {\n    this.changeSelected(false);\n  };\n\n  proto.changeSelected = function (isSelected) {\n    var classMethod = isSelected ? 'add' : 'remove';\n    this.cells.forEach(function (cell) {\n      cell.element.classList[classMethod]('is-selected');\n      cell.element.setAttribute('aria-selected', isSelected.toString());\n    });\n  };\n\n  proto.getCellElements = function () {\n    return this.cells.map(function (cell) {\n      return cell.element;\n    });\n  };\n\n  return Slide;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/slide.js?")},"./node_modules/get-size/get-size.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * getSize v2.0.3\n * measure size of elements\n * MIT license\n */\n\n/* jshint browser: true, strict: true, undef: true, unused: true */\n/* globals console: false */\n\n(function (window, factory) {\n  /* jshint strict: false */ /* globals define, module */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory() {\n  'use strict';\n\n  // -------------------------- helpers -------------------------- //\n\n  // get a number from a string, not a percentage\n\n  function getStyleSize(value) {\n    var num = parseFloat(value);\n    // not a percent like '100%', and a number\n    var isValid = value.indexOf('%') == -1 && !isNaN(num);\n    return isValid && num;\n  }\n\n  function noop() {}\n\n  var logError = typeof console == 'undefined' ? noop : function (message) {\n    console.error(message);\n  };\n\n  // -------------------------- measurements -------------------------- //\n\n  var measurements = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth'];\n\n  var measurementsLength = measurements.length;\n\n  function getZeroSize() {\n    var size = {\n      width: 0,\n      height: 0,\n      innerWidth: 0,\n      innerHeight: 0,\n      outerWidth: 0,\n      outerHeight: 0\n    };\n    for (var i = 0; i < measurementsLength; i++) {\n      var measurement = measurements[i];\n      size[measurement] = 0;\n    }\n    return size;\n  }\n\n  // -------------------------- getStyle -------------------------- //\n\n  /**\n   * getStyle, get style of element, check for Firefox bug\n   * https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n   */\n  function getStyle(elem) {\n    var style = getComputedStyle(elem);\n    if (!style) {\n      logError('Style returned ' + style + '. Are you running this code in a hidden iframe on Firefox? ' + 'See https://bit.ly/getsizebug1');\n    }\n    return style;\n  }\n\n  // -------------------------- setup -------------------------- //\n\n  var isSetup = false;\n\n  var isBoxSizeOuter;\n\n  /**\n   * setup\n   * check isBoxSizerOuter\n   * do on first getSize() rather than on page load for Firefox bug\n   */\n  function setup() {\n    // setup once\n    if (isSetup) {\n      return;\n    }\n    isSetup = true;\n\n    // -------------------------- box sizing -------------------------- //\n\n    /**\n     * Chrome & Safari measure the outer-width on style.width on border-box elems\n     * IE11 & Firefox<29 measures the inner-width\n     */\n    var div = document.createElement('div');\n    div.style.width = '200px';\n    div.style.padding = '1px 2px 3px 4px';\n    div.style.borderStyle = 'solid';\n    div.style.borderWidth = '1px 2px 3px 4px';\n    div.style.boxSizing = 'border-box';\n\n    var body = document.body || document.documentElement;\n    body.appendChild(div);\n    var style = getStyle(div);\n    // round value for browser zoom. desandro/masonry#928\n    isBoxSizeOuter = Math.round(getStyleSize(style.width)) == 200;\n    getSize.isBoxSizeOuter = isBoxSizeOuter;\n\n    body.removeChild(div);\n  }\n\n  // -------------------------- getSize -------------------------- //\n\n  function getSize(elem) {\n    setup();\n\n    // use querySeletor if elem is string\n    if (typeof elem == 'string') {\n      elem = document.querySelector(elem);\n    }\n\n    // do not proceed on non-objects\n    if (!elem || typeof elem != 'object' || !elem.nodeType) {\n      return;\n    }\n\n    var style = getStyle(elem);\n\n    // if hidden, everything is 0\n    if (style.display == 'none') {\n      return getZeroSize();\n    }\n\n    var size = {};\n    size.width = elem.offsetWidth;\n    size.height = elem.offsetHeight;\n\n    var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';\n\n    // get all measurements\n    for (var i = 0; i < measurementsLength; i++) {\n      var measurement = measurements[i];\n      var value = style[measurement];\n      var num = parseFloat(value);\n      // any 'auto', 'medium' value will be 0\n      size[measurement] = !isNaN(num) ? num : 0;\n    }\n\n    var paddingWidth = size.paddingLeft + size.paddingRight;\n    var paddingHeight = size.paddingTop + size.paddingBottom;\n    var marginWidth = size.marginLeft + size.marginRight;\n    var marginHeight = size.marginTop + size.marginBottom;\n    var borderWidth = size.borderLeftWidth + size.borderRightWidth;\n    var borderHeight = size.borderTopWidth + size.borderBottomWidth;\n\n    var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;\n\n    // overwrite width and height if we can get it from style\n    var styleWidth = getStyleSize(style.width);\n    if (styleWidth !== false) {\n      size.width = styleWidth + (\n      // add padding and border unless it's already including it\n      isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);\n    }\n\n    var styleHeight = getStyleSize(style.height);\n    if (styleHeight !== false) {\n      size.height = styleHeight + (\n      // add padding and border unless it's already including it\n      isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);\n    }\n\n    size.innerWidth = size.width - (paddingWidth + borderWidth);\n    size.innerHeight = size.height - (paddingHeight + borderHeight);\n\n    size.outerWidth = size.width + marginWidth;\n    size.outerHeight = size.height + marginHeight;\n\n    return size;\n  }\n\n  return getSize;\n});\n\n//# sourceURL=webpack:///./node_modules/get-size/get-size.js?")},"./node_modules/rellax/rellax.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\n(function (root, factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  var Rellax = function (el, options) {\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true;\n\n    // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n    var loop = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) {\n      setTimeout(callback, 1000 / 60);\n    };\n\n    // check which transform property to use\n    var transformProp = window.transformProp || function () {\n      var testEl = document.createElement('div');\n      if (testEl.style.transform === null) {\n        var vendors = ['Webkit', 'Moz', 'ms'];\n        for (var vendor in vendors) {\n          if (testEl.style[vendors[vendor] + 'Transform'] !== undefined) {\n            return vendors[vendor] + 'Transform';\n          }\n        }\n      }\n      return 'transform';\n    }();\n\n    // Default Settings\n    self.options = {\n      speed: -2,\n      center: false,\n      wrapper: null,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      callback: function () {}\n    };\n\n    // User defined options (might have more in the future)\n    if (options) {\n      Object.keys(options).forEach(function (key) {\n        self.options[key] = options[key];\n      });\n    }\n\n    // By default, rellax class\n    if (!el) {\n      el = '.rellax';\n    }\n\n    // check if el is a className or a node\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];\n\n    // Now query selector\n    if (elements.length > 0) {\n      self.elems = elements;\n    }\n\n    // The elements don't exist\n    else {\n        throw new Error(\"The elements you're trying to select don't exist.\");\n      }\n\n    // Has a wrapper and it exists\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          throw new Error(\"The wrapper you're trying to use don't exist.\");\n        }\n      }\n    }\n\n    // Get and cache initial position of all elements\n    var cacheBlocks = function () {\n      for (var i = 0; i < self.elems.length; i++) {\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    };\n\n    // Let's kick this script off\n    // Build array for cached element values\n    var init = function () {\n      for (var i = 0; i < blocks.length; i++) {\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      blocks = [];\n\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      setPosition();\n\n      cacheBlocks();\n\n      // If paused, unpause and set listener for window resizing events\n      if (pause) {\n        window.addEventListener('resize', init);\n        pause = false;\n      }\n      animate();\n    };\n\n    // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function (el) {\n      var dataPercentage = el.getAttribute('data-rellax-percentage');\n      var dataSpeed = el.getAttribute('data-rellax-speed');\n      var dataZindex = el.getAttribute('data-rellax-zindex') || 0;\n\n      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\n      var posY = self.options.vertical ? dataPercentage || self.options.center ? wrapperPosY : 0 : 0;\n      var posX = self.options.horizontal ? dataPercentage || self.options.center ? window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft : 0 : 0;\n\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;\n\n      // apparently parallax equation everyone uses\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n      if (self.options.center) {\n        percentageX = 0.5;percentageY = 0.5;\n      }\n\n      // Optional individual block speed as data attr, otherwise global speed\n      var speed = dataSpeed ? dataSpeed : self.options.speed;\n\n      var bases = updatePosition(percentageX, percentageY, speed);\n\n      // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n      var style = el.style.cssText;\n      var transform = '';\n\n      // Check if there's an inline styled transform\n      if (style.indexOf('transform') >= 0) {\n        // Get the index of the transform\n        var index = style.indexOf('transform');\n\n        // Trim the style to the transform point and get the following semi-colon index\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';');\n\n        // Remove \"transform\" string and save the attribute\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g, '');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g, '');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        style: style,\n        transform: transform,\n        zindex: dataZindex\n      };\n    };\n\n    // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function () {\n      var oldY = posY;\n      var oldX = posX;\n\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;\n\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      }\n\n      // scroll did not change\n      return false;\n    };\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n    var updatePosition = function (percentageX, percentageY, speed) {\n      var result = {};\n      var valueX = speed * (100 * (1 - percentageX));\n      var valueY = speed * (100 * (1 - percentageY));\n\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n\n      return result;\n    };\n\n    // Loop\n    var update = function () {\n      if (setPosition() && pause === false) {\n        animate();\n      }\n\n      // loop again\n      loop(update);\n    };\n\n    // Transform3d on parallax element\n    var animate = function () {\n      var positions;\n      for (var i = 0; i < self.elems.length; i++) {\n        var percentageY = (posY - blocks[i].top + screenY) / (blocks[i].height + screenY);\n        var percentageX = (posX - blocks[i].left + screenX) / (blocks[i].width + screenX);\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed); // - blocks[i].baseX;\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX;\n\n        var zindex = blocks[i].zindex;\n\n        // Move that element\n        // (Set the new translation and append initial inline transforms.)\n        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n      self.options.callback(positions);\n    };\n\n    self.destroy = function () {\n      for (var i = 0; i < self.elems.length; i++) {\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      // Remove resize event listener if not pause, and pause\n      if (!pause) {\n        window.removeEventListener('resize', init);\n        pause = true;\n      }\n    };\n\n    // Init\n    init();\n\n    // Start the loop\n    update();\n\n    // Allow to recalculate the initial values whenever we want\n    self.refresh = init;\n\n    return self;\n  };\n  return Rellax;\n});\n\n//# sourceURL=webpack:///./node_modules/rellax/rellax.js?")},"./node_modules/scrollreveal/dist/scrollreveal.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/////    /////    /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n/////             /////    /////\n/////             /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n/////    /////\n/////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n\n/**\n * ScrollReveal\n * ------------\n * Version : 3.4.0\n * Website : scrollrevealjs.org\n * Repo    : github.com/jlmakes/scrollreveal.js\n * Author  : Julian Lloyd (@jlmakes)\n */\n\n;(function () {\n  'use strict';\n\n  var sr;\n  var _requestAnimationFrame;\n\n  function ScrollReveal(config) {\n    // Support instantiation without the `new` keyword.\n    if (typeof this === 'undefined' || Object.getPrototypeOf(this) !== ScrollReveal.prototype) {\n      return new ScrollReveal(config);\n    }\n\n    sr = this; // Save reference to instance.\n    sr.version = '3.4.0';\n    sr.tools = new Tools(); // *required utilities\n\n    if (sr.isSupported()) {\n      sr.tools.extend(sr.defaults, config || {});\n\n      sr.defaults.container = _resolveContainer(sr.defaults);\n\n      sr.store = {\n        elements: {},\n        containers: []\n      };\n\n      sr.sequences = {};\n      sr.history = [];\n      sr.uid = 0;\n      sr.initialized = false;\n    } else if (typeof console !== 'undefined' && console !== null) {\n      // Note: IE9 only supports console if devtools are open.\n      console.log('ScrollReveal is not supported in this browser.');\n    }\n\n    return sr;\n  }\n\n  /**\n   * Configuration\n   * -------------\n   * This object signature can be passed directly to the ScrollReveal constructor,\n   * or as the second argument of the `reveal()` method.\n   */\n\n  ScrollReveal.prototype.defaults = {\n    // 'bottom', 'left', 'top', 'right'\n    origin: 'bottom',\n\n    // Can be any valid CSS distance, e.g. '5rem', '10%', '20vw', etc.\n    distance: '20px',\n\n    // Time in milliseconds.\n    duration: 500,\n    delay: 0,\n\n    // Starting angles in degrees, will transition from these values to 0 in all axes.\n    rotate: { x: 0, y: 0, z: 0 },\n\n    // Starting opacity value, before transitioning to the computed opacity.\n    opacity: 0,\n\n    // Starting scale value, will transition from this value to 1\n    scale: 0.9,\n\n    // Accepts any valid CSS easing, e.g. 'ease', 'ease-in-out', 'linear', etc.\n    easing: 'cubic-bezier(0.6, 0.2, 0.1, 1)',\n\n    // `<html>` is the default reveal container. You can pass either:\n    // DOM Node, e.g. document.querySelector('.fooContainer')\n    // Selector, e.g. '.fooContainer'\n    container: window.document.documentElement,\n\n    // true/false to control reveal animations on mobile.\n    mobile: true,\n\n    // true:  reveals occur every time elements become visible\n    // false: reveals occur once as elements become visible\n    reset: false,\n\n    // 'always' — delay for all reveal animations\n    // 'once'   — delay only the first time reveals occur\n    // 'onload' - delay only for animations triggered by first load\n    useDelay: 'always',\n\n    // Change when an element is considered in the viewport. The default value\n    // of 0.20 means 20% of an element must be visible for its reveal to occur.\n    viewFactor: 0.2,\n\n    // Pixel values that alter the container boundaries.\n    // e.g. Set `{ top: 48 }`, if you have a 48px tall fixed toolbar.\n    // --\n    // Visual Aid: https://scrollrevealjs.org/assets/viewoffset.png\n    viewOffset: { top: 0, right: 0, bottom: 0, left: 0 },\n\n    // Callbacks that fire for each triggered element reveal, and reset.\n    beforeReveal: function (domEl) {},\n    beforeReset: function (domEl) {},\n\n    // Callbacks that fire for each completed element reveal, and reset.\n    afterReveal: function (domEl) {},\n    afterReset: function (domEl) {}\n\n    /**\n     * Check if client supports CSS Transform and CSS Transition.\n     * @return {boolean}\n     */\n  };ScrollReveal.prototype.isSupported = function () {\n    var style = document.documentElement.style;\n    return 'WebkitTransition' in style && 'WebkitTransform' in style || 'transition' in style && 'transform' in style;\n  };\n\n  /**\n   * Creates a reveal set, a group of elements that will animate when they\n   * become visible. If [interval] is provided, a new sequence is created\n   * that will ensure elements reveal in the order they appear in the DOM.\n   *\n   * @param {Node|NodeList|string} [target]   The node, node list or selector to use for animation.\n   * @param {Object}               [config]   Override the defaults for this reveal set.\n   * @param {number}               [interval] Time between sequenced element animations (milliseconds).\n   * @param {boolean}              [sync]     Used internally when updating reveals for async content.\n   *\n   * @return {Object} The current ScrollReveal instance.\n   */\n  ScrollReveal.prototype.reveal = function (target, config, interval, sync) {\n    var container;\n    var elements;\n    var elem;\n    var elemId;\n    var sequence;\n    var sequenceId;\n\n    // No custom configuration was passed, but a sequence interval instead.\n    // let’s shuffle things around to make sure everything works.\n    if (config !== undefined && typeof config === 'number') {\n      interval = config;\n      config = {};\n    } else if (config === undefined || config === null) {\n      config = {};\n    }\n\n    container = _resolveContainer(config);\n    elements = _getRevealElements(target, container);\n\n    if (!elements.length) {\n      console.log('ScrollReveal: reveal on \"' + target + '\" failed, no elements found.');\n      return sr;\n    }\n\n    // Prepare a new sequence if an interval is passed.\n    if (interval && typeof interval === 'number') {\n      sequenceId = _nextUid();\n\n      sequence = sr.sequences[sequenceId] = {\n        id: sequenceId,\n        interval: interval,\n        elemIds: [],\n        active: false\n      };\n    }\n\n    // Begin main loop to configure ScrollReveal elements.\n    for (var i = 0; i < elements.length; i++) {\n      // Check if the element has already been configured and grab it from the store.\n      elemId = elements[i].getAttribute('data-sr-id');\n      if (elemId) {\n        elem = sr.store.elements[elemId];\n      } else {\n        // Otherwise, let’s do some basic setup.\n        elem = {\n          id: _nextUid(),\n          domEl: elements[i],\n          seen: false,\n          revealing: false\n        };\n        elem.domEl.setAttribute('data-sr-id', elem.id);\n      }\n\n      // Sequence only setup\n      if (sequence) {\n        elem.sequence = {\n          id: sequence.id,\n          index: sequence.elemIds.length\n        };\n\n        sequence.elemIds.push(elem.id);\n      }\n\n      // New or existing element, it’s time to update its configuration, styles,\n      // and send the updates to our store.\n      _configure(elem, config, container);\n      _style(elem);\n      _updateStore(elem);\n\n      // We need to make sure elements are set to visibility: visible, even when\n      // on mobile and `config.mobile === false`, or if unsupported.\n      if (sr.tools.isMobile() && !elem.config.mobile || !sr.isSupported()) {\n        elem.domEl.setAttribute('style', elem.styles.inline);\n        elem.disabled = true;\n      } else if (!elem.revealing) {\n        // Otherwise, proceed normally.\n        elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.initial);\n      }\n    }\n\n    // Each `reveal()` is recorded so that when calling `sync()` while working\n    // with asynchronously loaded content, it can re-trace your steps but with\n    // all your new elements now in the DOM.\n\n    // Since `reveal()` is called internally by `sync()`, we don’t want to\n    // record or intiialize each reveal during syncing.\n    if (!sync && sr.isSupported()) {\n      _record(target, config, interval);\n\n      // We push initialization to the event queue using setTimeout, so that we can\n      // give ScrollReveal room to process all reveal calls before putting things into motion.\n      // --\n      // Philip Roberts - What the heck is the event loop anyway? (JSConf EU 2014)\n      // https://www.youtube.com/watch?v=8aGhZQkoFbQ\n      if (sr.initTimeout) {\n        window.clearTimeout(sr.initTimeout);\n      }\n      sr.initTimeout = window.setTimeout(_init, 0);\n    }\n\n    return sr;\n  };\n\n  /**\n   * Re-runs `reveal()` for each record stored in history, effectively capturing\n   * any content loaded asynchronously that matches existing reveal set targets.\n   * @return {Object} The current ScrollReveal instance.\n   */\n  ScrollReveal.prototype.sync = function () {\n    if (sr.history.length && sr.isSupported()) {\n      for (var i = 0; i < sr.history.length; i++) {\n        var record = sr.history[i];\n        sr.reveal(record.target, record.config, record.interval, true);\n      }\n      _init();\n    } else {\n      console.log('ScrollReveal: sync failed, no reveals found.');\n    }\n    return sr;\n  };\n\n  /**\n   * Private Methods\n   * ---------------\n   */\n\n  function _resolveContainer(config) {\n    if (config && config.container) {\n      if (typeof config.container === 'string') {\n        return window.document.documentElement.querySelector(config.container);\n      } else if (sr.tools.isNode(config.container)) {\n        return config.container;\n      } else {\n        console.log('ScrollReveal: invalid container \"' + config.container + '\" provided.');\n        console.log('ScrollReveal: falling back to default container.');\n      }\n    }\n    return sr.defaults.container;\n  }\n\n  /**\n   * check to see if a node or node list was passed in as the target,\n   * otherwise query the container using target as a selector.\n   *\n   * @param {Node|NodeList|string} [target]    client input for reveal target.\n   * @param {Node}                 [container] parent element for selector queries.\n   *\n   * @return {array} elements to be revealed.\n   */\n  function _getRevealElements(target, container) {\n    if (typeof target === 'string') {\n      return Array.prototype.slice.call(container.querySelectorAll(target));\n    } else if (sr.tools.isNode(target)) {\n      return [target];\n    } else if (sr.tools.isNodeList(target)) {\n      return Array.prototype.slice.call(target);\n    } else if (Array.isArray(target)) {\n      return target.filter(sr.tools.isNode);\n    }\n    return [];\n  }\n\n  /**\n   * A consistent way of creating unique IDs.\n   * @returns {number}\n   */\n  function _nextUid() {\n    return ++sr.uid;\n  }\n\n  function _configure(elem, config, container) {\n    // If a container was passed as a part of the config object,\n    // let’s overwrite it with the resolved container passed in.\n    if (config.container) config.container = container;\n    // If the element hasn’t already been configured, let’s use a clone of the\n    // defaults extended by the configuration passed as the second argument.\n    if (!elem.config) {\n      elem.config = sr.tools.extendClone(sr.defaults, config);\n    } else {\n      // Otherwise, let’s use a clone of the existing element configuration extended\n      // by the configuration passed as the second argument.\n      elem.config = sr.tools.extendClone(elem.config, config);\n    }\n\n    // Infer CSS Transform axis from origin string.\n    if (elem.config.origin === 'top' || elem.config.origin === 'bottom') {\n      elem.config.axis = 'Y';\n    } else {\n      elem.config.axis = 'X';\n    }\n  }\n\n  function _style(elem) {\n    var computed = window.getComputedStyle(elem.domEl);\n\n    if (!elem.styles) {\n      elem.styles = {\n        transition: {},\n        transform: {},\n        computed: {}\n\n        // Capture any existing inline styles, and add our visibility override.\n        // --\n        // See section 4.2. in the Documentation:\n        // https://github.com/jlmakes/scrollreveal.js#42-improve-user-experience\n      };elem.styles.inline = elem.domEl.getAttribute('style') || '';\n      elem.styles.inline += '; visibility: visible; ';\n\n      // grab the elements existing opacity.\n      elem.styles.computed.opacity = computed.opacity;\n\n      // grab the elements existing transitions.\n      if (!computed.transition || computed.transition === 'all 0s ease 0s') {\n        elem.styles.computed.transition = '';\n      } else {\n        elem.styles.computed.transition = computed.transition + ', ';\n      }\n    }\n\n    // Create transition styles\n    elem.styles.transition.instant = _generateTransition(elem, 0);\n    elem.styles.transition.delayed = _generateTransition(elem, elem.config.delay);\n\n    // Generate transform styles, first with the webkit prefix.\n    elem.styles.transform.initial = ' -webkit-transform:';\n    elem.styles.transform.target = ' -webkit-transform:';\n    _generateTransform(elem);\n\n    // And again without any prefix.\n    elem.styles.transform.initial += 'transform:';\n    elem.styles.transform.target += 'transform:';\n    _generateTransform(elem);\n  }\n\n  function _generateTransition(elem, delay) {\n    var config = elem.config;\n\n    return '-webkit-transition: ' + elem.styles.computed.transition + '-webkit-transform ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's, opacity ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's; ' + 'transition: ' + elem.styles.computed.transition + 'transform ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's, opacity ' + config.duration / 1000 + 's ' + config.easing + ' ' + delay / 1000 + 's; ';\n  }\n\n  function _generateTransform(elem) {\n    var config = elem.config;\n    var cssDistance;\n    var transform = elem.styles.transform;\n\n    // Let’s make sure our our pixel distances are negative for top and left.\n    // e.g. origin = 'top' and distance = '25px' starts at `top: -25px` in CSS.\n    if (config.origin === 'top' || config.origin === 'left') {\n      cssDistance = /^-/.test(config.distance) ? config.distance.substr(1) : '-' + config.distance;\n    } else {\n      cssDistance = config.distance;\n    }\n\n    if (parseInt(config.distance)) {\n      transform.initial += ' translate' + config.axis + '(' + cssDistance + ')';\n      transform.target += ' translate' + config.axis + '(0)';\n    }\n    if (config.scale) {\n      transform.initial += ' scale(' + config.scale + ')';\n      transform.target += ' scale(1)';\n    }\n    if (config.rotate.x) {\n      transform.initial += ' rotateX(' + config.rotate.x + 'deg)';\n      transform.target += ' rotateX(0)';\n    }\n    if (config.rotate.y) {\n      transform.initial += ' rotateY(' + config.rotate.y + 'deg)';\n      transform.target += ' rotateY(0)';\n    }\n    if (config.rotate.z) {\n      transform.initial += ' rotateZ(' + config.rotate.z + 'deg)';\n      transform.target += ' rotateZ(0)';\n    }\n    transform.initial += '; opacity: ' + config.opacity + ';';\n    transform.target += '; opacity: ' + elem.styles.computed.opacity + ';';\n  }\n\n  function _updateStore(elem) {\n    var container = elem.config.container;\n\n    // If this element’s container isn’t already in the store, let’s add it.\n    if (container && sr.store.containers.indexOf(container) === -1) {\n      sr.store.containers.push(elem.config.container);\n    }\n\n    // Update the element stored with our new element.\n    sr.store.elements[elem.id] = elem;\n  }\n\n  function _record(target, config, interval) {\n    // Save the `reveal()` arguments that triggered this `_record()` call, so we\n    // can re-trace our steps when calling the `sync()` method.\n    var record = {\n      target: target,\n      config: config,\n      interval: interval\n    };\n    sr.history.push(record);\n  }\n\n  function _init() {\n    if (sr.isSupported()) {\n      // Initial animate call triggers valid reveal animations on first load.\n      // Subsequent animate calls are made inside the event handler.\n      _animate();\n\n      // Then we loop through all container nodes in the store and bind event\n      // listeners to each.\n      for (var i = 0; i < sr.store.containers.length; i++) {\n        sr.store.containers[i].addEventListener('scroll', _handler);\n        sr.store.containers[i].addEventListener('resize', _handler);\n      }\n\n      // Let’s also do a one-time binding of window event listeners.\n      if (!sr.initialized) {\n        window.addEventListener('scroll', _handler);\n        window.addEventListener('resize', _handler);\n        sr.initialized = true;\n      }\n    }\n    return sr;\n  }\n\n  function _handler() {\n    _requestAnimationFrame(_animate);\n  }\n\n  function _setActiveSequences() {\n    var active;\n    var elem;\n    var elemId;\n    var sequence;\n\n    // Loop through all sequences\n    sr.tools.forOwn(sr.sequences, function (sequenceId) {\n      sequence = sr.sequences[sequenceId];\n      active = false;\n\n      // For each sequenced elemenet, let’s check visibility and if\n      // any are visible, set it’s sequence to active.\n      for (var i = 0; i < sequence.elemIds.length; i++) {\n        elemId = sequence.elemIds[i];\n        elem = sr.store.elements[elemId];\n        if (_isElemVisible(elem) && !active) {\n          active = true;\n        }\n      }\n\n      sequence.active = active;\n    });\n  }\n\n  function _animate() {\n    var delayed;\n    var elem;\n\n    _setActiveSequences();\n\n    // Loop through all elements in the store\n    sr.tools.forOwn(sr.store.elements, function (elemId) {\n      elem = sr.store.elements[elemId];\n      delayed = _shouldUseDelay(elem);\n\n      // Let’s see if we should revealand if so,\n      // trigger the `beforeReveal` callback and\n      // determine whether or not to use delay.\n      if (_shouldReveal(elem)) {\n        elem.config.beforeReveal(elem.domEl);\n        if (delayed) {\n          elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.target + elem.styles.transition.delayed);\n        } else {\n          elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.target + elem.styles.transition.instant);\n        }\n\n        // Let’s queue the `afterReveal` callback\n        // and mark the element as seen and revealing.\n        _queueCallback('reveal', elem, delayed);\n        elem.revealing = true;\n        elem.seen = true;\n\n        if (elem.sequence) {\n          _queueNextInSequence(elem, delayed);\n        }\n      } else if (_shouldReset(elem)) {\n        //Otherwise reset our element and\n        // trigger the `beforeReset` callback.\n        elem.config.beforeReset(elem.domEl);\n        elem.domEl.setAttribute('style', elem.styles.inline + elem.styles.transform.initial + elem.styles.transition.instant);\n        // And queue the `afterReset` callback.\n        _queueCallback('reset', elem);\n        elem.revealing = false;\n      }\n    });\n  }\n\n  function _queueNextInSequence(elem, delayed) {\n    var elapsed = 0;\n    var delay = 0;\n    var sequence = sr.sequences[elem.sequence.id];\n\n    // We’re processing a sequenced element, so let's block other elements in this sequence.\n    sequence.blocked = true;\n\n    // Since we’re triggering animations a part of a sequence after animations on first load,\n    // we need to check for that condition and explicitly add the delay to our timer.\n    if (delayed && elem.config.useDelay === 'onload') {\n      delay = elem.config.delay;\n    }\n\n    // If a sequence timer is already running, capture the elapsed time and clear it.\n    if (elem.sequence.timer) {\n      elapsed = Math.abs(elem.sequence.timer.started - new Date());\n      window.clearTimeout(elem.sequence.timer);\n    }\n\n    // Start a new timer.\n    elem.sequence.timer = { started: new Date() };\n    elem.sequence.timer.clock = window.setTimeout(function () {\n      // Sequence interval has passed, so unblock the sequence and re-run the handler.\n      sequence.blocked = false;\n      elem.sequence.timer = null;\n      _handler();\n    }, Math.abs(sequence.interval) + delay - elapsed);\n  }\n\n  function _queueCallback(type, elem, delayed) {\n    var elapsed = 0;\n    var duration = 0;\n    var callback = 'after';\n\n    // Check which callback we’re working with.\n    switch (type) {\n      case 'reveal':\n        duration = elem.config.duration;\n        if (delayed) {\n          duration += elem.config.delay;\n        }\n        callback += 'Reveal';\n        break;\n\n      case 'reset':\n        duration = elem.config.duration;\n        callback += 'Reset';\n        break;\n    }\n\n    // If a timer is already running, capture the elapsed time and clear it.\n    if (elem.timer) {\n      elapsed = Math.abs(elem.timer.started - new Date());\n      window.clearTimeout(elem.timer.clock);\n    }\n\n    // Start a new timer.\n    elem.timer = { started: new Date() };\n    elem.timer.clock = window.setTimeout(function () {\n      // The timer completed, so let’s fire the callback and null the timer.\n      elem.config[callback](elem.domEl);\n      elem.timer = null;\n    }, duration - elapsed);\n  }\n\n  function _shouldReveal(elem) {\n    if (elem.sequence) {\n      var sequence = sr.sequences[elem.sequence.id];\n      return sequence.active && !sequence.blocked && !elem.revealing && !elem.disabled;\n    }\n    return _isElemVisible(elem) && !elem.revealing && !elem.disabled;\n  }\n\n  function _shouldUseDelay(elem) {\n    var config = elem.config.useDelay;\n    return config === 'always' || config === 'onload' && !sr.initialized || config === 'once' && !elem.seen;\n  }\n\n  function _shouldReset(elem) {\n    if (elem.sequence) {\n      var sequence = sr.sequences[elem.sequence.id];\n      return !sequence.active && elem.config.reset && elem.revealing && !elem.disabled;\n    }\n    return !_isElemVisible(elem) && elem.config.reset && elem.revealing && !elem.disabled;\n  }\n\n  function _getContainer(container) {\n    return {\n      width: container.clientWidth,\n      height: container.clientHeight\n    };\n  }\n\n  function _getScrolled(container) {\n    // Return the container scroll values, plus the its offset.\n    if (container && container !== window.document.documentElement) {\n      var offset = _getOffset(container);\n      return {\n        x: container.scrollLeft + offset.left,\n        y: container.scrollTop + offset.top\n      };\n    } else {\n      // Otherwise, default to the window object’s scroll values.\n      return {\n        x: window.pageXOffset,\n        y: window.pageYOffset\n      };\n    }\n  }\n\n  function _getOffset(domEl) {\n    var offsetTop = 0;\n    var offsetLeft = 0;\n\n    // Grab the element’s dimensions.\n    var offsetHeight = domEl.offsetHeight;\n    var offsetWidth = domEl.offsetWidth;\n\n    // Now calculate the distance between the element and its parent, then\n    // again for the parent to its parent, and again etc... until we have the\n    // total distance of the element to the document’s top and left origin.\n    do {\n      if (!isNaN(domEl.offsetTop)) {\n        offsetTop += domEl.offsetTop;\n      }\n      if (!isNaN(domEl.offsetLeft)) {\n        offsetLeft += domEl.offsetLeft;\n      }\n      domEl = domEl.offsetParent;\n    } while (domEl);\n\n    return {\n      top: offsetTop,\n      left: offsetLeft,\n      height: offsetHeight,\n      width: offsetWidth\n    };\n  }\n\n  function _isElemVisible(elem) {\n    var offset = _getOffset(elem.domEl);\n    var container = _getContainer(elem.config.container);\n    var scrolled = _getScrolled(elem.config.container);\n    var vF = elem.config.viewFactor;\n\n    // Define the element geometry.\n    var elemHeight = offset.height;\n    var elemWidth = offset.width;\n    var elemTop = offset.top;\n    var elemLeft = offset.left;\n    var elemBottom = elemTop + elemHeight;\n    var elemRight = elemLeft + elemWidth;\n\n    return confirmBounds() || isPositionFixed();\n\n    function confirmBounds() {\n      // Define the element’s functional boundaries using its view factor.\n      var top = elemTop + elemHeight * vF;\n      var left = elemLeft + elemWidth * vF;\n      var bottom = elemBottom - elemHeight * vF;\n      var right = elemRight - elemWidth * vF;\n\n      // Define the container functional boundaries using its view offset.\n      var viewTop = scrolled.y + elem.config.viewOffset.top;\n      var viewLeft = scrolled.x + elem.config.viewOffset.left;\n      var viewBottom = scrolled.y - elem.config.viewOffset.bottom + container.height;\n      var viewRight = scrolled.x - elem.config.viewOffset.right + container.width;\n\n      return top < viewBottom && bottom > viewTop && left < viewRight && right > viewLeft;\n    }\n\n    function isPositionFixed() {\n      return window.getComputedStyle(elem.domEl).position === 'fixed';\n    }\n  }\n\n  /**\n   * Utilities\n   * ---------\n   */\n\n  function Tools() {}\n\n  Tools.prototype.isObject = function (object) {\n    return object !== null && typeof object === 'object' && object.constructor === Object;\n  };\n\n  Tools.prototype.isNode = function (object) {\n    return typeof window.Node === 'object' ? object instanceof window.Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n  };\n\n  Tools.prototype.isNodeList = function (object) {\n    var prototypeToString = Object.prototype.toString.call(object);\n    var regex = /^\\[object (HTMLCollection|NodeList|Object)\\]$/;\n\n    return typeof window.NodeList === 'object' ? object instanceof window.NodeList : object && typeof object === 'object' && regex.test(prototypeToString) && typeof object.length === 'number' && (object.length === 0 || this.isNode(object[0]));\n  };\n\n  Tools.prototype.forOwn = function (object, callback) {\n    if (!this.isObject(object)) {\n      throw new TypeError('Expected \"object\", but received \"' + typeof object + '\".');\n    } else {\n      for (var property in object) {\n        if (object.hasOwnProperty(property)) {\n          callback(property);\n        }\n      }\n    }\n  };\n\n  Tools.prototype.extend = function (target, source) {\n    this.forOwn(source, function (property) {\n      if (this.isObject(source[property])) {\n        if (!target[property] || !this.isObject(target[property])) {\n          target[property] = {};\n        }\n        this.extend(target[property], source[property]);\n      } else {\n        target[property] = source[property];\n      }\n    }.bind(this));\n    return target;\n  };\n\n  Tools.prototype.extendClone = function (target, source) {\n    return this.extend(this.extend({}, target), source);\n  };\n\n  Tools.prototype.isMobile = function () {\n    return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n    );\n  };\n\n  /**\n   * Polyfills\n   * --------\n   */\n\n  _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {\n    window.setTimeout(callback, 1000 / 60);\n  };\n\n  /**\n   * Module Wrapper\n   * --------------\n   */\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return ScrollReveal;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})();\n\n//# sourceURL=webpack:///./node_modules/scrollreveal/dist/scrollreveal.js?")},"./node_modules/tap-listener/tap-listener.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Tap listener v2.0.0\n * listens to taps\n * MIT license\n */\n\n/*jshint browser: true, unused: true, undef: true, strict: true */\n\n(function (window, factory) {\n  // universal module definition\n  /*jshint strict: false*/ /*globals define, module, require */\n\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! unipointer/unipointer */ \"./node_modules/unipointer/unipointer.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Unipointer) {\n      return factory(window, Unipointer);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, Unipointer) {\n\n  'use strict';\n\n  // --------------------------  TapListener -------------------------- //\n\n  function TapListener(elem) {\n    this.bindTap(elem);\n  }\n\n  // inherit Unipointer & EventEmitter\n  var proto = TapListener.prototype = Object.create(Unipointer.prototype);\n\n  /**\n   * bind tap event to element\n   * @param {Element} elem\n   */\n  proto.bindTap = function (elem) {\n    if (!elem) {\n      return;\n    }\n    this.unbindTap();\n    this.tapElement = elem;\n    this._bindStartEvent(elem, true);\n  };\n\n  proto.unbindTap = function () {\n    if (!this.tapElement) {\n      return;\n    }\n    this._bindStartEvent(this.tapElement, true);\n    delete this.tapElement;\n  };\n\n  /**\n   * pointer up\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n  proto.pointerUp = function (event, pointer) {\n    // ignore emulated mouse up clicks\n    if (this.isIgnoringMouseUp && event.type == 'mouseup') {\n      return;\n    }\n\n    var pointerPoint = Unipointer.getPointerPoint(pointer);\n    var boundingRect = this.tapElement.getBoundingClientRect();\n    var scrollX = window.pageXOffset;\n    var scrollY = window.pageYOffset;\n    // calculate if pointer is inside tapElement\n    var isInside = pointerPoint.x >= boundingRect.left + scrollX && pointerPoint.x <= boundingRect.right + scrollX && pointerPoint.y >= boundingRect.top + scrollY && pointerPoint.y <= boundingRect.bottom + scrollY;\n    // trigger callback if pointer is inside element\n    if (isInside) {\n      this.emitEvent('tap', [event, pointer]);\n    }\n\n    // set flag for emulated clicks 300ms after touchend\n    if (event.type != 'mouseup') {\n      this.isIgnoringMouseUp = true;\n      // reset flag after 300ms\n      var _this = this;\n      setTimeout(function () {\n        delete _this.isIgnoringMouseUp;\n      }, 400);\n    }\n  };\n\n  proto.destroy = function () {\n    this.pointerDone();\n    this.unbindTap();\n  };\n\n  // -----  ----- //\n\n  return TapListener;\n});\n\n//# sourceURL=webpack:///./node_modules/tap-listener/tap-listener.js?")},"./node_modules/unidragger/unidragger.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unidragger v2.3.0\n * Draggable base class\n * MIT license\n */\n\n/*jshint browser: true, unused: true, undef: true, strict: true */\n\n(function (window, factory) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! unipointer/unipointer */ \"./node_modules/unipointer/unipointer.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Unipointer) {\n      return factory(window, Unipointer);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, Unipointer) {\n\n  'use strict';\n\n  // -------------------------- Unidragger -------------------------- //\n\n  function Unidragger() {}\n\n  // inherit Unipointer & EvEmitter\n  var proto = Unidragger.prototype = Object.create(Unipointer.prototype);\n\n  // ----- bind start ----- //\n\n  proto.bindHandles = function () {\n    this._bindHandles(true);\n  };\n\n  proto.unbindHandles = function () {\n    this._bindHandles(false);\n  };\n\n  /**\n   * Add or remove start event\n   * @param {Boolean} isAdd\n   */\n  proto._bindHandles = function (isAdd) {\n    // munge isAdd, default to true\n    isAdd = isAdd === undefined ? true : isAdd;\n    // bind each handle\n    var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n    var touchAction = isAdd ? this._touchActionValue : '';\n    for (var i = 0; i < this.handles.length; i++) {\n      var handle = this.handles[i];\n      this._bindStartEvent(handle, isAdd);\n      handle[bindMethod]('click', this);\n      // touch-action: none to override browser touch gestures. metafizzy/flickity#540\n      if (window.PointerEvent) {\n        handle.style.touchAction = touchAction;\n      }\n    }\n  };\n\n  // prototype so it can be overwriteable by Flickity\n  proto._touchActionValue = 'none';\n\n  // ----- start event ----- //\n\n  /**\n   * pointer start\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n  proto.pointerDown = function (event, pointer) {\n    var isOkay = this.okayPointerDown(event);\n    if (!isOkay) {\n      return;\n    }\n    // track start event position\n    this.pointerDownPointer = pointer;\n\n    event.preventDefault();\n    this.pointerDownBlur();\n    // bind move and end events\n    this._bindPostStartEvents(event);\n    this.emitEvent('pointerDown', [event, pointer]);\n  };\n\n  // nodes that have text fields\n  var cursorNodes = {\n    TEXTAREA: true,\n    INPUT: true,\n    SELECT: true,\n    OPTION: true\n  };\n\n  // input types that do not have text fields\n  var clickTypes = {\n    radio: true,\n    checkbox: true,\n    button: true,\n    submit: true,\n    image: true,\n    file: true\n  };\n\n  // dismiss inputs with text fields. flickity#403, flickity#404\n  proto.okayPointerDown = function (event) {\n    var isCursorNode = cursorNodes[event.target.nodeName];\n    var isClickType = clickTypes[event.target.type];\n    var isOkay = !isCursorNode || isClickType;\n    if (!isOkay) {\n      this._pointerReset();\n    }\n    return isOkay;\n  };\n\n  // kludge to blur previously focused input\n  proto.pointerDownBlur = function () {\n    var focused = document.activeElement;\n    // do not blur body for IE10, metafizzy/flickity#117\n    var canBlur = focused && focused.blur && focused != document.body;\n    if (canBlur) {\n      focused.blur();\n    }\n  };\n\n  // ----- move event ----- //\n\n  /**\n   * drag move\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n  proto.pointerMove = function (event, pointer) {\n    var moveVector = this._dragPointerMove(event, pointer);\n    this.emitEvent('pointerMove', [event, pointer, moveVector]);\n    this._dragMove(event, pointer, moveVector);\n  };\n\n  // base pointer move logic\n  proto._dragPointerMove = function (event, pointer) {\n    var moveVector = {\n      x: pointer.pageX - this.pointerDownPointer.pageX,\n      y: pointer.pageY - this.pointerDownPointer.pageY\n    };\n    // start drag if pointer has moved far enough to start drag\n    if (!this.isDragging && this.hasDragStarted(moveVector)) {\n      this._dragStart(event, pointer);\n    }\n    return moveVector;\n  };\n\n  // condition if pointer has moved far enough to start drag\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > 3 || Math.abs(moveVector.y) > 3;\n  };\n\n  // ----- end event ----- //\n\n  /**\n   * pointer up\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n  proto.pointerUp = function (event, pointer) {\n    this.emitEvent('pointerUp', [event, pointer]);\n    this._dragPointerUp(event, pointer);\n  };\n\n  proto._dragPointerUp = function (event, pointer) {\n    if (this.isDragging) {\n      this._dragEnd(event, pointer);\n    } else {\n      // pointer didn't move enough for drag to start\n      this._staticClick(event, pointer);\n    }\n  };\n\n  // -------------------------- drag -------------------------- //\n\n  // dragStart\n  proto._dragStart = function (event, pointer) {\n    this.isDragging = true;\n    // prevent clicks\n    this.isPreventingClicks = true;\n    this.dragStart(event, pointer);\n  };\n\n  proto.dragStart = function (event, pointer) {\n    this.emitEvent('dragStart', [event, pointer]);\n  };\n\n  // dragMove\n  proto._dragMove = function (event, pointer, moveVector) {\n    // do not drag if not dragging yet\n    if (!this.isDragging) {\n      return;\n    }\n\n    this.dragMove(event, pointer, moveVector);\n  };\n\n  proto.dragMove = function (event, pointer, moveVector) {\n    event.preventDefault();\n    this.emitEvent('dragMove', [event, pointer, moveVector]);\n  };\n\n  // dragEnd\n  proto._dragEnd = function (event, pointer) {\n    // set flags\n    this.isDragging = false;\n    // re-enable clicking async\n    setTimeout(function () {\n      delete this.isPreventingClicks;\n    }.bind(this));\n\n    this.dragEnd(event, pointer);\n  };\n\n  proto.dragEnd = function (event, pointer) {\n    this.emitEvent('dragEnd', [event, pointer]);\n  };\n\n  // ----- onclick ----- //\n\n  // handle all clicks and prevent clicks when dragging\n  proto.onclick = function (event) {\n    if (this.isPreventingClicks) {\n      event.preventDefault();\n    }\n  };\n\n  // ----- staticClick ----- //\n\n  // triggered after pointer down & up with no/tiny movement\n  proto._staticClick = function (event, pointer) {\n    // ignore emulated mouse up clicks\n    if (this.isIgnoringMouseUp && event.type == 'mouseup') {\n      return;\n    }\n\n    this.staticClick(event, pointer);\n\n    // set flag for emulated clicks 300ms after touchend\n    if (event.type != 'mouseup') {\n      this.isIgnoringMouseUp = true;\n      // reset flag after 300ms\n      setTimeout(function () {\n        delete this.isIgnoringMouseUp;\n      }.bind(this), 400);\n    }\n  };\n\n  proto.staticClick = function (event, pointer) {\n    this.emitEvent('staticClick', [event, pointer]);\n  };\n\n  // ----- utils ----- //\n\n  Unidragger.getPointerPoint = Unipointer.getPointerPoint;\n\n  // -----  ----- //\n\n  return Unidragger;\n});\n\n//# sourceURL=webpack:///./node_modules/unidragger/unidragger.js?")},"./node_modules/unipointer/unipointer.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unipointer v2.3.0\n * base class for doing one thing with pointer event\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */ /*global define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ev-emitter/ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (EvEmitter) {\n      return factory(window, EvEmitter);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, EvEmitter) {\n\n  'use strict';\n\n  function noop() {}\n\n  function Unipointer() {}\n\n  // inherit EvEmitter\n  var proto = Unipointer.prototype = Object.create(EvEmitter.prototype);\n\n  proto.bindStartEvent = function (elem) {\n    this._bindStartEvent(elem, true);\n  };\n\n  proto.unbindStartEvent = function (elem) {\n    this._bindStartEvent(elem, false);\n  };\n\n  /**\n   * Add or remove start event\n   * @param {Boolean} isAdd - remove if falsey\n   */\n  proto._bindStartEvent = function (elem, isAdd) {\n    // munge isAdd, default to true\n    isAdd = isAdd === undefined ? true : isAdd;\n    var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n\n    // default to mouse events\n    var startEvent = 'mousedown';\n    if (window.PointerEvent) {\n      // Pointer Events\n      startEvent = 'pointerdown';\n    } else if ('ontouchstart' in window) {\n      // Touch Events. iOS Safari\n      startEvent = 'touchstart';\n    }\n    elem[bindMethod](startEvent, this);\n  };\n\n  // trigger handler methods for events\n  proto.handleEvent = function (event) {\n    var method = 'on' + event.type;\n    if (this[method]) {\n      this[method](event);\n    }\n  };\n\n  // returns the touch that we're keeping track of\n  proto.getTouch = function (touches) {\n    for (var i = 0; i < touches.length; i++) {\n      var touch = touches[i];\n      if (touch.identifier == this.pointerIdentifier) {\n        return touch;\n      }\n    }\n  };\n\n  // ----- start event ----- //\n\n  proto.onmousedown = function (event) {\n    // dismiss clicks from right or middle buttons\n    var button = event.button;\n    if (button && button !== 0 && button !== 1) {\n      return;\n    }\n    this._pointerDown(event, event);\n  };\n\n  proto.ontouchstart = function (event) {\n    this._pointerDown(event, event.changedTouches[0]);\n  };\n\n  proto.onpointerdown = function (event) {\n    this._pointerDown(event, event);\n  };\n\n  /**\n   * pointer start\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n  proto._pointerDown = function (event, pointer) {\n    // dismiss right click and other pointers\n    // button = 0 is okay, 1-4 not\n    if (event.button || this.isPointerDown) {\n      return;\n    }\n\n    this.isPointerDown = true;\n    // save pointer identifier to match up touch events\n    this.pointerIdentifier = pointer.pointerId !== undefined ?\n    // pointerId for pointer events, touch.indentifier for touch events\n    pointer.pointerId : pointer.identifier;\n\n    this.pointerDown(event, pointer);\n  };\n\n  proto.pointerDown = function (event, pointer) {\n    this._bindPostStartEvents(event);\n    this.emitEvent('pointerDown', [event, pointer]);\n  };\n\n  // hash of events to be bound after start event\n  var postStartEvents = {\n    mousedown: ['mousemove', 'mouseup'],\n    touchstart: ['touchmove', 'touchend', 'touchcancel'],\n    pointerdown: ['pointermove', 'pointerup', 'pointercancel']\n  };\n\n  proto._bindPostStartEvents = function (event) {\n    if (!event) {\n      return;\n    }\n    // get proper events to match start event\n    var events = postStartEvents[event.type];\n    // bind events to node\n    events.forEach(function (eventName) {\n      window.addEventListener(eventName, this);\n    }, this);\n    // save these arguments\n    this._boundPointerEvents = events;\n  };\n\n  proto._unbindPostStartEvents = function () {\n    // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)\n    if (!this._boundPointerEvents) {\n      return;\n    }\n    this._boundPointerEvents.forEach(function (eventName) {\n      window.removeEventListener(eventName, this);\n    }, this);\n\n    delete this._boundPointerEvents;\n  };\n\n  // ----- move event ----- //\n\n  proto.onmousemove = function (event) {\n    this._pointerMove(event, event);\n  };\n\n  proto.onpointermove = function (event) {\n    if (event.pointerId == this.pointerIdentifier) {\n      this._pointerMove(event, event);\n    }\n  };\n\n  proto.ontouchmove = function (event) {\n    var touch = this.getTouch(event.changedTouches);\n    if (touch) {\n      this._pointerMove(event, touch);\n    }\n  };\n\n  /**\n   * pointer move\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   * @private\n   */\n  proto._pointerMove = function (event, pointer) {\n    this.pointerMove(event, pointer);\n  };\n\n  // public\n  proto.pointerMove = function (event, pointer) {\n    this.emitEvent('pointerMove', [event, pointer]);\n  };\n\n  // ----- end event ----- //\n\n\n  proto.onmouseup = function (event) {\n    this._pointerUp(event, event);\n  };\n\n  proto.onpointerup = function (event) {\n    if (event.pointerId == this.pointerIdentifier) {\n      this._pointerUp(event, event);\n    }\n  };\n\n  proto.ontouchend = function (event) {\n    var touch = this.getTouch(event.changedTouches);\n    if (touch) {\n      this._pointerUp(event, touch);\n    }\n  };\n\n  /**\n   * pointer up\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   * @private\n   */\n  proto._pointerUp = function (event, pointer) {\n    this._pointerDone();\n    this.pointerUp(event, pointer);\n  };\n\n  // public\n  proto.pointerUp = function (event, pointer) {\n    this.emitEvent('pointerUp', [event, pointer]);\n  };\n\n  // ----- pointer done ----- //\n\n  // triggered on pointer up & pointer cancel\n  proto._pointerDone = function () {\n    this._pointerReset();\n    this._unbindPostStartEvents();\n    this.pointerDone();\n  };\n\n  proto._pointerReset = function () {\n    // reset properties\n    this.isPointerDown = false;\n    delete this.pointerIdentifier;\n  };\n\n  proto.pointerDone = noop;\n\n  // ----- pointer cancel ----- //\n\n  proto.onpointercancel = function (event) {\n    if (event.pointerId == this.pointerIdentifier) {\n      this._pointerCancel(event, event);\n    }\n  };\n\n  proto.ontouchcancel = function (event) {\n    var touch = this.getTouch(event.changedTouches);\n    if (touch) {\n      this._pointerCancel(event, touch);\n    }\n  };\n\n  /**\n   * pointer cancel\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   * @private\n   */\n  proto._pointerCancel = function (event, pointer) {\n    this._pointerDone();\n    this.pointerCancel(event, pointer);\n  };\n\n  // public\n  proto.pointerCancel = function (event, pointer) {\n    this.emitEvent('pointerCancel', [event, pointer]);\n  };\n\n  // -----  ----- //\n\n  // utility function for getting x/y coords from event\n  Unipointer.getPointerPoint = function (pointer) {\n    return {\n      x: pointer.pageX,\n      y: pointer.pageY\n    };\n  };\n\n  // -----  ----- //\n\n  return Unipointer;\n});\n\n//# sourceURL=webpack:///./node_modules/unipointer/unipointer.js?")},"./src/js/build/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var rellax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rellax */ \"./node_modules/rellax/rellax.js\");\n/* harmony import */ var rellax__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rellax__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_video__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/video */ \"./src/js/lib/video.js\");\n/* harmony import */ var _lib_product_featurettes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/product-featurettes */ \"./src/js/lib/product-featurettes.js\");\n/* harmony import */ var _lib_anim_scrollreveal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/anim-scrollreveal */ \"./src/js/lib/anim-scrollreveal.js\");\n/**\n * import modules\n */\n// import Flickity from 'flickity';\n\n\n\n\n\n/**\n * namespace\n * @type {Object}\n */\nSDG.Home = SDG.Home || {};\n\n/**\n * run\n */\nSDG.Home.run = function () {\n\n\t// newsletter banner\n\tSDG.Newsletter.banner({\n\t\tnamespace: 'banner'\n\t});\n\n\t// home product grid\n\tSDG.Home.hpg();\n\n\t// home product featurettes\n\tObject(_lib_product_featurettes__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n\n\t// b-touts__items fade In on ScrollReveal\n\tObject(_lib_anim_scrollreveal__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n\n\t// video\n\tconst videoEmbed = Object(_lib_video__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n\t\tid: 'homeVid'\n\t});\n\tvideoEmbed.init();\n\n\t// // parallax\n\t// eslint-disable-next-line\n\tnew rellax__WEBPACK_IMPORTED_MODULE_0___default.a('.js-rellax');\n};\n\n/**\n * Home Product Grid\n */\nSDG.Home.hpg = function () {\n\tconst c = {\n\t\tcls: {\n\t\t\tactive: 'is-active',\n\t\t\tselected: 'is-selected'\n\t\t},\n\t\tid: {\n\t\t\thome_product_grid: 'hpgCarousel'\n\t\t}\n\t};\n\tconst $hpg = document.getElementById(c.id.home_product_grid);\n\n\tif ($hpg) {\n\t\t/*\n  // eslint-disable-next-line\n  const flkty = new Flickity(`#${c.id.home_product_grid}`, {\n  \twatchCSS: true,\n  \tpageDots: false\n  });\n  */\n\t}\n};\n\n/**\n * fire functions\n */\nSDG.Home.run();\n\n//# sourceURL=webpack:///./src/js/build/index.js?")},"./src/js/lib/anim-scrollreveal.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var scrollreveal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! scrollreveal */ \"./node_modules/scrollreveal/dist/scrollreveal.js\");\n/* harmony import */ var scrollreveal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(scrollreveal__WEBPACK_IMPORTED_MODULE_0__);\n\n\nSDG.ToutsReveal = function () {\n\n\tconst sr = scrollreveal__WEBPACK_IMPORTED_MODULE_0___default()();\n\n\tsr.reveal('.b-touts__item:nth-child(1)', {\n\t\tduration: 400,\n\t\torigin: 'left',\n\t\tdistance: '150px'\n\t});\n\n\tsr.reveal('.b-touts__item:nth-child(2)', {\n\t\tduration: 400,\n\t\torigin: 'left',\n\t\tdelay: 400,\n\t\tdistance: '150px'\n\t});\n\n\tsr.reveal('.b-touts__item:nth-child(3)', {\n\t\tduration: 400,\n\t\torigin: 'left',\n\t\tdelay: 800,\n\t\tdistance: '150px'\n\t});\n\n\tsr.reveal('.vid__image', {\n\t\tduration: 700,\n\t\torigin: 'top',\n\t\tdistance: '400px'\n\t});\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SDG.ToutsReveal);\n\n//# sourceURL=webpack:///./src/js/lib/anim-scrollreveal.js?")},"./src/js/lib/product-featurettes.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var flickity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flickity */ \"./node_modules/flickity/js/index.js\");\n/* harmony import */ var flickity__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(flickity__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Home Product Featurettes\n */\n\n\n\nSDG.ProductFeaturettes = function (opts) {\n\tconst config = {\n\t\tcls: {\n\t\t\tbackground: '.js-pf-bg',\n\t\t\tnext_btn: 'js-carousel-next',\n\t\t\tprev_btn: 'js-carousel-prev',\n\t\t\tbackground_set: 'bg-set',\n\t\t\tvisible: 'is-visible'\n\t\t},\n\t\tid: {\n\t\t\tcarousel: 'pfCarousel'\n\t\t},\n\t\ttimer: 150\n\t};\n\tconst c = _.extend(config, opts);\n\tconst $pf = document.getElementById(c.id.carousel);\n\tlet $pfBackgrounds;\n\tlet flkty;\n\n\tif ($pf) {\n\t\t$pfBackgrounds = $pf.querySelectorAll(c.cls.background);\n\n\t\t// slide effect on Founder Section\n\t\t// backgroundSlide({\n\t\t// \tid: 'pf__carousel',\n\t\t// \toffset: 500,\n\t\t// \ttimer: 200,\n\t\t// \tcl: 'pf__content'\n\t\t// }).init();\n\n\t\taddEvents();\n\n\t\t// eslint-disable-next-line\n\t\tflkty = new flickity__WEBPACK_IMPORTED_MODULE_0___default.a(`#${c.id.carousel}`, {\n\t\t\tcellAlign: 'left',\n\t\t\tfullscreen: true,\n\t\t\tpageDots: false,\n\t\t\tprevNextButtons: false,\n\t\t\twrapAround: true\n\t\t});\n\t}\n\n\tfunction addEvents() {\n\t\t_.addEvent({\n\t\t\tid: c.id.carousel,\n\t\t\tclassName: c.cls.next_btn,\n\t\t\tevent: 'click',\n\t\t\tfn() {\n\t\t\t\tflkty.next();\n\t\t\t}\n\t\t});\n\n\t\t_.addEvent({\n\t\t\tid: c.id.carousel,\n\t\t\tclassName: c.cls.prev_btn,\n\t\t\tevent: 'click',\n\t\t\tfn() {\n\t\t\t\tflkty.previous();\n\t\t\t}\n\t\t});\n\n\t\t_.waypoint({\n\t\t\tel: $pf,\n\t\t\tin: triggerParalax,\n\t\t\toffset: 700\n\t\t});\n\t}\n\n\tfunction triggerParalax() {\n\t\tArray.prototype.forEach.call($pfBackgrounds, bg => {\n\t\t\t_.addClass(bg, c.cls.visible);\n\t\t});\n\n\t\tsetTimeout(showContent, c.timer);\n\t}\n\n\tfunction showContent() {\n\t\t_.addClass($pf, c.cls.background_set);\n\t}\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SDG.ProductFeaturettes);\n\n//# sourceURL=webpack:///./src/js/lib/product-featurettes.js?")},"./src/js/lib/video.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/**\n * video embed\n * @param  {Object}  Config object\n * @requires [lib/util.js,lib/modal.js,lib/modal-get.js,lib/modal-clear.js]\n */\nSDG.videoEmbed = function (opts) {\n\tconst config = {\n\t\tid: 'vid',\n\t\timage: '.js-vid-image',\n\t\tclass: {\n\t\t\tembed: 'vid__embed',\n\t\t\tfade_out: 'is-fading-out',\n\t\t\thas_embed: 'has-embed',\n\t\t\tir: 'ir ir--vid'\n\t\t},\n\t\tvideo_url: {\n\t\t\tyoutube: 'https://www.youtube.com/embed/',\n\t\t\tvimeo: 'https://player.vimeo.com/video/'\n\t\t},\n\t\tshow_in_modal: false,\n\t\tmodal: null // keys: id, modifier, overlay\n\t};\n\tconst c = _.extend(config, opts);\n\n\t// globals\n\tconst video = document.getElementById(c.id);\n\n\t/**\n  * init\n  * @return {Function}\n  */\n\tfunction init() {\n\t\tbindEvents();\n\t}\n\n\t/**\n  * bind events\n  * @return {Function}\n  */\n\tfunction bindEvents() {\n\t\tif (video) {\n\t\t\tif (c.show_in_modal) {\n\t\t\t\tvideo.addEventListener('click', generateModal, false);\n\t\t\t} else {\n\t\t\t\tvideo.addEventListener('click', insertVideo, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * unbind events\n  * @return {Function}\n  */\n\tfunction unbindEvents() {\n\t\tif (c.show_in_modal) {\n\t\t\tvideo.removeEventListener('click', generateModal, false);\n\t\t} else {\n\t\t\tvideo.removeEventListener('click', insertVideo, false);\n\t\t}\n\t}\n\n\t/**\n  * insert video\n  * @return {Function}\n  */\n\tfunction insertVideo() {\n\t\tconst videoId = this.getAttribute('data-video-id');\n\t\tconst videoPlayer = this.getAttribute('data-video-player');\n\t\tconst videoImage = video.querySelector(c.image);\n\t\tconst videoEmbed = buildEmbed(videoId, videoPlayer);\n\n\t\t// unbind events\n\t\tunbindEvents();\n\n\t\t// transition image-to-video\n\t\t_.transition({\n\t\t\tbefore: () => {\n\n\t\t\t\t// add fade-out class to image\n\t\t\t\t_.addClass(videoImage, c.class.fade_out);\n\t\t\t},\n\t\t\tafter: () => {\n\t\t\t\t// hide image\n\t\t\t\tvideoImage.style.display = 'none';\n\n\t\t\t\t// remove fade-out class from image\n\t\t\t\t_.removeClass(videoImage, c.class.fade_out);\n\n\t\t\t\t// prepend video embed to video container\n\t\t\t\tvideo.insertBefore(videoEmbed, videoImage);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n  * video player chocie\n  * @param {String} videoPlayer\n  * @return {Function}\n  */\n\tfunction videoPlayerChoice(videoPlayer) {\n\t\tlet videoUrlPlayer;\n\n\t\tswitch (videoPlayer) {\n\t\t\tcase 'vimeo':\n\t\t\t\tvideoUrlPlayer = c.video_url.vimeo;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvideoUrlPlayer = c.video_url.youtube;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn videoUrlPlayer;\n\t}\n\n\t/**\n  * build embed\n  * @param  {String} videoId     Id of the video on youtube or vimeo\n  * @param  {String} videoPlayer Type of player, youtube or vimeo. Default is youtube\n  * @return {String}             Html for the iframe embed\n  */\n\tfunction buildEmbed(videoId, videoPlayer) {\n\n\t\tconst videoChoice = videoPlayerChoice(videoPlayer);\n\t\tconst videoUrl = `${videoChoice}${videoId}?autoplay=1&rel=0`;\n\t\tconst videoEmbed = document.createElement('div');\n\t\tconst videoIframe = `<iframe width=\"1280\" height=\"720\" src=\"${videoUrl}\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>`;\n\n\t\t// set class name\n\t\tvideoEmbed.className = `${c.class.embed} ${c.class.ir}`;\n\n\t\t// append iframe html to embed div\n\t\tvideoEmbed.innerHTML = videoIframe;\n\n\t\treturn videoEmbed;\n\t}\n\n\t/**\n  * generate modal\n  * @return {Function}\n  */\n\tfunction generateModal() {\n\t\tconst videoId = this.getAttribute('data-video-id');\n\t\tconst videoPlayer = this.getAttribute('data-video-player');\n\t\tconst videoChoice = videoPlayerChoice(videoPlayer);\n\t\tconst videoUrl = `${videoChoice}${videoId}?autoplay=1&rel=0`;\n\t\tconst html = `<div class=\"vid__embed ir ir--vid\">\n\t\t\t\t<iframe width=\"1280\" height=\"720\" src=\"${videoUrl}\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>\n\t\t\t</div>`;\n\n\t\tlet md;\n\t\tlet modalWrap;\n\n\t\tif (c.modal) {\n\t\t\tmd = SDG.Modal.getHtml({\n\t\t\t\tmodal: c.modal.id,\n\t\t\t\tmodifier: c.modal.modifier,\n\t\t\t\toverlay: c.modal.overlay,\n\t\t\t\thtml\n\t\t\t}).render();\n\n\t\t\tmodalWrap = document.createElement('div');\n\t\t\tmodalWrap.innerHTML = md;\n\t\t\tdocument.body.appendChild(modalWrap);\n\n\t\t\tsetTimeout(() => initVideo, 20);\n\t\t}\n\n\t\tfunction initVideo() {\n\t\t\tconst videoModal = SDG.Modal({\n\t\t\t\tdom: {\n\t\t\t\t\tmodal_id: c.modal.id\n\t\t\t\t},\n\t\t\t\tcb: {\n\t\t\t\t\tclose: attachCloseEvent\n\t\t\t\t}\n\t\t\t});\n\t\t\tvideoModal.init();\n\t\t\tvideoModal.open(c.modal.id);\n\t\t}\n\n\t\tfunction attachCloseEvent() {\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst clear = SDG.Modal.clear({\n\t\t\t\t\tmodal: c.modal.id,\n\t\t\t\t\toverlay: c.modal.overlay\n\t\t\t\t});\n\t\t\t\tclear.init();\n\t\t\t}, 500);\n\t\t}\n\t}\n\n\treturn { init };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SDG.videoEmbed);\n\n//# sourceURL=webpack:///./src/js/lib/video.js?")}});