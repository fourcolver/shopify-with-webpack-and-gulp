/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/build/product.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/desandro-matches-selector/matches-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/desandro-matches-selector/matches-selector.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * matchesSelector v2.0.2\n * matchesSelector( element, '.selector' )\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n\n(function (window, factory) {\n  /*global define: false, module: false */\n  'use strict';\n  // universal module definition\n\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory() {\n  'use strict';\n\n  var matchesMethod = function () {\n    var ElemProto = window.Element.prototype;\n    // check for the standard method name first\n    if (ElemProto.matches) {\n      return 'matches';\n    }\n    // check un-prefixed\n    if (ElemProto.matchesSelector) {\n      return 'matchesSelector';\n    }\n    // check vendor prefixes\n    var prefixes = ['webkit', 'moz', 'ms', 'o'];\n\n    for (var i = 0; i < prefixes.length; i++) {\n      var prefix = prefixes[i];\n      var method = prefix + 'MatchesSelector';\n      if (ElemProto[method]) {\n        return method;\n      }\n    }\n  }();\n\n  return function matchesSelector(elem, selector) {\n    return elem[matchesMethod](selector);\n  };\n});\n\n//# sourceURL=webpack:///./node_modules/desandro-matches-selector/matches-selector.js?");

/***/ }),

/***/ "./node_modules/ev-emitter/ev-emitter.js":
/*!***********************************************!*\
  !*** ./node_modules/ev-emitter/ev-emitter.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * EvEmitter v1.1.0\n * Lil' event emitter\n * MIT License\n */\n\n/* jshint unused: true, undef: true, strict: true */\n\n(function (global, factory) {\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, window */\n  if (true) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(typeof window != 'undefined' ? window : this, function () {\n\n  \"use strict\";\n\n  function EvEmitter() {}\n\n  var proto = EvEmitter.prototype;\n\n  proto.on = function (eventName, listener) {\n    if (!eventName || !listener) {\n      return;\n    }\n    // set events hash\n    var events = this._events = this._events || {};\n    // set listeners array\n    var listeners = events[eventName] = events[eventName] || [];\n    // only add once\n    if (listeners.indexOf(listener) == -1) {\n      listeners.push(listener);\n    }\n\n    return this;\n  };\n\n  proto.once = function (eventName, listener) {\n    if (!eventName || !listener) {\n      return;\n    }\n    // add event\n    this.on(eventName, listener);\n    // set once flag\n    // set onceEvents hash\n    var onceEvents = this._onceEvents = this._onceEvents || {};\n    // set onceListeners object\n    var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};\n    // set flag\n    onceListeners[listener] = true;\n\n    return this;\n  };\n\n  proto.off = function (eventName, listener) {\n    var listeners = this._events && this._events[eventName];\n    if (!listeners || !listeners.length) {\n      return;\n    }\n    var index = listeners.indexOf(listener);\n    if (index != -1) {\n      listeners.splice(index, 1);\n    }\n\n    return this;\n  };\n\n  proto.emitEvent = function (eventName, args) {\n    var listeners = this._events && this._events[eventName];\n    if (!listeners || !listeners.length) {\n      return;\n    }\n    // copy over to avoid interference if .off() in listener\n    listeners = listeners.slice(0);\n    args = args || [];\n    // once stuff\n    var onceListeners = this._onceEvents && this._onceEvents[eventName];\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      var isOnce = onceListeners && onceListeners[listener];\n      if (isOnce) {\n        // remove listener\n        // remove before trigger to prevent recursion\n        this.off(eventName, listener);\n        // unset once flag\n        delete onceListeners[listener];\n      }\n      // trigger listener\n      listener.apply(this, args);\n    }\n\n    return this;\n  };\n\n  proto.allOff = function () {\n    delete this._events;\n    delete this._onceEvents;\n  };\n\n  return EvEmitter;\n});\n\n//# sourceURL=webpack:///./node_modules/ev-emitter/ev-emitter.js?");

/***/ }),

/***/ "./node_modules/fizzy-ui-utils/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/fizzy-ui-utils/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Fizzy UI utils v2.0.7\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n(function (window, factory) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! desandro-matches-selector/matches-selector */ \"./node_modules/desandro-matches-selector/matches-selector.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (matchesSelector) {\n      return factory(window, matchesSelector);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, matchesSelector) {\n\n  'use strict';\n\n  var utils = {};\n\n  // ----- extend ----- //\n\n  // extends objects\n  utils.extend = function (a, b) {\n    for (var prop in b) {\n      a[prop] = b[prop];\n    }\n    return a;\n  };\n\n  // ----- modulo ----- //\n\n  utils.modulo = function (num, div) {\n    return (num % div + div) % div;\n  };\n\n  // ----- makeArray ----- //\n\n  var arraySlice = Array.prototype.slice;\n\n  // turn element or nodeList into an array\n  utils.makeArray = function (obj) {\n    if (Array.isArray(obj)) {\n      // use object if already an array\n      return obj;\n    }\n    // return empty array if undefined or null. #6\n    if (obj === null || obj === undefined) {\n      return [];\n    }\n\n    var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';\n    if (isArrayLike) {\n      // convert nodeList to array\n      return arraySlice.call(obj);\n    }\n\n    // array of single index\n    return [obj];\n  };\n\n  // ----- removeFrom ----- //\n\n  utils.removeFrom = function (ary, obj) {\n    var index = ary.indexOf(obj);\n    if (index != -1) {\n      ary.splice(index, 1);\n    }\n  };\n\n  // ----- getParent ----- //\n\n  utils.getParent = function (elem, selector) {\n    while (elem.parentNode && elem != document.body) {\n      elem = elem.parentNode;\n      if (matchesSelector(elem, selector)) {\n        return elem;\n      }\n    }\n  };\n\n  // ----- getQueryElement ----- //\n\n  // use element as selector string\n  utils.getQueryElement = function (elem) {\n    if (typeof elem == 'string') {\n      return document.querySelector(elem);\n    }\n    return elem;\n  };\n\n  // ----- handleEvent ----- //\n\n  // enable .ontype to trigger from .addEventListener( elem, 'type' )\n  utils.handleEvent = function (event) {\n    var method = 'on' + event.type;\n    if (this[method]) {\n      this[method](event);\n    }\n  };\n\n  // ----- filterFindElements ----- //\n\n  utils.filterFindElements = function (elems, selector) {\n    // make array of elems\n    elems = utils.makeArray(elems);\n    var ffElems = [];\n\n    elems.forEach(function (elem) {\n      // check that elem is an actual element\n      if (!(elem instanceof HTMLElement)) {\n        return;\n      }\n      // add elem if no selector\n      if (!selector) {\n        ffElems.push(elem);\n        return;\n      }\n      // filter & find items if we have a selector\n      // filter\n      if (matchesSelector(elem, selector)) {\n        ffElems.push(elem);\n      }\n      // find children\n      var childElems = elem.querySelectorAll(selector);\n      // concat childElems to filterFound array\n      for (var i = 0; i < childElems.length; i++) {\n        ffElems.push(childElems[i]);\n      }\n    });\n\n    return ffElems;\n  };\n\n  // ----- debounceMethod ----- //\n\n  utils.debounceMethod = function (_class, methodName, threshold) {\n    threshold = threshold || 100;\n    // original method\n    var method = _class.prototype[methodName];\n    var timeoutName = methodName + 'Timeout';\n\n    _class.prototype[methodName] = function () {\n      var timeout = this[timeoutName];\n      clearTimeout(timeout);\n\n      var args = arguments;\n      var _this = this;\n      this[timeoutName] = setTimeout(function () {\n        method.apply(_this, args);\n        delete _this[timeoutName];\n      }, threshold);\n    };\n  };\n\n  // ----- docReady ----- //\n\n  utils.docReady = function (callback) {\n    var readyState = document.readyState;\n    if (readyState == 'complete' || readyState == 'interactive') {\n      // do async to allow for other scripts to run. metafizzy/flickity#441\n      setTimeout(callback);\n    } else {\n      document.addEventListener('DOMContentLoaded', callback);\n    }\n  };\n\n  // ----- htmlInit ----- //\n\n  // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/\n  utils.toDashed = function (str) {\n    return str.replace(/(.)([A-Z])/g, function (match, $1, $2) {\n      return $1 + '-' + $2;\n    }).toLowerCase();\n  };\n\n  var console = window.console;\n  /**\n   * allow user to initialize classes via [data-namespace] or .js-namespace class\n   * htmlInit( Widget, 'widgetName' )\n   * options are parsed from data-namespace-options\n   */\n  utils.htmlInit = function (WidgetClass, namespace) {\n    utils.docReady(function () {\n      var dashedNamespace = utils.toDashed(namespace);\n      var dataAttr = 'data-' + dashedNamespace;\n      var dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');\n      var jsDashElems = document.querySelectorAll('.js-' + dashedNamespace);\n      var elems = utils.makeArray(dataAttrElems).concat(utils.makeArray(jsDashElems));\n      var dataOptionsAttr = dataAttr + '-options';\n      var jQuery = window.jQuery;\n\n      elems.forEach(function (elem) {\n        var attr = elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);\n        var options;\n        try {\n          options = attr && JSON.parse(attr);\n        } catch (error) {\n          // log error, do not initialize\n          if (console) {\n            console.error('Error parsing ' + dataAttr + ' on ' + elem.className + ': ' + error);\n          }\n          return;\n        }\n        // initialize\n        var instance = new WidgetClass(elem, options);\n        // make available via $().data('namespace')\n        if (jQuery) {\n          jQuery.data(elem, namespace, instance);\n        }\n      });\n    });\n  };\n\n  // -----  ----- //\n\n  return utils;\n});\n\n//# sourceURL=webpack:///./node_modules/fizzy-ui-utils/utils.js?");

/***/ }),

/***/ "./node_modules/flickity-as-nav-for/as-nav-for.js":
/*!********************************************************!*\
  !*** ./node_modules/flickity-as-nav-for/as-nav-for.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Flickity asNavFor v2.0.1\n * enable asNavFor for Flickity\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true*/\n\n(function (window, factory) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! flickity/js/index */ \"./node_modules/flickity/js/index.js\"), __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(Flickity, utils) {\n\n  'use strict';\n\n  // -------------------------- asNavFor prototype -------------------------- //\n\n  // Flickity.defaults.asNavFor = null;\n\n  Flickity.createMethods.push('_createAsNavFor');\n\n  var proto = Flickity.prototype;\n\n  proto._createAsNavFor = function () {\n    this.on('activate', this.activateAsNavFor);\n    this.on('deactivate', this.deactivateAsNavFor);\n    this.on('destroy', this.destroyAsNavFor);\n\n    var asNavForOption = this.options.asNavFor;\n    if (!asNavForOption) {\n      return;\n    }\n    // HACK do async, give time for other flickity to be initalized\n    var _this = this;\n    setTimeout(function initNavCompanion() {\n      _this.setNavCompanion(asNavForOption);\n    });\n  };\n\n  proto.setNavCompanion = function (elem) {\n    elem = utils.getQueryElement(elem);\n    var companion = Flickity.data(elem);\n    // stop if no companion or companion is self\n    if (!companion || companion == this) {\n      return;\n    }\n\n    this.navCompanion = companion;\n    // companion select\n    var _this = this;\n    this.onNavCompanionSelect = function () {\n      _this.navCompanionSelect();\n    };\n    companion.on('select', this.onNavCompanionSelect);\n    // click\n    this.on('staticClick', this.onNavStaticClick);\n\n    this.navCompanionSelect(true);\n  };\n\n  proto.navCompanionSelect = function (isInstant) {\n    if (!this.navCompanion) {\n      return;\n    }\n    // select slide that matches first cell of slide\n    var selectedCell = this.navCompanion.selectedCells[0];\n    var firstIndex = this.navCompanion.cells.indexOf(selectedCell);\n    var lastIndex = firstIndex + this.navCompanion.selectedCells.length - 1;\n    var selectIndex = Math.floor(lerp(firstIndex, lastIndex, this.navCompanion.cellAlign));\n    this.selectCell(selectIndex, false, isInstant);\n    // set nav selected class\n    this.removeNavSelectedElements();\n    // stop if companion has more cells than this one\n    if (selectIndex >= this.cells.length) {\n      return;\n    }\n\n    var selectedCells = this.cells.slice(firstIndex, lastIndex + 1);\n    this.navSelectedElements = selectedCells.map(function (cell) {\n      return cell.element;\n    });\n    this.changeNavSelectedClass('add');\n  };\n\n  function lerp(a, b, t) {\n    return (b - a) * t + a;\n  }\n\n  proto.changeNavSelectedClass = function (method) {\n    this.navSelectedElements.forEach(function (navElem) {\n      navElem.classList[method]('is-nav-selected');\n    });\n  };\n\n  proto.activateAsNavFor = function () {\n    this.navCompanionSelect(true);\n  };\n\n  proto.removeNavSelectedElements = function () {\n    if (!this.navSelectedElements) {\n      return;\n    }\n    this.changeNavSelectedClass('remove');\n    delete this.navSelectedElements;\n  };\n\n  proto.onNavStaticClick = function (event, pointer, cellElement, cellIndex) {\n    if (typeof cellIndex == 'number') {\n      this.navCompanion.selectCell(cellIndex);\n    }\n  };\n\n  proto.deactivateAsNavFor = function () {\n    this.removeNavSelectedElements();\n  };\n\n  proto.destroyAsNavFor = function () {\n    if (!this.navCompanion) {\n      return;\n    }\n    this.navCompanion.off('select', this.onNavCompanionSelect);\n    this.off('staticClick', this.onNavStaticClick);\n    delete this.navCompanion;\n  };\n\n  // -----  ----- //\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity-as-nav-for/as-nav-for.js?");

/***/ }),

/***/ "./node_modules/flickity/js/add-remove-cell.js":
/*!*****************************************************!*\
  !*** ./node_modules/flickity/js/add-remove-cell.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// add, remove cell\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Flickity, utils) {\n      return factory(window, Flickity, utils);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, Flickity, utils) {\n\n  'use strict';\n\n  // append cells to a document fragment\n\n  function getCellsFragment(cells) {\n    var fragment = document.createDocumentFragment();\n    cells.forEach(function (cell) {\n      fragment.appendChild(cell.element);\n    });\n    return fragment;\n  }\n\n  // -------------------------- add/remove cell prototype -------------------------- //\n\n  var proto = Flickity.prototype;\n\n  /**\n   * Insert, prepend, or append cells\n   * @param {Element, Array, NodeList} elems\n   * @param {Integer} index\n   */\n  proto.insert = function (elems, index) {\n    var cells = this._makeCells(elems);\n    if (!cells || !cells.length) {\n      return;\n    }\n    var len = this.cells.length;\n    // default to append\n    index = index === undefined ? len : index;\n    // add cells with document fragment\n    var fragment = getCellsFragment(cells);\n    // append to slider\n    var isAppend = index == len;\n    if (isAppend) {\n      this.slider.appendChild(fragment);\n    } else {\n      var insertCellElement = this.cells[index].element;\n      this.slider.insertBefore(fragment, insertCellElement);\n    }\n    // add to this.cells\n    if (index === 0) {\n      // prepend, add to start\n      this.cells = cells.concat(this.cells);\n    } else if (isAppend) {\n      // append, add to end\n      this.cells = this.cells.concat(cells);\n    } else {\n      // insert in this.cells\n      var endCells = this.cells.splice(index, len - index);\n      this.cells = this.cells.concat(cells).concat(endCells);\n    }\n\n    this._sizeCells(cells);\n    this.cellChange(index, true);\n  };\n\n  proto.append = function (elems) {\n    this.insert(elems, this.cells.length);\n  };\n\n  proto.prepend = function (elems) {\n    this.insert(elems, 0);\n  };\n\n  /**\n   * Remove cells\n   * @param {Element, Array, NodeList} elems\n   */\n  proto.remove = function (elems) {\n    var cells = this.getCells(elems);\n    if (!cells || !cells.length) {\n      return;\n    }\n\n    var minCellIndex = this.cells.length - 1;\n    // remove cells from collection & DOM\n    cells.forEach(function (cell) {\n      cell.remove();\n      var index = this.cells.indexOf(cell);\n      minCellIndex = Math.min(index, minCellIndex);\n      utils.removeFrom(this.cells, cell);\n    }, this);\n\n    this.cellChange(minCellIndex, true);\n  };\n\n  /**\n   * logic to be run after a cell's size changes\n   * @param {Element} elem - cell's element\n   */\n  proto.cellSizeChange = function (elem) {\n    var cell = this.getCell(elem);\n    if (!cell) {\n      return;\n    }\n    cell.getSize();\n\n    var index = this.cells.indexOf(cell);\n    this.cellChange(index);\n  };\n\n  /**\n   * logic any time a cell is changed: added, removed, or size changed\n   * @param {Integer} changedCellIndex - index of the changed cell, optional\n   */\n  proto.cellChange = function (changedCellIndex, isPositioningSlider) {\n    var prevSelectedElem = this.selectedElement;\n    this._positionCells(changedCellIndex);\n    this._getWrapShiftCells();\n    this.setGallerySize();\n    // update selectedIndex\n    // try to maintain position & select previous selected element\n    var cell = this.getCell(prevSelectedElem);\n    if (cell) {\n      this.selectedIndex = this.getCellSlideIndex(cell);\n    }\n    this.selectedIndex = Math.min(this.slides.length - 1, this.selectedIndex);\n\n    this.emitEvent('cellChange', [changedCellIndex]);\n    // position slider\n    this.select(this.selectedIndex);\n    // do not position slider after lazy load\n    if (isPositioningSlider) {\n      this.positionSliderAtSelected();\n    }\n  };\n\n  // -----  ----- //\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/add-remove-cell.js?");

/***/ }),

/***/ "./node_modules/flickity/js/animate.js":
/*!*********************************************!*\
  !*** ./node_modules/flickity/js/animate.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// animate\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (utils) {\n      return factory(window, utils);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, utils) {\n\n  'use strict';\n\n  // -------------------------- animate -------------------------- //\n\n  var proto = {};\n\n  proto.startAnimation = function () {\n    if (this.isAnimating) {\n      return;\n    }\n\n    this.isAnimating = true;\n    this.restingFrames = 0;\n    this.animate();\n  };\n\n  proto.animate = function () {\n    this.applyDragForce();\n    this.applySelectedAttraction();\n\n    var previousX = this.x;\n\n    this.integratePhysics();\n    this.positionSlider();\n    this.settle(previousX);\n    // animate next frame\n    if (this.isAnimating) {\n      var _this = this;\n      requestAnimationFrame(function animateFrame() {\n        _this.animate();\n      });\n    }\n  };\n\n  proto.positionSlider = function () {\n    var x = this.x;\n    // wrap position around\n    if (this.options.wrapAround && this.cells.length > 1) {\n      x = utils.modulo(x, this.slideableWidth);\n      x = x - this.slideableWidth;\n      this.shiftWrapCells(x);\n    }\n\n    this.setTranslateX(x, this.isAnimating);\n    this.dispatchScrollEvent();\n  };\n\n  proto.setTranslateX = function (x, is3d) {\n    x += this.cursorPosition;\n    // reverse if right-to-left and using transform\n    x = this.options.rightToLeft ? -x : x;\n    var translateX = this.getPositionValue(x);\n    // use 3D tranforms for hardware acceleration on iOS\n    // but use 2D when settled, for better font-rendering\n    this.slider.style.transform = is3d ? 'translate3d(' + translateX + ',0,0)' : 'translateX(' + translateX + ')';\n  };\n\n  proto.dispatchScrollEvent = function () {\n    var firstSlide = this.slides[0];\n    if (!firstSlide) {\n      return;\n    }\n    var positionX = -this.x - firstSlide.target;\n    var progress = positionX / this.slidesWidth;\n    this.dispatchEvent('scroll', null, [progress, positionX]);\n  };\n\n  proto.positionSliderAtSelected = function () {\n    if (!this.cells.length) {\n      return;\n    }\n    this.x = -this.selectedSlide.target;\n    this.velocity = 0; // stop wobble\n    this.positionSlider();\n  };\n\n  proto.getPositionValue = function (position) {\n    if (this.options.percentPosition) {\n      // percent position, round to 2 digits, like 12.34%\n      return Math.round(position / this.size.innerWidth * 10000) * 0.01 + '%';\n    } else {\n      // pixel positioning\n      return Math.round(position) + 'px';\n    }\n  };\n\n  proto.settle = function (previousX) {\n    // keep track of frames where x hasn't moved\n    if (!this.isPointerDown && Math.round(this.x * 100) == Math.round(previousX * 100)) {\n      this.restingFrames++;\n    }\n    // stop animating if resting for 3 or more frames\n    if (this.restingFrames > 2) {\n      this.isAnimating = false;\n      delete this.isFreeScrolling;\n      // render position with translateX when settled\n      this.positionSlider();\n      this.dispatchEvent('settle', null, [this.selectedIndex]);\n    }\n  };\n\n  proto.shiftWrapCells = function (x) {\n    // shift before cells\n    var beforeGap = this.cursorPosition + x;\n    this._shiftCells(this.beforeShiftCells, beforeGap, -1);\n    // shift after cells\n    var afterGap = this.size.innerWidth - (x + this.slideableWidth + this.cursorPosition);\n    this._shiftCells(this.afterShiftCells, afterGap, 1);\n  };\n\n  proto._shiftCells = function (cells, gap, shift) {\n    for (var i = 0; i < cells.length; i++) {\n      var cell = cells[i];\n      var cellShift = gap > 0 ? shift : 0;\n      cell.wrapShift(cellShift);\n      gap -= cell.size.outerWidth;\n    }\n  };\n\n  proto._unshiftCells = function (cells) {\n    if (!cells || !cells.length) {\n      return;\n    }\n    for (var i = 0; i < cells.length; i++) {\n      cells[i].wrapShift(0);\n    }\n  };\n\n  // -------------------------- physics -------------------------- //\n\n  proto.integratePhysics = function () {\n    this.x += this.velocity;\n    this.velocity *= this.getFrictionFactor();\n  };\n\n  proto.applyForce = function (force) {\n    this.velocity += force;\n  };\n\n  proto.getFrictionFactor = function () {\n    return 1 - this.options[this.isFreeScrolling ? 'freeScrollFriction' : 'friction'];\n  };\n\n  proto.getRestingPosition = function () {\n    // my thanks to Steven Wittens, who simplified this math greatly\n    return this.x + this.velocity / (1 - this.getFrictionFactor());\n  };\n\n  proto.applyDragForce = function () {\n    if (!this.isDraggable || !this.isPointerDown) {\n      return;\n    }\n    // change the position to drag position by applying force\n    var dragVelocity = this.dragX - this.x;\n    var dragForce = dragVelocity - this.velocity;\n    this.applyForce(dragForce);\n  };\n\n  proto.applySelectedAttraction = function () {\n    // do not attract if pointer down or no slides\n    var dragDown = this.isDraggable && this.isPointerDown;\n    if (dragDown || this.isFreeScrolling || !this.slides.length) {\n      return;\n    }\n    var distance = this.selectedSlide.target * -1 - this.x;\n    var force = distance * this.options.selectedAttraction;\n    this.applyForce(force);\n  };\n\n  return proto;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/animate.js?");

/***/ }),

/***/ "./node_modules/flickity/js/cell.js":
/*!******************************************!*\
  !*** ./node_modules/flickity/js/cell.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Flickity.Cell\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! get-size/get-size */ \"./node_modules/get-size/get-size.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (getSize) {\n      return factory(window, getSize);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, getSize) {\n\n  'use strict';\n\n  function Cell(elem, parent) {\n    this.element = elem;\n    this.parent = parent;\n\n    this.create();\n  }\n\n  var proto = Cell.prototype;\n\n  proto.create = function () {\n    this.element.style.position = 'absolute';\n    this.element.setAttribute('aria-hidden', 'true');\n    this.x = 0;\n    this.shift = 0;\n  };\n\n  proto.destroy = function () {\n    // reset style\n    this.unselect();\n    this.element.style.position = '';\n    var side = this.parent.originSide;\n    this.element.style[side] = '';\n  };\n\n  proto.getSize = function () {\n    this.size = getSize(this.element);\n  };\n\n  proto.setPosition = function (x) {\n    this.x = x;\n    this.updateTarget();\n    this.renderPosition(x);\n  };\n\n  // setDefaultTarget v1 method, backwards compatibility, remove in v3\n  proto.updateTarget = proto.setDefaultTarget = function () {\n    var marginProperty = this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';\n    this.target = this.x + this.size[marginProperty] + this.size.width * this.parent.cellAlign;\n  };\n\n  proto.renderPosition = function (x) {\n    // render position of cell with in slider\n    var side = this.parent.originSide;\n    this.element.style[side] = this.parent.getPositionValue(x);\n  };\n\n  proto.select = function () {\n    this.element.classList.add('is-selected');\n    this.element.removeAttribute('aria-hidden');\n  };\n\n  proto.unselect = function () {\n    this.element.classList.remove('is-selected');\n    this.element.setAttribute('aria-hidden', 'true');\n  };\n\n  /**\n   * @param {Integer} factor - 0, 1, or -1\n  **/\n  proto.wrapShift = function (shift) {\n    this.shift = shift;\n    this.renderPosition(this.x + this.parent.slideableWidth * shift);\n  };\n\n  proto.remove = function () {\n    this.element.parentNode.removeChild(this.element);\n  };\n\n  return Cell;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/cell.js?");

/***/ }),

/***/ "./node_modules/flickity/js/drag.js":
/*!******************************************!*\
  !*** ./node_modules/flickity/js/drag.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// drag\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! unidragger/unidragger */ \"./node_modules/unidragger/unidragger.js\"), __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Flickity, Unidragger, utils) {\n      return factory(window, Flickity, Unidragger, utils);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, Flickity, Unidragger, utils) {\n\n  'use strict';\n\n  // ----- defaults ----- //\n\n  utils.extend(Flickity.defaults, {\n    draggable: '>1',\n    dragThreshold: 3\n  });\n\n  // ----- create ----- //\n\n  Flickity.createMethods.push('_createDrag');\n\n  // -------------------------- drag prototype -------------------------- //\n\n  var proto = Flickity.prototype;\n  utils.extend(proto, Unidragger.prototype);\n  proto._touchActionValue = 'pan-y';\n\n  // --------------------------  -------------------------- //\n\n  var isTouch = 'createTouch' in document;\n  var isTouchmoveScrollCanceled = false;\n\n  proto._createDrag = function () {\n    this.on('activate', this.onActivateDrag);\n    this.on('uiChange', this._uiChangeDrag);\n    this.on('deactivate', this.onDeactivateDrag);\n    this.on('cellChange', this.updateDraggable);\n    // TODO updateDraggable on resize? if groupCells & slides change\n    // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior\n    // #457, RubaXa/Sortable#973\n    if (isTouch && !isTouchmoveScrollCanceled) {\n      window.addEventListener('touchmove', function () {});\n      isTouchmoveScrollCanceled = true;\n    }\n  };\n\n  proto.onActivateDrag = function () {\n    this.handles = [this.viewport];\n    this.bindHandles();\n    this.updateDraggable();\n  };\n\n  proto.onDeactivateDrag = function () {\n    this.unbindHandles();\n    this.element.classList.remove('is-draggable');\n  };\n\n  proto.updateDraggable = function () {\n    // disable dragging if less than 2 slides. #278\n    if (this.options.draggable == '>1') {\n      this.isDraggable = this.slides.length > 1;\n    } else {\n      this.isDraggable = this.options.draggable;\n    }\n    if (this.isDraggable) {\n      this.element.classList.add('is-draggable');\n    } else {\n      this.element.classList.remove('is-draggable');\n    }\n  };\n\n  // backwards compatibility\n  proto.bindDrag = function () {\n    this.options.draggable = true;\n    this.updateDraggable();\n  };\n\n  proto.unbindDrag = function () {\n    this.options.draggable = false;\n    this.updateDraggable();\n  };\n\n  proto._uiChangeDrag = function () {\n    delete this.isFreeScrolling;\n  };\n\n  // -------------------------- pointer events -------------------------- //\n\n  proto.pointerDown = function (event, pointer) {\n    if (!this.isDraggable) {\n      this._pointerDownDefault(event, pointer);\n      return;\n    }\n    var isOkay = this.okayPointerDown(event);\n    if (!isOkay) {\n      return;\n    }\n\n    this._pointerDownPreventDefault(event);\n    this.pointerDownFocus(event);\n    // blur\n    if (document.activeElement != this.element) {\n      // do not blur if already focused\n      this.pointerDownBlur();\n    }\n\n    // stop if it was moving\n    this.dragX = this.x;\n    this.viewport.classList.add('is-pointer-down');\n    // track scrolling\n    this.pointerDownScroll = getScrollPosition();\n    window.addEventListener('scroll', this);\n\n    this._pointerDownDefault(event, pointer);\n  };\n\n  // default pointerDown logic, used for staticClick\n  proto._pointerDownDefault = function (event, pointer) {\n    // track start event position\n    // Safari 9 overrides pageX and pageY. These values needs to be copied. #779\n    this.pointerDownPointer = {\n      pageX: pointer.pageX,\n      pageY: pointer.pageY\n    };\n    // bind move and end events\n    this._bindPostStartEvents(event);\n    this.dispatchEvent('pointerDown', event, [pointer]);\n  };\n\n  var focusNodes = {\n    INPUT: true,\n    TEXTAREA: true,\n    SELECT: true\n  };\n\n  proto.pointerDownFocus = function (event) {\n    var isFocusNode = focusNodes[event.target.nodeName];\n    if (!isFocusNode) {\n      this.focus();\n    }\n  };\n\n  proto._pointerDownPreventDefault = function (event) {\n    var isTouchStart = event.type == 'touchstart';\n    var isTouchPointer = event.pointerType == 'touch';\n    var isFocusNode = focusNodes[event.target.nodeName];\n    if (!isTouchStart && !isTouchPointer && !isFocusNode) {\n      event.preventDefault();\n    }\n  };\n\n  // ----- move ----- //\n\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > this.options.dragThreshold;\n  };\n\n  // ----- up ----- //\n\n  proto.pointerUp = function (event, pointer) {\n    delete this.isTouchScrolling;\n    this.viewport.classList.remove('is-pointer-down');\n    this.dispatchEvent('pointerUp', event, [pointer]);\n    this._dragPointerUp(event, pointer);\n  };\n\n  proto.pointerDone = function () {\n    window.removeEventListener('scroll', this);\n    delete this.pointerDownScroll;\n  };\n\n  // -------------------------- dragging -------------------------- //\n\n  proto.dragStart = function (event, pointer) {\n    if (!this.isDraggable) {\n      return;\n    }\n    this.dragStartPosition = this.x;\n    this.startAnimation();\n    window.removeEventListener('scroll', this);\n    this.dispatchEvent('dragStart', event, [pointer]);\n  };\n\n  proto.pointerMove = function (event, pointer) {\n    var moveVector = this._dragPointerMove(event, pointer);\n    this.dispatchEvent('pointerMove', event, [pointer, moveVector]);\n    this._dragMove(event, pointer, moveVector);\n  };\n\n  proto.dragMove = function (event, pointer, moveVector) {\n    if (!this.isDraggable) {\n      return;\n    }\n    event.preventDefault();\n\n    this.previousDragX = this.dragX;\n    // reverse if right-to-left\n    var direction = this.options.rightToLeft ? -1 : 1;\n    if (this.options.wrapAround) {\n      // wrap around move. #589\n      moveVector.x = moveVector.x % this.slideableWidth;\n    }\n    var dragX = this.dragStartPosition + moveVector.x * direction;\n\n    if (!this.options.wrapAround && this.slides.length) {\n      // slow drag\n      var originBound = Math.max(-this.slides[0].target, this.dragStartPosition);\n      dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;\n      var endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);\n      dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;\n    }\n\n    this.dragX = dragX;\n\n    this.dragMoveTime = new Date();\n    this.dispatchEvent('dragMove', event, [pointer, moveVector]);\n  };\n\n  proto.dragEnd = function (event, pointer) {\n    if (!this.isDraggable) {\n      return;\n    }\n    if (this.options.freeScroll) {\n      this.isFreeScrolling = true;\n    }\n    // set selectedIndex based on where flick will end up\n    var index = this.dragEndRestingSelect();\n\n    if (this.options.freeScroll && !this.options.wrapAround) {\n      // if free-scroll & not wrap around\n      // do not free-scroll if going outside of bounding slides\n      // so bounding slides can attract slider, and keep it in bounds\n      var restingX = this.getRestingPosition();\n      this.isFreeScrolling = -restingX > this.slides[0].target && -restingX < this.getLastSlide().target;\n    } else if (!this.options.freeScroll && index == this.selectedIndex) {\n      // boost selection if selected index has not changed\n      index += this.dragEndBoostSelect();\n    }\n    delete this.previousDragX;\n    // apply selection\n    // TODO refactor this, selecting here feels weird\n    // HACK, set flag so dragging stays in correct direction\n    this.isDragSelect = this.options.wrapAround;\n    this.select(index);\n    delete this.isDragSelect;\n    this.dispatchEvent('dragEnd', event, [pointer]);\n  };\n\n  proto.dragEndRestingSelect = function () {\n    var restingX = this.getRestingPosition();\n    // how far away from selected slide\n    var distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex));\n    // get closet resting going up and going down\n    var positiveResting = this._getClosestResting(restingX, distance, 1);\n    var negativeResting = this._getClosestResting(restingX, distance, -1);\n    // use closer resting for wrap-around\n    var index = positiveResting.distance < negativeResting.distance ? positiveResting.index : negativeResting.index;\n    return index;\n  };\n\n  /**\n   * given resting X and distance to selected cell\n   * get the distance and index of the closest cell\n   * @param {Number} restingX - estimated post-flick resting position\n   * @param {Number} distance - distance to selected cell\n   * @param {Integer} increment - +1 or -1, going up or down\n   * @returns {Object} - { distance: {Number}, index: {Integer} }\n   */\n  proto._getClosestResting = function (restingX, distance, increment) {\n    var index = this.selectedIndex;\n    var minDistance = Infinity;\n    var condition = this.options.contain && !this.options.wrapAround ?\n    // if contain, keep going if distance is equal to minDistance\n    function (d, md) {\n      return d <= md;\n    } : function (d, md) {\n      return d < md;\n    };\n    while (condition(distance, minDistance)) {\n      // measure distance to next cell\n      index += increment;\n      minDistance = distance;\n      distance = this.getSlideDistance(-restingX, index);\n      if (distance === null) {\n        break;\n      }\n      distance = Math.abs(distance);\n    }\n    return {\n      distance: minDistance,\n      // selected was previous index\n      index: index - increment\n    };\n  };\n\n  /**\n   * measure distance between x and a slide target\n   * @param {Number} x\n   * @param {Integer} index - slide index\n   */\n  proto.getSlideDistance = function (x, index) {\n    var len = this.slides.length;\n    // wrap around if at least 2 slides\n    var isWrapAround = this.options.wrapAround && len > 1;\n    var slideIndex = isWrapAround ? utils.modulo(index, len) : index;\n    var slide = this.slides[slideIndex];\n    if (!slide) {\n      return null;\n    }\n    // add distance for wrap-around slides\n    var wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;\n    return x - (slide.target + wrap);\n  };\n\n  proto.dragEndBoostSelect = function () {\n    // do not boost if no previousDragX or dragMoveTime\n    if (this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100) {\n      return 0;\n    }\n\n    var distance = this.getSlideDistance(-this.dragX, this.selectedIndex);\n    var delta = this.previousDragX - this.dragX;\n    if (distance > 0 && delta > 0) {\n      // boost to next if moving towards the right, and positive velocity\n      return 1;\n    } else if (distance < 0 && delta < 0) {\n      // boost to previous if moving towards the left, and negative velocity\n      return -1;\n    }\n    return 0;\n  };\n\n  // ----- staticClick ----- //\n\n  proto.staticClick = function (event, pointer) {\n    // get clickedCell, if cell was clicked\n    var clickedCell = this.getParentCell(event.target);\n    var cellElem = clickedCell && clickedCell.element;\n    var cellIndex = clickedCell && this.cells.indexOf(clickedCell);\n    this.dispatchEvent('staticClick', event, [pointer, cellElem, cellIndex]);\n  };\n\n  // ----- scroll ----- //\n\n  proto.onscroll = function () {\n    var scroll = getScrollPosition();\n    var scrollMoveX = this.pointerDownScroll.x - scroll.x;\n    var scrollMoveY = this.pointerDownScroll.y - scroll.y;\n    // cancel click/tap if scroll is too much\n    if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {\n      this._pointerDone();\n    }\n  };\n\n  // ----- utils ----- //\n\n  function getScrollPosition() {\n    return {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n\n  // -----  ----- //\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/drag.js?");

/***/ }),

/***/ "./node_modules/flickity/js/flickity.js":
/*!**********************************************!*\
  !*** ./node_modules/flickity/js/flickity.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Flickity main\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ev-emitter/ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\"), __webpack_require__(/*! get-size/get-size */ \"./node_modules/get-size/get-size.js\"), __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\"), __webpack_require__(/*! ./cell */ \"./node_modules/flickity/js/cell.js\"), __webpack_require__(/*! ./slide */ \"./node_modules/flickity/js/slide.js\"), __webpack_require__(/*! ./animate */ \"./node_modules/flickity/js/animate.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {\n      return factory(window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var _Flickity; }\n})(window, function factory(window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {\n\n  'use strict';\n\n  // vars\n\n  var jQuery = window.jQuery;\n  var getComputedStyle = window.getComputedStyle;\n  var console = window.console;\n\n  function moveElements(elems, toElem) {\n    elems = utils.makeArray(elems);\n    while (elems.length) {\n      toElem.appendChild(elems.shift());\n    }\n  }\n\n  // -------------------------- Flickity -------------------------- //\n\n  // globally unique identifiers\n  var GUID = 0;\n  // internal store of all Flickity intances\n  var instances = {};\n\n  function Flickity(element, options) {\n    var queryElement = utils.getQueryElement(element);\n    if (!queryElement) {\n      if (console) {\n        console.error('Bad element for Flickity: ' + (queryElement || element));\n      }\n      return;\n    }\n    this.element = queryElement;\n    // do not initialize twice on same element\n    if (this.element.flickityGUID) {\n      var instance = instances[this.element.flickityGUID];\n      instance.option(options);\n      return instance;\n    }\n\n    // add jQuery\n    if (jQuery) {\n      this.$element = jQuery(this.element);\n    }\n    // options\n    this.options = utils.extend({}, this.constructor.defaults);\n    this.option(options);\n\n    // kick things off\n    this._create();\n  }\n\n  Flickity.defaults = {\n    accessibility: true,\n    // adaptiveHeight: false,\n    cellAlign: 'center',\n    // cellSelector: undefined,\n    // contain: false,\n    freeScrollFriction: 0.075, // friction when free-scrolling\n    friction: 0.28, // friction when selecting\n    namespaceJQueryEvents: true,\n    // initialIndex: 0,\n    percentPosition: true,\n    resize: true,\n    selectedAttraction: 0.025,\n    setGallerySize: true\n    // watchCSS: false,\n    // wrapAround: false\n  };\n\n  // hash of methods triggered on _create()\n  Flickity.createMethods = [];\n\n  var proto = Flickity.prototype;\n  // inherit EventEmitter\n  utils.extend(proto, EvEmitter.prototype);\n\n  proto._create = function () {\n    // add id for Flickity.data\n    var id = this.guid = ++GUID;\n    this.element.flickityGUID = id; // expando\n    instances[id] = this; // associate via id\n    // initial properties\n    this.selectedIndex = 0;\n    // how many frames slider has been in same position\n    this.restingFrames = 0;\n    // initial physics properties\n    this.x = 0;\n    this.velocity = 0;\n    this.originSide = this.options.rightToLeft ? 'right' : 'left';\n    // create viewport & slider\n    this.viewport = document.createElement('div');\n    this.viewport.className = 'flickity-viewport';\n    this._createSlider();\n\n    if (this.options.resize || this.options.watchCSS) {\n      window.addEventListener('resize', this);\n    }\n\n    // add listeners from on option\n    for (var eventName in this.options.on) {\n      var listener = this.options.on[eventName];\n      this.on(eventName, listener);\n    }\n\n    Flickity.createMethods.forEach(function (method) {\n      this[method]();\n    }, this);\n\n    if (this.options.watchCSS) {\n      this.watchCSS();\n    } else {\n      this.activate();\n    }\n  };\n\n  /**\n   * set options\n   * @param {Object} opts\n   */\n  proto.option = function (opts) {\n    utils.extend(this.options, opts);\n  };\n\n  proto.activate = function () {\n    if (this.isActive) {\n      return;\n    }\n    this.isActive = true;\n    this.element.classList.add('flickity-enabled');\n    if (this.options.rightToLeft) {\n      this.element.classList.add('flickity-rtl');\n    }\n\n    this.getSize();\n    // move initial cell elements so they can be loaded as cells\n    var cellElems = this._filterFindCellElements(this.element.children);\n    moveElements(cellElems, this.slider);\n    this.viewport.appendChild(this.slider);\n    this.element.appendChild(this.viewport);\n    // get cells from children\n    this.reloadCells();\n\n    if (this.options.accessibility) {\n      // allow element to focusable\n      this.element.tabIndex = 0;\n      // listen for key presses\n      this.element.addEventListener('keydown', this);\n    }\n\n    this.emitEvent('activate');\n    this.selectInitialIndex();\n    // flag for initial activation, for using initialIndex\n    this.isInitActivated = true;\n    // ready event. #493\n    this.dispatchEvent('ready');\n  };\n\n  // slider positions the cells\n  proto._createSlider = function () {\n    // slider element does all the positioning\n    var slider = document.createElement('div');\n    slider.className = 'flickity-slider';\n    slider.style[this.originSide] = 0;\n    this.slider = slider;\n  };\n\n  proto._filterFindCellElements = function (elems) {\n    return utils.filterFindElements(elems, this.options.cellSelector);\n  };\n\n  // goes through all children\n  proto.reloadCells = function () {\n    // collection of item elements\n    this.cells = this._makeCells(this.slider.children);\n    this.positionCells();\n    this._getWrapShiftCells();\n    this.setGallerySize();\n  };\n\n  /**\n   * turn elements into Flickity.Cells\n   * @param {Array or NodeList or HTMLElement} elems\n   * @returns {Array} items - collection of new Flickity Cells\n   */\n  proto._makeCells = function (elems) {\n    var cellElems = this._filterFindCellElements(elems);\n\n    // create new Flickity for collection\n    var cells = cellElems.map(function (cellElem) {\n      return new Cell(cellElem, this);\n    }, this);\n\n    return cells;\n  };\n\n  proto.getLastCell = function () {\n    return this.cells[this.cells.length - 1];\n  };\n\n  proto.getLastSlide = function () {\n    return this.slides[this.slides.length - 1];\n  };\n\n  // positions all cells\n  proto.positionCells = function () {\n    // size all cells\n    this._sizeCells(this.cells);\n    // position all cells\n    this._positionCells(0);\n  };\n\n  /**\n   * position certain cells\n   * @param {Integer} index - which cell to start with\n   */\n  proto._positionCells = function (index) {\n    index = index || 0;\n    // also measure maxCellHeight\n    // start 0 if positioning all cells\n    this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;\n    var cellX = 0;\n    // get cellX\n    if (index > 0) {\n      var startCell = this.cells[index - 1];\n      cellX = startCell.x + startCell.size.outerWidth;\n    }\n    var len = this.cells.length;\n    for (var i = index; i < len; i++) {\n      var cell = this.cells[i];\n      cell.setPosition(cellX);\n      cellX += cell.size.outerWidth;\n      this.maxCellHeight = Math.max(cell.size.outerHeight, this.maxCellHeight);\n    }\n    // keep track of cellX for wrap-around\n    this.slideableWidth = cellX;\n    // slides\n    this.updateSlides();\n    // contain slides target\n    this._containSlides();\n    // update slidesWidth\n    this.slidesWidth = len ? this.getLastSlide().target - this.slides[0].target : 0;\n  };\n\n  /**\n   * cell.getSize() on multiple cells\n   * @param {Array} cells\n   */\n  proto._sizeCells = function (cells) {\n    cells.forEach(function (cell) {\n      cell.getSize();\n    });\n  };\n\n  // --------------------------  -------------------------- //\n\n  proto.updateSlides = function () {\n    this.slides = [];\n    if (!this.cells.length) {\n      return;\n    }\n\n    var slide = new Slide(this);\n    this.slides.push(slide);\n    var isOriginLeft = this.originSide == 'left';\n    var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';\n\n    var canCellFit = this._getCanCellFit();\n\n    this.cells.forEach(function (cell, i) {\n      // just add cell if first cell in slide\n      if (!slide.cells.length) {\n        slide.addCell(cell);\n        return;\n      }\n\n      var slideWidth = slide.outerWidth - slide.firstMargin + (cell.size.outerWidth - cell.size[nextMargin]);\n\n      if (canCellFit.call(this, i, slideWidth)) {\n        slide.addCell(cell);\n      } else {\n        // doesn't fit, new slide\n        slide.updateTarget();\n\n        slide = new Slide(this);\n        this.slides.push(slide);\n        slide.addCell(cell);\n      }\n    }, this);\n    // last slide\n    slide.updateTarget();\n    // update .selectedSlide\n    this.updateSelectedSlide();\n  };\n\n  proto._getCanCellFit = function () {\n    var groupCells = this.options.groupCells;\n    if (!groupCells) {\n      return function () {\n        return false;\n      };\n    } else if (typeof groupCells == 'number') {\n      // group by number. 3 -> [0,1,2], [3,4,5], ...\n      var number = parseInt(groupCells, 10);\n      return function (i) {\n        return i % number !== 0;\n      };\n    }\n    // default, group by width of slide\n    // parse '75%\n    var percentMatch = typeof groupCells == 'string' && groupCells.match(/^(\\d+)%$/);\n    var percent = percentMatch ? parseInt(percentMatch[1], 10) / 100 : 1;\n    return function (i, slideWidth) {\n      return slideWidth <= (this.size.innerWidth + 1) * percent;\n    };\n  };\n\n  // alias _init for jQuery plugin .flickity()\n  proto._init = proto.reposition = function () {\n    this.positionCells();\n    this.positionSliderAtSelected();\n  };\n\n  proto.getSize = function () {\n    this.size = getSize(this.element);\n    this.setCellAlign();\n    this.cursorPosition = this.size.innerWidth * this.cellAlign;\n  };\n\n  var cellAlignShorthands = {\n    // cell align, then based on origin side\n    center: {\n      left: 0.5,\n      right: 0.5\n    },\n    left: {\n      left: 0,\n      right: 1\n    },\n    right: {\n      right: 0,\n      left: 1\n    }\n  };\n\n  proto.setCellAlign = function () {\n    var shorthand = cellAlignShorthands[this.options.cellAlign];\n    this.cellAlign = shorthand ? shorthand[this.originSide] : this.options.cellAlign;\n  };\n\n  proto.setGallerySize = function () {\n    if (this.options.setGallerySize) {\n      var height = this.options.adaptiveHeight && this.selectedSlide ? this.selectedSlide.height : this.maxCellHeight;\n      this.viewport.style.height = height + 'px';\n    }\n  };\n\n  proto._getWrapShiftCells = function () {\n    // only for wrap-around\n    if (!this.options.wrapAround) {\n      return;\n    }\n    // unshift previous cells\n    this._unshiftCells(this.beforeShiftCells);\n    this._unshiftCells(this.afterShiftCells);\n    // get before cells\n    // initial gap\n    var gapX = this.cursorPosition;\n    var cellIndex = this.cells.length - 1;\n    this.beforeShiftCells = this._getGapCells(gapX, cellIndex, -1);\n    // get after cells\n    // ending gap between last cell and end of gallery viewport\n    gapX = this.size.innerWidth - this.cursorPosition;\n    // start cloning at first cell, working forwards\n    this.afterShiftCells = this._getGapCells(gapX, 0, 1);\n  };\n\n  proto._getGapCells = function (gapX, cellIndex, increment) {\n    // keep adding cells until the cover the initial gap\n    var cells = [];\n    while (gapX > 0) {\n      var cell = this.cells[cellIndex];\n      if (!cell) {\n        break;\n      }\n      cells.push(cell);\n      cellIndex += increment;\n      gapX -= cell.size.outerWidth;\n    }\n    return cells;\n  };\n\n  // ----- contain ----- //\n\n  // contain cell targets so no excess sliding\n  proto._containSlides = function () {\n    if (!this.options.contain || this.options.wrapAround || !this.cells.length) {\n      return;\n    }\n    var isRightToLeft = this.options.rightToLeft;\n    var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';\n    var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';\n    var contentWidth = this.slideableWidth - this.getLastCell().size[endMargin];\n    // content is less than gallery size\n    var isContentSmaller = contentWidth < this.size.innerWidth;\n    // bounds\n    var beginBound = this.cursorPosition + this.cells[0].size[beginMargin];\n    var endBound = contentWidth - this.size.innerWidth * (1 - this.cellAlign);\n    // contain each cell target\n    this.slides.forEach(function (slide) {\n      if (isContentSmaller) {\n        // all cells fit inside gallery\n        slide.target = contentWidth * this.cellAlign;\n      } else {\n        // contain to bounds\n        slide.target = Math.max(slide.target, beginBound);\n        slide.target = Math.min(slide.target, endBound);\n      }\n    }, this);\n  };\n\n  // -----  ----- //\n\n  /**\n   * emits events via eventEmitter and jQuery events\n   * @param {String} type - name of event\n   * @param {Event} event - original event\n   * @param {Array} args - extra arguments\n   */\n  proto.dispatchEvent = function (type, event, args) {\n    var emitArgs = event ? [event].concat(args) : args;\n    this.emitEvent(type, emitArgs);\n\n    if (jQuery && this.$element) {\n      // default trigger with type if no event\n      type += this.options.namespaceJQueryEvents ? '.flickity' : '';\n      var $event = type;\n      if (event) {\n        // create jQuery event\n        var jQEvent = jQuery.Event(event);\n        jQEvent.type = type;\n        $event = jQEvent;\n      }\n      this.$element.trigger($event, args);\n    }\n  };\n\n  // -------------------------- select -------------------------- //\n\n  /**\n   * @param {Integer} index - index of the slide\n   * @param {Boolean} isWrap - will wrap-around to last/first if at the end\n   * @param {Boolean} isInstant - will immediately set position at selected cell\n   */\n  proto.select = function (index, isWrap, isInstant) {\n    if (!this.isActive) {\n      return;\n    }\n    index = parseInt(index, 10);\n    this._wrapSelect(index);\n\n    if (this.options.wrapAround || isWrap) {\n      index = utils.modulo(index, this.slides.length);\n    }\n    // bail if invalid index\n    if (!this.slides[index]) {\n      return;\n    }\n    var prevIndex = this.selectedIndex;\n    this.selectedIndex = index;\n    this.updateSelectedSlide();\n    if (isInstant) {\n      this.positionSliderAtSelected();\n    } else {\n      this.startAnimation();\n    }\n    if (this.options.adaptiveHeight) {\n      this.setGallerySize();\n    }\n    // events\n    this.dispatchEvent('select', null, [index]);\n    // change event if new index\n    if (index != prevIndex) {\n      this.dispatchEvent('change', null, [index]);\n    }\n    // old v1 event name, remove in v3\n    this.dispatchEvent('cellSelect');\n  };\n\n  // wraps position for wrapAround, to move to closest slide. #113\n  proto._wrapSelect = function (index) {\n    var len = this.slides.length;\n    var isWrapping = this.options.wrapAround && len > 1;\n    if (!isWrapping) {\n      return index;\n    }\n    var wrapIndex = utils.modulo(index, len);\n    // go to shortest\n    var delta = Math.abs(wrapIndex - this.selectedIndex);\n    var backWrapDelta = Math.abs(wrapIndex + len - this.selectedIndex);\n    var forewardWrapDelta = Math.abs(wrapIndex - len - this.selectedIndex);\n    if (!this.isDragSelect && backWrapDelta < delta) {\n      index += len;\n    } else if (!this.isDragSelect && forewardWrapDelta < delta) {\n      index -= len;\n    }\n    // wrap position so slider is within normal area\n    if (index < 0) {\n      this.x -= this.slideableWidth;\n    } else if (index >= len) {\n      this.x += this.slideableWidth;\n    }\n  };\n\n  proto.previous = function (isWrap, isInstant) {\n    this.select(this.selectedIndex - 1, isWrap, isInstant);\n  };\n\n  proto.next = function (isWrap, isInstant) {\n    this.select(this.selectedIndex + 1, isWrap, isInstant);\n  };\n\n  proto.updateSelectedSlide = function () {\n    var slide = this.slides[this.selectedIndex];\n    // selectedIndex could be outside of slides, if triggered before resize()\n    if (!slide) {\n      return;\n    }\n    // unselect previous selected slide\n    this.unselectSelectedSlide();\n    // update new selected slide\n    this.selectedSlide = slide;\n    slide.select();\n    this.selectedCells = slide.cells;\n    this.selectedElements = slide.getCellElements();\n    // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility\n    // Remove in v3?\n    this.selectedCell = slide.cells[0];\n    this.selectedElement = this.selectedElements[0];\n  };\n\n  proto.unselectSelectedSlide = function () {\n    if (this.selectedSlide) {\n      this.selectedSlide.unselect();\n    }\n  };\n\n  proto.selectInitialIndex = function () {\n    var initialIndex = this.options.initialIndex;\n    // already activated, select previous selectedIndex\n    if (this.isInitActivated) {\n      this.select(this.selectedIndex, false, true);\n      return;\n    }\n    // select with selector string\n    if (initialIndex && typeof initialIndex == 'string') {\n      var cell = this.queryCell(initialIndex);\n      if (cell) {\n        this.selectCell(initialIndex, false, true);\n        return;\n      }\n    }\n\n    var index = 0;\n    // select with number\n    if (initialIndex && this.slides[initialIndex]) {\n      index = initialIndex;\n    }\n    // select instantly\n    this.select(index, false, true);\n  };\n\n  /**\n   * select slide from number or cell element\n   * @param {Element or Number} elem\n   */\n  proto.selectCell = function (value, isWrap, isInstant) {\n    // get cell\n    var cell = this.queryCell(value);\n    if (!cell) {\n      return;\n    }\n\n    var index = this.getCellSlideIndex(cell);\n    this.select(index, isWrap, isInstant);\n  };\n\n  proto.getCellSlideIndex = function (cell) {\n    // get index of slides that has cell\n    for (var i = 0; i < this.slides.length; i++) {\n      var slide = this.slides[i];\n      var index = slide.cells.indexOf(cell);\n      if (index != -1) {\n        return i;\n      }\n    }\n  };\n\n  // -------------------------- get cells -------------------------- //\n\n  /**\n   * get Flickity.Cell, given an Element\n   * @param {Element} elem\n   * @returns {Flickity.Cell} item\n   */\n  proto.getCell = function (elem) {\n    // loop through cells to get the one that matches\n    for (var i = 0; i < this.cells.length; i++) {\n      var cell = this.cells[i];\n      if (cell.element == elem) {\n        return cell;\n      }\n    }\n  };\n\n  /**\n   * get collection of Flickity.Cells, given Elements\n   * @param {Element, Array, NodeList} elems\n   * @returns {Array} cells - Flickity.Cells\n   */\n  proto.getCells = function (elems) {\n    elems = utils.makeArray(elems);\n    var cells = [];\n    elems.forEach(function (elem) {\n      var cell = this.getCell(elem);\n      if (cell) {\n        cells.push(cell);\n      }\n    }, this);\n    return cells;\n  };\n\n  /**\n   * get cell elements\n   * @returns {Array} cellElems\n   */\n  proto.getCellElements = function () {\n    return this.cells.map(function (cell) {\n      return cell.element;\n    });\n  };\n\n  /**\n   * get parent cell from an element\n   * @param {Element} elem\n   * @returns {Flickit.Cell} cell\n   */\n  proto.getParentCell = function (elem) {\n    // first check if elem is cell\n    var cell = this.getCell(elem);\n    if (cell) {\n      return cell;\n    }\n    // try to get parent cell elem\n    elem = utils.getParent(elem, '.flickity-slider > *');\n    return this.getCell(elem);\n  };\n\n  /**\n   * get cells adjacent to a slide\n   * @param {Integer} adjCount - number of adjacent slides\n   * @param {Integer} index - index of slide to start\n   * @returns {Array} cells - array of Flickity.Cells\n   */\n  proto.getAdjacentCellElements = function (adjCount, index) {\n    if (!adjCount) {\n      return this.selectedSlide.getCellElements();\n    }\n    index = index === undefined ? this.selectedIndex : index;\n\n    var len = this.slides.length;\n    if (1 + adjCount * 2 >= len) {\n      return this.getCellElements();\n    }\n\n    var cellElems = [];\n    for (var i = index - adjCount; i <= index + adjCount; i++) {\n      var slideIndex = this.options.wrapAround ? utils.modulo(i, len) : i;\n      var slide = this.slides[slideIndex];\n      if (slide) {\n        cellElems = cellElems.concat(slide.getCellElements());\n      }\n    }\n    return cellElems;\n  };\n\n  /**\n   * select slide from number or cell element\n   * @param {Element, Selector String, or Number} selector\n   */\n  proto.queryCell = function (selector) {\n    if (typeof selector == 'number') {\n      // use number as index\n      return this.cells[selector];\n    }\n    if (typeof selector == 'string') {\n      // do not select invalid selectors from hash: #123, #/. #791\n      if (selector.match(/^[#\\.]?[\\d\\/]/)) {\n        return;\n      }\n      // use string as selector, get element\n      selector = this.element.querySelector(selector);\n    }\n    // get cell from element\n    return this.getCell(selector);\n  };\n\n  // -------------------------- events -------------------------- //\n\n  proto.uiChange = function () {\n    this.emitEvent('uiChange');\n  };\n\n  // keep focus on element when child UI elements are clicked\n  proto.childUIPointerDown = function (event) {\n    // HACK iOS does not allow touch events to bubble up?!\n    if (event.type != 'touchstart') {\n      event.preventDefault();\n    }\n    this.focus();\n  };\n\n  // ----- resize ----- //\n\n  proto.onresize = function () {\n    this.watchCSS();\n    this.resize();\n  };\n\n  utils.debounceMethod(Flickity, 'onresize', 150);\n\n  proto.resize = function () {\n    if (!this.isActive) {\n      return;\n    }\n    this.getSize();\n    // wrap values\n    if (this.options.wrapAround) {\n      this.x = utils.modulo(this.x, this.slideableWidth);\n    }\n    this.positionCells();\n    this._getWrapShiftCells();\n    this.setGallerySize();\n    this.emitEvent('resize');\n    // update selected index for group slides, instant\n    // TODO: position can be lost between groups of various numbers\n    var selectedElement = this.selectedElements && this.selectedElements[0];\n    this.selectCell(selectedElement, false, true);\n  };\n\n  // watches the :after property, activates/deactivates\n  proto.watchCSS = function () {\n    var watchOption = this.options.watchCSS;\n    if (!watchOption) {\n      return;\n    }\n\n    var afterContent = getComputedStyle(this.element, ':after').content;\n    // activate if :after { content: 'flickity' }\n    if (afterContent.indexOf('flickity') != -1) {\n      this.activate();\n    } else {\n      this.deactivate();\n    }\n  };\n\n  // ----- keydown ----- //\n\n  // go previous/next if left/right keys pressed\n  proto.onkeydown = function (event) {\n    // only work if element is in focus\n    var isNotFocused = document.activeElement && document.activeElement != this.element;\n    if (!this.options.accessibility || isNotFocused) {\n      return;\n    }\n\n    var handler = Flickity.keyboardHandlers[event.keyCode];\n    if (handler) {\n      handler.call(this);\n    }\n  };\n\n  Flickity.keyboardHandlers = {\n    // left arrow\n    37: function () {\n      var leftMethod = this.options.rightToLeft ? 'next' : 'previous';\n      this.uiChange();\n      this[leftMethod]();\n    },\n    // right arrow\n    39: function () {\n      var rightMethod = this.options.rightToLeft ? 'previous' : 'next';\n      this.uiChange();\n      this[rightMethod]();\n    }\n  };\n\n  // ----- focus ----- //\n\n  proto.focus = function () {\n    // TODO remove scrollTo once focus options gets more support\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#Browser_compatibility\n    var prevScrollY = window.pageYOffset;\n    this.element.focus({ preventScroll: true });\n    // hack to fix scroll jump after focus, #76\n    if (window.pageYOffset != prevScrollY) {\n      window.scrollTo(window.pageXOffset, prevScrollY);\n    }\n  };\n\n  // -------------------------- destroy -------------------------- //\n\n  // deactivate all Flickity functionality, but keep stuff available\n  proto.deactivate = function () {\n    if (!this.isActive) {\n      return;\n    }\n    this.element.classList.remove('flickity-enabled');\n    this.element.classList.remove('flickity-rtl');\n    this.unselectSelectedSlide();\n    // destroy cells\n    this.cells.forEach(function (cell) {\n      cell.destroy();\n    });\n    this.element.removeChild(this.viewport);\n    // move child elements back into element\n    moveElements(this.slider.children, this.element);\n    if (this.options.accessibility) {\n      this.element.removeAttribute('tabIndex');\n      this.element.removeEventListener('keydown', this);\n    }\n    // set flags\n    this.isActive = false;\n    this.emitEvent('deactivate');\n  };\n\n  proto.destroy = function () {\n    this.deactivate();\n    window.removeEventListener('resize', this);\n    this.allOff();\n    this.emitEvent('destroy');\n    if (jQuery && this.$element) {\n      jQuery.removeData(this.element, 'flickity');\n    }\n    delete this.element.flickityGUID;\n    delete instances[this.guid];\n  };\n\n  // -------------------------- prototype -------------------------- //\n\n  utils.extend(proto, animatePrototype);\n\n  // -------------------------- extras -------------------------- //\n\n  /**\n   * get Flickity instance from element\n   * @param {Element} elem\n   * @returns {Flickity}\n   */\n  Flickity.data = function (elem) {\n    elem = utils.getQueryElement(elem);\n    var id = elem && elem.flickityGUID;\n    return id && instances[id];\n  };\n\n  utils.htmlInit(Flickity, 'flickity');\n\n  if (jQuery && jQuery.bridget) {\n    jQuery.bridget('flickity', Flickity);\n  }\n\n  // set internal jQuery, for Webpack + jQuery v3, #478\n  Flickity.setJQuery = function (jq) {\n    jQuery = jq;\n  };\n\n  Flickity.Cell = Cell;\n  Flickity.Slide = Slide;\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/flickity.js?");

/***/ }),

/***/ "./node_modules/flickity/js/index.js":
/*!*******************************************!*\
  !*** ./node_modules/flickity/js/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Flickity v2.2.1\n * Touch, responsive, flickable carousels\n *\n * Licensed GPLv3 for open source use\n * or Flickity Commercial License for commercial use\n *\n * https://flickity.metafizzy.co\n * Copyright 2015-2019 Metafizzy\n */\n\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! ./drag */ \"./node_modules/flickity/js/drag.js\"), __webpack_require__(/*! ./prev-next-button */ \"./node_modules/flickity/js/prev-next-button.js\"), __webpack_require__(/*! ./page-dots */ \"./node_modules/flickity/js/page-dots.js\"), __webpack_require__(/*! ./player */ \"./node_modules/flickity/js/player.js\"), __webpack_require__(/*! ./add-remove-cell */ \"./node_modules/flickity/js/add-remove-cell.js\"), __webpack_require__(/*! ./lazyload */ \"./node_modules/flickity/js/lazyload.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(Flickity) {\n  /*jshint strict: false*/\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/index.js?");

/***/ }),

/***/ "./node_modules/flickity/js/lazyload.js":
/*!**********************************************!*\
  !*** ./node_modules/flickity/js/lazyload.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// lazyload\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Flickity, utils) {\n      return factory(window, Flickity, utils);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, Flickity, utils) {\n  'use strict';\n\n  Flickity.createMethods.push('_createLazyload');\n  var proto = Flickity.prototype;\n\n  proto._createLazyload = function () {\n    this.on('select', this.lazyLoad);\n  };\n\n  proto.lazyLoad = function () {\n    var lazyLoad = this.options.lazyLoad;\n    if (!lazyLoad) {\n      return;\n    }\n    // get adjacent cells, use lazyLoad option for adjacent count\n    var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;\n    var cellElems = this.getAdjacentCellElements(adjCount);\n    // get lazy images in those cells\n    var lazyImages = [];\n    cellElems.forEach(function (cellElem) {\n      var lazyCellImages = getCellLazyImages(cellElem);\n      lazyImages = lazyImages.concat(lazyCellImages);\n    });\n    // load lazy images\n    lazyImages.forEach(function (img) {\n      new LazyLoader(img, this);\n    }, this);\n  };\n\n  function getCellLazyImages(cellElem) {\n    // check if cell element is lazy image\n    if (cellElem.nodeName == 'IMG') {\n      var lazyloadAttr = cellElem.getAttribute('data-flickity-lazyload');\n      var srcAttr = cellElem.getAttribute('data-flickity-lazyload-src');\n      var srcsetAttr = cellElem.getAttribute('data-flickity-lazyload-srcset');\n      if (lazyloadAttr || srcAttr || srcsetAttr) {\n        return [cellElem];\n      }\n    }\n    // select lazy images in cell\n    var lazySelector = 'img[data-flickity-lazyload], ' + 'img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]';\n    var imgs = cellElem.querySelectorAll(lazySelector);\n    return utils.makeArray(imgs);\n  }\n\n  // -------------------------- LazyLoader -------------------------- //\n\n  /**\n   * class to handle loading images\n   */\n  function LazyLoader(img, flickity) {\n    this.img = img;\n    this.flickity = flickity;\n    this.load();\n  }\n\n  LazyLoader.prototype.handleEvent = utils.handleEvent;\n\n  LazyLoader.prototype.load = function () {\n    this.img.addEventListener('load', this);\n    this.img.addEventListener('error', this);\n    // get src & srcset\n    var src = this.img.getAttribute('data-flickity-lazyload') || this.img.getAttribute('data-flickity-lazyload-src');\n    var srcset = this.img.getAttribute('data-flickity-lazyload-srcset');\n    // set src & serset\n    this.img.src = src;\n    if (srcset) {\n      this.img.setAttribute('srcset', srcset);\n    }\n    // remove attr\n    this.img.removeAttribute('data-flickity-lazyload');\n    this.img.removeAttribute('data-flickity-lazyload-src');\n    this.img.removeAttribute('data-flickity-lazyload-srcset');\n  };\n\n  LazyLoader.prototype.onload = function (event) {\n    this.complete(event, 'flickity-lazyloaded');\n  };\n\n  LazyLoader.prototype.onerror = function (event) {\n    this.complete(event, 'flickity-lazyerror');\n  };\n\n  LazyLoader.prototype.complete = function (event, className) {\n    // unbind events\n    this.img.removeEventListener('load', this);\n    this.img.removeEventListener('error', this);\n\n    var cell = this.flickity.getParentCell(this.img);\n    var cellElem = cell && cell.element;\n    this.flickity.cellSizeChange(cellElem);\n\n    this.img.classList.add(className);\n    this.flickity.dispatchEvent('lazyLoad', event, cellElem);\n  };\n\n  // -----  ----- //\n\n  Flickity.LazyLoader = LazyLoader;\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/lazyload.js?");

/***/ }),

/***/ "./node_modules/flickity/js/page-dots.js":
/*!***********************************************!*\
  !*** ./node_modules/flickity/js/page-dots.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// page dots\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! unipointer/unipointer */ \"./node_modules/unipointer/unipointer.js\"), __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Flickity, Unipointer, utils) {\n      return factory(window, Flickity, Unipointer, utils);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, Flickity, Unipointer, utils) {\n\n  // -------------------------- PageDots -------------------------- //\n\n  'use strict';\n\n  function PageDots(parent) {\n    this.parent = parent;\n    this._create();\n  }\n\n  PageDots.prototype = Object.create(Unipointer.prototype);\n\n  PageDots.prototype._create = function () {\n    // create holder element\n    this.holder = document.createElement('ol');\n    this.holder.className = 'flickity-page-dots';\n    // create dots, array of elements\n    this.dots = [];\n    // events\n    this.handleClick = this.onClick.bind(this);\n    this.on('pointerDown', this.parent.childUIPointerDown.bind(this.parent));\n  };\n\n  PageDots.prototype.activate = function () {\n    this.setDots();\n    this.holder.addEventListener('click', this.handleClick);\n    this.bindStartEvent(this.holder);\n    // add to DOM\n    this.parent.element.appendChild(this.holder);\n  };\n\n  PageDots.prototype.deactivate = function () {\n    this.holder.removeEventListener('click', this.handleClick);\n    this.unbindStartEvent(this.holder);\n    // remove from DOM\n    this.parent.element.removeChild(this.holder);\n  };\n\n  PageDots.prototype.setDots = function () {\n    // get difference between number of slides and number of dots\n    var delta = this.parent.slides.length - this.dots.length;\n    if (delta > 0) {\n      this.addDots(delta);\n    } else if (delta < 0) {\n      this.removeDots(-delta);\n    }\n  };\n\n  PageDots.prototype.addDots = function (count) {\n    var fragment = document.createDocumentFragment();\n    var newDots = [];\n    var length = this.dots.length;\n    var max = length + count;\n\n    for (var i = length; i < max; i++) {\n      var dot = document.createElement('li');\n      dot.className = 'dot';\n      dot.setAttribute('aria-label', 'Page dot ' + (i + 1));\n      fragment.appendChild(dot);\n      newDots.push(dot);\n    }\n\n    this.holder.appendChild(fragment);\n    this.dots = this.dots.concat(newDots);\n  };\n\n  PageDots.prototype.removeDots = function (count) {\n    // remove from this.dots collection\n    var removeDots = this.dots.splice(this.dots.length - count, count);\n    // remove from DOM\n    removeDots.forEach(function (dot) {\n      this.holder.removeChild(dot);\n    }, this);\n  };\n\n  PageDots.prototype.updateSelected = function () {\n    // remove selected class on previous\n    if (this.selectedDot) {\n      this.selectedDot.className = 'dot';\n      this.selectedDot.removeAttribute('aria-current');\n    }\n    // don't proceed if no dots\n    if (!this.dots.length) {\n      return;\n    }\n    this.selectedDot = this.dots[this.parent.selectedIndex];\n    this.selectedDot.className = 'dot is-selected';\n    this.selectedDot.setAttribute('aria-current', 'step');\n  };\n\n  PageDots.prototype.onTap = // old method name, backwards-compatible\n  PageDots.prototype.onClick = function (event) {\n    var target = event.target;\n    // only care about dot clicks\n    if (target.nodeName != 'LI') {\n      return;\n    }\n\n    this.parent.uiChange();\n    var index = this.dots.indexOf(target);\n    this.parent.select(index);\n  };\n\n  PageDots.prototype.destroy = function () {\n    this.deactivate();\n    this.allOff();\n  };\n\n  Flickity.PageDots = PageDots;\n\n  // -------------------------- Flickity -------------------------- //\n\n  utils.extend(Flickity.defaults, {\n    pageDots: true\n  });\n\n  Flickity.createMethods.push('_createPageDots');\n\n  var proto = Flickity.prototype;\n\n  proto._createPageDots = function () {\n    if (!this.options.pageDots) {\n      return;\n    }\n    this.pageDots = new PageDots(this);\n    // events\n    this.on('activate', this.activatePageDots);\n    this.on('select', this.updateSelectedPageDots);\n    this.on('cellChange', this.updatePageDots);\n    this.on('resize', this.updatePageDots);\n    this.on('deactivate', this.deactivatePageDots);\n  };\n\n  proto.activatePageDots = function () {\n    this.pageDots.activate();\n  };\n\n  proto.updateSelectedPageDots = function () {\n    this.pageDots.updateSelected();\n  };\n\n  proto.updatePageDots = function () {\n    this.pageDots.setDots();\n  };\n\n  proto.deactivatePageDots = function () {\n    this.pageDots.deactivate();\n  };\n\n  // -----  ----- //\n\n  Flickity.PageDots = PageDots;\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/page-dots.js?");

/***/ }),

/***/ "./node_modules/flickity/js/player.js":
/*!********************************************!*\
  !*** ./node_modules/flickity/js/player.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// player & autoPlay\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ev-emitter/ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\"), __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\"), __webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (EvEmitter, utils, Flickity) {\n      return factory(EvEmitter, utils, Flickity);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(EvEmitter, utils, Flickity) {\n\n  'use strict';\n\n  // -------------------------- Player -------------------------- //\n\n  function Player(parent) {\n    this.parent = parent;\n    this.state = 'stopped';\n    // visibility change event handler\n    this.onVisibilityChange = this.visibilityChange.bind(this);\n    this.onVisibilityPlay = this.visibilityPlay.bind(this);\n  }\n\n  Player.prototype = Object.create(EvEmitter.prototype);\n\n  // start play\n  Player.prototype.play = function () {\n    if (this.state == 'playing') {\n      return;\n    }\n    // do not play if page is hidden, start playing when page is visible\n    var isPageHidden = document.hidden;\n    if (isPageHidden) {\n      document.addEventListener('visibilitychange', this.onVisibilityPlay);\n      return;\n    }\n\n    this.state = 'playing';\n    // listen to visibility change\n    document.addEventListener('visibilitychange', this.onVisibilityChange);\n    // start ticking\n    this.tick();\n  };\n\n  Player.prototype.tick = function () {\n    // do not tick if not playing\n    if (this.state != 'playing') {\n      return;\n    }\n\n    var time = this.parent.options.autoPlay;\n    // default to 3 seconds\n    time = typeof time == 'number' ? time : 3000;\n    var _this = this;\n    // HACK: reset ticks if stopped and started within interval\n    this.clear();\n    this.timeout = setTimeout(function () {\n      _this.parent.next(true);\n      _this.tick();\n    }, time);\n  };\n\n  Player.prototype.stop = function () {\n    this.state = 'stopped';\n    this.clear();\n    // remove visibility change event\n    document.removeEventListener('visibilitychange', this.onVisibilityChange);\n  };\n\n  Player.prototype.clear = function () {\n    clearTimeout(this.timeout);\n  };\n\n  Player.prototype.pause = function () {\n    if (this.state == 'playing') {\n      this.state = 'paused';\n      this.clear();\n    }\n  };\n\n  Player.prototype.unpause = function () {\n    // re-start play if paused\n    if (this.state == 'paused') {\n      this.play();\n    }\n  };\n\n  // pause if page visibility is hidden, unpause if visible\n  Player.prototype.visibilityChange = function () {\n    var isPageHidden = document.hidden;\n    this[isPageHidden ? 'pause' : 'unpause']();\n  };\n\n  Player.prototype.visibilityPlay = function () {\n    this.play();\n    document.removeEventListener('visibilitychange', this.onVisibilityPlay);\n  };\n\n  // -------------------------- Flickity -------------------------- //\n\n  utils.extend(Flickity.defaults, {\n    pauseAutoPlayOnHover: true\n  });\n\n  Flickity.createMethods.push('_createPlayer');\n  var proto = Flickity.prototype;\n\n  proto._createPlayer = function () {\n    this.player = new Player(this);\n\n    this.on('activate', this.activatePlayer);\n    this.on('uiChange', this.stopPlayer);\n    this.on('pointerDown', this.stopPlayer);\n    this.on('deactivate', this.deactivatePlayer);\n  };\n\n  proto.activatePlayer = function () {\n    if (!this.options.autoPlay) {\n      return;\n    }\n    this.player.play();\n    this.element.addEventListener('mouseenter', this);\n  };\n\n  // Player API, don't hate the ... thanks I know where the door is\n\n  proto.playPlayer = function () {\n    this.player.play();\n  };\n\n  proto.stopPlayer = function () {\n    this.player.stop();\n  };\n\n  proto.pausePlayer = function () {\n    this.player.pause();\n  };\n\n  proto.unpausePlayer = function () {\n    this.player.unpause();\n  };\n\n  proto.deactivatePlayer = function () {\n    this.player.stop();\n    this.element.removeEventListener('mouseenter', this);\n  };\n\n  // ----- mouseenter/leave ----- //\n\n  // pause auto-play on hover\n  proto.onmouseenter = function () {\n    if (!this.options.pauseAutoPlayOnHover) {\n      return;\n    }\n    this.player.pause();\n    this.element.addEventListener('mouseleave', this);\n  };\n\n  // resume auto-play on hover off\n  proto.onmouseleave = function () {\n    this.player.unpause();\n    this.element.removeEventListener('mouseleave', this);\n  };\n\n  // -----  ----- //\n\n  Flickity.Player = Player;\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/player.js?");

/***/ }),

/***/ "./node_modules/flickity/js/prev-next-button.js":
/*!******************************************************!*\
  !*** ./node_modules/flickity/js/prev-next-button.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// prev/next buttons\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./flickity */ \"./node_modules/flickity/js/flickity.js\"), __webpack_require__(/*! unipointer/unipointer */ \"./node_modules/unipointer/unipointer.js\"), __webpack_require__(/*! fizzy-ui-utils/utils */ \"./node_modules/fizzy-ui-utils/utils.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Flickity, Unipointer, utils) {\n      return factory(window, Flickity, Unipointer, utils);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, Flickity, Unipointer, utils) {\n  'use strict';\n\n  var svgURI = 'http://www.w3.org/2000/svg';\n\n  // -------------------------- PrevNextButton -------------------------- //\n\n  function PrevNextButton(direction, parent) {\n    this.direction = direction;\n    this.parent = parent;\n    this._create();\n  }\n\n  PrevNextButton.prototype = Object.create(Unipointer.prototype);\n\n  PrevNextButton.prototype._create = function () {\n    // properties\n    this.isEnabled = true;\n    this.isPrevious = this.direction == -1;\n    var leftDirection = this.parent.options.rightToLeft ? 1 : -1;\n    this.isLeft = this.direction == leftDirection;\n\n    var element = this.element = document.createElement('button');\n    element.className = 'flickity-button flickity-prev-next-button';\n    element.className += this.isPrevious ? ' previous' : ' next';\n    // prevent button from submitting form http://stackoverflow.com/a/10836076/182183\n    element.setAttribute('type', 'button');\n    // init as disabled\n    this.disable();\n\n    element.setAttribute('aria-label', this.isPrevious ? 'Previous' : 'Next');\n\n    // create arrow\n    var svg = this.createSVG();\n    element.appendChild(svg);\n    // events\n    this.parent.on('select', this.update.bind(this));\n    this.on('pointerDown', this.parent.childUIPointerDown.bind(this.parent));\n  };\n\n  PrevNextButton.prototype.activate = function () {\n    this.bindStartEvent(this.element);\n    this.element.addEventListener('click', this);\n    // add to DOM\n    this.parent.element.appendChild(this.element);\n  };\n\n  PrevNextButton.prototype.deactivate = function () {\n    // remove from DOM\n    this.parent.element.removeChild(this.element);\n    // click events\n    this.unbindStartEvent(this.element);\n    this.element.removeEventListener('click', this);\n  };\n\n  PrevNextButton.prototype.createSVG = function () {\n    var svg = document.createElementNS(svgURI, 'svg');\n    svg.setAttribute('class', 'flickity-button-icon');\n    svg.setAttribute('viewBox', '0 0 100 100');\n    var path = document.createElementNS(svgURI, 'path');\n    var pathMovements = getArrowMovements(this.parent.options.arrowShape);\n    path.setAttribute('d', pathMovements);\n    path.setAttribute('class', 'arrow');\n    // rotate arrow\n    if (!this.isLeft) {\n      path.setAttribute('transform', 'translate(100, 100) rotate(180) ');\n    }\n    svg.appendChild(path);\n    return svg;\n  };\n\n  // get SVG path movmement\n  function getArrowMovements(shape) {\n    // use shape as movement if string\n    if (typeof shape == 'string') {\n      return shape;\n    }\n    // create movement string\n    return 'M ' + shape.x0 + ',50' + ' L ' + shape.x1 + ',' + (shape.y1 + 50) + ' L ' + shape.x2 + ',' + (shape.y2 + 50) + ' L ' + shape.x3 + ',50 ' + ' L ' + shape.x2 + ',' + (50 - shape.y2) + ' L ' + shape.x1 + ',' + (50 - shape.y1) + ' Z';\n  }\n\n  PrevNextButton.prototype.handleEvent = utils.handleEvent;\n\n  PrevNextButton.prototype.onclick = function () {\n    if (!this.isEnabled) {\n      return;\n    }\n    this.parent.uiChange();\n    var method = this.isPrevious ? 'previous' : 'next';\n    this.parent[method]();\n  };\n\n  // -----  ----- //\n\n  PrevNextButton.prototype.enable = function () {\n    if (this.isEnabled) {\n      return;\n    }\n    this.element.disabled = false;\n    this.isEnabled = true;\n  };\n\n  PrevNextButton.prototype.disable = function () {\n    if (!this.isEnabled) {\n      return;\n    }\n    this.element.disabled = true;\n    this.isEnabled = false;\n  };\n\n  PrevNextButton.prototype.update = function () {\n    // index of first or last slide, if previous or next\n    var slides = this.parent.slides;\n    // enable is wrapAround and at least 2 slides\n    if (this.parent.options.wrapAround && slides.length > 1) {\n      this.enable();\n      return;\n    }\n    var lastIndex = slides.length ? slides.length - 1 : 0;\n    var boundIndex = this.isPrevious ? 0 : lastIndex;\n    var method = this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';\n    this[method]();\n  };\n\n  PrevNextButton.prototype.destroy = function () {\n    this.deactivate();\n    this.allOff();\n  };\n\n  // -------------------------- Flickity prototype -------------------------- //\n\n  utils.extend(Flickity.defaults, {\n    prevNextButtons: true,\n    arrowShape: {\n      x0: 10,\n      x1: 60, y1: 50,\n      x2: 70, y2: 40,\n      x3: 30\n    }\n  });\n\n  Flickity.createMethods.push('_createPrevNextButtons');\n  var proto = Flickity.prototype;\n\n  proto._createPrevNextButtons = function () {\n    if (!this.options.prevNextButtons) {\n      return;\n    }\n\n    this.prevButton = new PrevNextButton(-1, this);\n    this.nextButton = new PrevNextButton(1, this);\n\n    this.on('activate', this.activatePrevNextButtons);\n  };\n\n  proto.activatePrevNextButtons = function () {\n    this.prevButton.activate();\n    this.nextButton.activate();\n    this.on('deactivate', this.deactivatePrevNextButtons);\n  };\n\n  proto.deactivatePrevNextButtons = function () {\n    this.prevButton.deactivate();\n    this.nextButton.deactivate();\n    this.off('deactivate', this.deactivatePrevNextButtons);\n  };\n\n  // --------------------------  -------------------------- //\n\n  Flickity.PrevNextButton = PrevNextButton;\n\n  return Flickity;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/prev-next-button.js?");

/***/ }),

/***/ "./node_modules/flickity/js/slide.js":
/*!*******************************************!*\
  !*** ./node_modules/flickity/js/slide.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// slide\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory() {\n  'use strict';\n\n  function Slide(parent) {\n    this.parent = parent;\n    this.isOriginLeft = parent.originSide == 'left';\n    this.cells = [];\n    this.outerWidth = 0;\n    this.height = 0;\n  }\n\n  var proto = Slide.prototype;\n\n  proto.addCell = function (cell) {\n    this.cells.push(cell);\n    this.outerWidth += cell.size.outerWidth;\n    this.height = Math.max(cell.size.outerHeight, this.height);\n    // first cell stuff\n    if (this.cells.length == 1) {\n      this.x = cell.x; // x comes from first cell\n      var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';\n      this.firstMargin = cell.size[beginMargin];\n    }\n  };\n\n  proto.updateTarget = function () {\n    var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';\n    var lastCell = this.getLastCell();\n    var lastMargin = lastCell ? lastCell.size[endMargin] : 0;\n    var slideWidth = this.outerWidth - (this.firstMargin + lastMargin);\n    this.target = this.x + this.firstMargin + slideWidth * this.parent.cellAlign;\n  };\n\n  proto.getLastCell = function () {\n    return this.cells[this.cells.length - 1];\n  };\n\n  proto.select = function () {\n    this.cells.forEach(function (cell) {\n      cell.select();\n    });\n  };\n\n  proto.unselect = function () {\n    this.cells.forEach(function (cell) {\n      cell.unselect();\n    });\n  };\n\n  proto.getCellElements = function () {\n    return this.cells.map(function (cell) {\n      return cell.element;\n    });\n  };\n\n  return Slide;\n});\n\n//# sourceURL=webpack:///./node_modules/flickity/js/slide.js?");

/***/ }),

/***/ "./node_modules/get-size/get-size.js":
/*!*******************************************!*\
  !*** ./node_modules/get-size/get-size.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * getSize v2.0.3\n * measure size of elements\n * MIT license\n */\n\n/* jshint browser: true, strict: true, undef: true, unused: true */\n/* globals console: false */\n\n(function (window, factory) {\n  /* jshint strict: false */ /* globals define, module */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory() {\n  'use strict';\n\n  // -------------------------- helpers -------------------------- //\n\n  // get a number from a string, not a percentage\n\n  function getStyleSize(value) {\n    var num = parseFloat(value);\n    // not a percent like '100%', and a number\n    var isValid = value.indexOf('%') == -1 && !isNaN(num);\n    return isValid && num;\n  }\n\n  function noop() {}\n\n  var logError = typeof console == 'undefined' ? noop : function (message) {\n    console.error(message);\n  };\n\n  // -------------------------- measurements -------------------------- //\n\n  var measurements = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth'];\n\n  var measurementsLength = measurements.length;\n\n  function getZeroSize() {\n    var size = {\n      width: 0,\n      height: 0,\n      innerWidth: 0,\n      innerHeight: 0,\n      outerWidth: 0,\n      outerHeight: 0\n    };\n    for (var i = 0; i < measurementsLength; i++) {\n      var measurement = measurements[i];\n      size[measurement] = 0;\n    }\n    return size;\n  }\n\n  // -------------------------- getStyle -------------------------- //\n\n  /**\n   * getStyle, get style of element, check for Firefox bug\n   * https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n   */\n  function getStyle(elem) {\n    var style = getComputedStyle(elem);\n    if (!style) {\n      logError('Style returned ' + style + '. Are you running this code in a hidden iframe on Firefox? ' + 'See https://bit.ly/getsizebug1');\n    }\n    return style;\n  }\n\n  // -------------------------- setup -------------------------- //\n\n  var isSetup = false;\n\n  var isBoxSizeOuter;\n\n  /**\n   * setup\n   * check isBoxSizerOuter\n   * do on first getSize() rather than on page load for Firefox bug\n   */\n  function setup() {\n    // setup once\n    if (isSetup) {\n      return;\n    }\n    isSetup = true;\n\n    // -------------------------- box sizing -------------------------- //\n\n    /**\n     * Chrome & Safari measure the outer-width on style.width on border-box elems\n     * IE11 & Firefox<29 measures the inner-width\n     */\n    var div = document.createElement('div');\n    div.style.width = '200px';\n    div.style.padding = '1px 2px 3px 4px';\n    div.style.borderStyle = 'solid';\n    div.style.borderWidth = '1px 2px 3px 4px';\n    div.style.boxSizing = 'border-box';\n\n    var body = document.body || document.documentElement;\n    body.appendChild(div);\n    var style = getStyle(div);\n    // round value for browser zoom. desandro/masonry#928\n    isBoxSizeOuter = Math.round(getStyleSize(style.width)) == 200;\n    getSize.isBoxSizeOuter = isBoxSizeOuter;\n\n    body.removeChild(div);\n  }\n\n  // -------------------------- getSize -------------------------- //\n\n  function getSize(elem) {\n    setup();\n\n    // use querySeletor if elem is string\n    if (typeof elem == 'string') {\n      elem = document.querySelector(elem);\n    }\n\n    // do not proceed on non-objects\n    if (!elem || typeof elem != 'object' || !elem.nodeType) {\n      return;\n    }\n\n    var style = getStyle(elem);\n\n    // if hidden, everything is 0\n    if (style.display == 'none') {\n      return getZeroSize();\n    }\n\n    var size = {};\n    size.width = elem.offsetWidth;\n    size.height = elem.offsetHeight;\n\n    var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';\n\n    // get all measurements\n    for (var i = 0; i < measurementsLength; i++) {\n      var measurement = measurements[i];\n      var value = style[measurement];\n      var num = parseFloat(value);\n      // any 'auto', 'medium' value will be 0\n      size[measurement] = !isNaN(num) ? num : 0;\n    }\n\n    var paddingWidth = size.paddingLeft + size.paddingRight;\n    var paddingHeight = size.paddingTop + size.paddingBottom;\n    var marginWidth = size.marginLeft + size.marginRight;\n    var marginHeight = size.marginTop + size.marginBottom;\n    var borderWidth = size.borderLeftWidth + size.borderRightWidth;\n    var borderHeight = size.borderTopWidth + size.borderBottomWidth;\n\n    var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;\n\n    // overwrite width and height if we can get it from style\n    var styleWidth = getStyleSize(style.width);\n    if (styleWidth !== false) {\n      size.width = styleWidth + (\n      // add padding and border unless it's already including it\n      isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);\n    }\n\n    var styleHeight = getStyleSize(style.height);\n    if (styleHeight !== false) {\n      size.height = styleHeight + (\n      // add padding and border unless it's already including it\n      isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);\n    }\n\n    size.innerWidth = size.width - (paddingWidth + borderWidth);\n    size.innerHeight = size.height - (paddingHeight + borderHeight);\n\n    size.outerWidth = size.width + marginWidth;\n    size.outerHeight = size.height + marginHeight;\n\n    return size;\n  }\n\n  return getSize;\n});\n\n//# sourceURL=webpack:///./node_modules/get-size/get-size.js?");

/***/ }),

/***/ "./node_modules/unidragger/unidragger.js":
/*!***********************************************!*\
  !*** ./node_modules/unidragger/unidragger.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unidragger v2.3.0\n * Draggable base class\n * MIT license\n */\n\n/*jshint browser: true, unused: true, undef: true, strict: true */\n\n(function (window, factory) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! unipointer/unipointer */ \"./node_modules/unipointer/unipointer.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Unipointer) {\n      return factory(window, Unipointer);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, Unipointer) {\n\n  'use strict';\n\n  // -------------------------- Unidragger -------------------------- //\n\n  function Unidragger() {}\n\n  // inherit Unipointer & EvEmitter\n  var proto = Unidragger.prototype = Object.create(Unipointer.prototype);\n\n  // ----- bind start ----- //\n\n  proto.bindHandles = function () {\n    this._bindHandles(true);\n  };\n\n  proto.unbindHandles = function () {\n    this._bindHandles(false);\n  };\n\n  /**\n   * Add or remove start event\n   * @param {Boolean} isAdd\n   */\n  proto._bindHandles = function (isAdd) {\n    // munge isAdd, default to true\n    isAdd = isAdd === undefined ? true : isAdd;\n    // bind each handle\n    var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n    var touchAction = isAdd ? this._touchActionValue : '';\n    for (var i = 0; i < this.handles.length; i++) {\n      var handle = this.handles[i];\n      this._bindStartEvent(handle, isAdd);\n      handle[bindMethod]('click', this);\n      // touch-action: none to override browser touch gestures. metafizzy/flickity#540\n      if (window.PointerEvent) {\n        handle.style.touchAction = touchAction;\n      }\n    }\n  };\n\n  // prototype so it can be overwriteable by Flickity\n  proto._touchActionValue = 'none';\n\n  // ----- start event ----- //\n\n  /**\n   * pointer start\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n  proto.pointerDown = function (event, pointer) {\n    var isOkay = this.okayPointerDown(event);\n    if (!isOkay) {\n      return;\n    }\n    // track start event position\n    this.pointerDownPointer = pointer;\n\n    event.preventDefault();\n    this.pointerDownBlur();\n    // bind move and end events\n    this._bindPostStartEvents(event);\n    this.emitEvent('pointerDown', [event, pointer]);\n  };\n\n  // nodes that have text fields\n  var cursorNodes = {\n    TEXTAREA: true,\n    INPUT: true,\n    SELECT: true,\n    OPTION: true\n  };\n\n  // input types that do not have text fields\n  var clickTypes = {\n    radio: true,\n    checkbox: true,\n    button: true,\n    submit: true,\n    image: true,\n    file: true\n  };\n\n  // dismiss inputs with text fields. flickity#403, flickity#404\n  proto.okayPointerDown = function (event) {\n    var isCursorNode = cursorNodes[event.target.nodeName];\n    var isClickType = clickTypes[event.target.type];\n    var isOkay = !isCursorNode || isClickType;\n    if (!isOkay) {\n      this._pointerReset();\n    }\n    return isOkay;\n  };\n\n  // kludge to blur previously focused input\n  proto.pointerDownBlur = function () {\n    var focused = document.activeElement;\n    // do not blur body for IE10, metafizzy/flickity#117\n    var canBlur = focused && focused.blur && focused != document.body;\n    if (canBlur) {\n      focused.blur();\n    }\n  };\n\n  // ----- move event ----- //\n\n  /**\n   * drag move\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n  proto.pointerMove = function (event, pointer) {\n    var moveVector = this._dragPointerMove(event, pointer);\n    this.emitEvent('pointerMove', [event, pointer, moveVector]);\n    this._dragMove(event, pointer, moveVector);\n  };\n\n  // base pointer move logic\n  proto._dragPointerMove = function (event, pointer) {\n    var moveVector = {\n      x: pointer.pageX - this.pointerDownPointer.pageX,\n      y: pointer.pageY - this.pointerDownPointer.pageY\n    };\n    // start drag if pointer has moved far enough to start drag\n    if (!this.isDragging && this.hasDragStarted(moveVector)) {\n      this._dragStart(event, pointer);\n    }\n    return moveVector;\n  };\n\n  // condition if pointer has moved far enough to start drag\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > 3 || Math.abs(moveVector.y) > 3;\n  };\n\n  // ----- end event ----- //\n\n  /**\n   * pointer up\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n  proto.pointerUp = function (event, pointer) {\n    this.emitEvent('pointerUp', [event, pointer]);\n    this._dragPointerUp(event, pointer);\n  };\n\n  proto._dragPointerUp = function (event, pointer) {\n    if (this.isDragging) {\n      this._dragEnd(event, pointer);\n    } else {\n      // pointer didn't move enough for drag to start\n      this._staticClick(event, pointer);\n    }\n  };\n\n  // -------------------------- drag -------------------------- //\n\n  // dragStart\n  proto._dragStart = function (event, pointer) {\n    this.isDragging = true;\n    // prevent clicks\n    this.isPreventingClicks = true;\n    this.dragStart(event, pointer);\n  };\n\n  proto.dragStart = function (event, pointer) {\n    this.emitEvent('dragStart', [event, pointer]);\n  };\n\n  // dragMove\n  proto._dragMove = function (event, pointer, moveVector) {\n    // do not drag if not dragging yet\n    if (!this.isDragging) {\n      return;\n    }\n\n    this.dragMove(event, pointer, moveVector);\n  };\n\n  proto.dragMove = function (event, pointer, moveVector) {\n    event.preventDefault();\n    this.emitEvent('dragMove', [event, pointer, moveVector]);\n  };\n\n  // dragEnd\n  proto._dragEnd = function (event, pointer) {\n    // set flags\n    this.isDragging = false;\n    // re-enable clicking async\n    setTimeout(function () {\n      delete this.isPreventingClicks;\n    }.bind(this));\n\n    this.dragEnd(event, pointer);\n  };\n\n  proto.dragEnd = function (event, pointer) {\n    this.emitEvent('dragEnd', [event, pointer]);\n  };\n\n  // ----- onclick ----- //\n\n  // handle all clicks and prevent clicks when dragging\n  proto.onclick = function (event) {\n    if (this.isPreventingClicks) {\n      event.preventDefault();\n    }\n  };\n\n  // ----- staticClick ----- //\n\n  // triggered after pointer down & up with no/tiny movement\n  proto._staticClick = function (event, pointer) {\n    // ignore emulated mouse up clicks\n    if (this.isIgnoringMouseUp && event.type == 'mouseup') {\n      return;\n    }\n\n    this.staticClick(event, pointer);\n\n    // set flag for emulated clicks 300ms after touchend\n    if (event.type != 'mouseup') {\n      this.isIgnoringMouseUp = true;\n      // reset flag after 300ms\n      setTimeout(function () {\n        delete this.isIgnoringMouseUp;\n      }.bind(this), 400);\n    }\n  };\n\n  proto.staticClick = function (event, pointer) {\n    this.emitEvent('staticClick', [event, pointer]);\n  };\n\n  // ----- utils ----- //\n\n  Unidragger.getPointerPoint = Unipointer.getPointerPoint;\n\n  // -----  ----- //\n\n  return Unidragger;\n});\n\n//# sourceURL=webpack:///./node_modules/unidragger/unidragger.js?");

/***/ }),

/***/ "./node_modules/unipointer/unipointer.js":
/*!***********************************************!*\
  !*** ./node_modules/unipointer/unipointer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unipointer v2.3.0\n * base class for doing one thing with pointer event\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n(function (window, factory) {\n  // universal module definition\n  /* jshint strict: false */ /*global define, module, require */\n  if (true) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ev-emitter/ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (EvEmitter) {\n      return factory(window, EvEmitter);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, function factory(window, EvEmitter) {\n\n  'use strict';\n\n  function noop() {}\n\n  function Unipointer() {}\n\n  // inherit EvEmitter\n  var proto = Unipointer.prototype = Object.create(EvEmitter.prototype);\n\n  proto.bindStartEvent = function (elem) {\n    this._bindStartEvent(elem, true);\n  };\n\n  proto.unbindStartEvent = function (elem) {\n    this._bindStartEvent(elem, false);\n  };\n\n  /**\n   * Add or remove start event\n   * @param {Boolean} isAdd - remove if falsey\n   */\n  proto._bindStartEvent = function (elem, isAdd) {\n    // munge isAdd, default to true\n    isAdd = isAdd === undefined ? true : isAdd;\n    var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n\n    // default to mouse events\n    var startEvent = 'mousedown';\n    if (window.PointerEvent) {\n      // Pointer Events\n      startEvent = 'pointerdown';\n    } else if ('ontouchstart' in window) {\n      // Touch Events. iOS Safari\n      startEvent = 'touchstart';\n    }\n    elem[bindMethod](startEvent, this);\n  };\n\n  // trigger handler methods for events\n  proto.handleEvent = function (event) {\n    var method = 'on' + event.type;\n    if (this[method]) {\n      this[method](event);\n    }\n  };\n\n  // returns the touch that we're keeping track of\n  proto.getTouch = function (touches) {\n    for (var i = 0; i < touches.length; i++) {\n      var touch = touches[i];\n      if (touch.identifier == this.pointerIdentifier) {\n        return touch;\n      }\n    }\n  };\n\n  // ----- start event ----- //\n\n  proto.onmousedown = function (event) {\n    // dismiss clicks from right or middle buttons\n    var button = event.button;\n    if (button && button !== 0 && button !== 1) {\n      return;\n    }\n    this._pointerDown(event, event);\n  };\n\n  proto.ontouchstart = function (event) {\n    this._pointerDown(event, event.changedTouches[0]);\n  };\n\n  proto.onpointerdown = function (event) {\n    this._pointerDown(event, event);\n  };\n\n  /**\n   * pointer start\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n  proto._pointerDown = function (event, pointer) {\n    // dismiss right click and other pointers\n    // button = 0 is okay, 1-4 not\n    if (event.button || this.isPointerDown) {\n      return;\n    }\n\n    this.isPointerDown = true;\n    // save pointer identifier to match up touch events\n    this.pointerIdentifier = pointer.pointerId !== undefined ?\n    // pointerId for pointer events, touch.indentifier for touch events\n    pointer.pointerId : pointer.identifier;\n\n    this.pointerDown(event, pointer);\n  };\n\n  proto.pointerDown = function (event, pointer) {\n    this._bindPostStartEvents(event);\n    this.emitEvent('pointerDown', [event, pointer]);\n  };\n\n  // hash of events to be bound after start event\n  var postStartEvents = {\n    mousedown: ['mousemove', 'mouseup'],\n    touchstart: ['touchmove', 'touchend', 'touchcancel'],\n    pointerdown: ['pointermove', 'pointerup', 'pointercancel']\n  };\n\n  proto._bindPostStartEvents = function (event) {\n    if (!event) {\n      return;\n    }\n    // get proper events to match start event\n    var events = postStartEvents[event.type];\n    // bind events to node\n    events.forEach(function (eventName) {\n      window.addEventListener(eventName, this);\n    }, this);\n    // save these arguments\n    this._boundPointerEvents = events;\n  };\n\n  proto._unbindPostStartEvents = function () {\n    // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)\n    if (!this._boundPointerEvents) {\n      return;\n    }\n    this._boundPointerEvents.forEach(function (eventName) {\n      window.removeEventListener(eventName, this);\n    }, this);\n\n    delete this._boundPointerEvents;\n  };\n\n  // ----- move event ----- //\n\n  proto.onmousemove = function (event) {\n    this._pointerMove(event, event);\n  };\n\n  proto.onpointermove = function (event) {\n    if (event.pointerId == this.pointerIdentifier) {\n      this._pointerMove(event, event);\n    }\n  };\n\n  proto.ontouchmove = function (event) {\n    var touch = this.getTouch(event.changedTouches);\n    if (touch) {\n      this._pointerMove(event, touch);\n    }\n  };\n\n  /**\n   * pointer move\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   * @private\n   */\n  proto._pointerMove = function (event, pointer) {\n    this.pointerMove(event, pointer);\n  };\n\n  // public\n  proto.pointerMove = function (event, pointer) {\n    this.emitEvent('pointerMove', [event, pointer]);\n  };\n\n  // ----- end event ----- //\n\n\n  proto.onmouseup = function (event) {\n    this._pointerUp(event, event);\n  };\n\n  proto.onpointerup = function (event) {\n    if (event.pointerId == this.pointerIdentifier) {\n      this._pointerUp(event, event);\n    }\n  };\n\n  proto.ontouchend = function (event) {\n    var touch = this.getTouch(event.changedTouches);\n    if (touch) {\n      this._pointerUp(event, touch);\n    }\n  };\n\n  /**\n   * pointer up\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   * @private\n   */\n  proto._pointerUp = function (event, pointer) {\n    this._pointerDone();\n    this.pointerUp(event, pointer);\n  };\n\n  // public\n  proto.pointerUp = function (event, pointer) {\n    this.emitEvent('pointerUp', [event, pointer]);\n  };\n\n  // ----- pointer done ----- //\n\n  // triggered on pointer up & pointer cancel\n  proto._pointerDone = function () {\n    this._pointerReset();\n    this._unbindPostStartEvents();\n    this.pointerDone();\n  };\n\n  proto._pointerReset = function () {\n    // reset properties\n    this.isPointerDown = false;\n    delete this.pointerIdentifier;\n  };\n\n  proto.pointerDone = noop;\n\n  // ----- pointer cancel ----- //\n\n  proto.onpointercancel = function (event) {\n    if (event.pointerId == this.pointerIdentifier) {\n      this._pointerCancel(event, event);\n    }\n  };\n\n  proto.ontouchcancel = function (event) {\n    var touch = this.getTouch(event.changedTouches);\n    if (touch) {\n      this._pointerCancel(event, touch);\n    }\n  };\n\n  /**\n   * pointer cancel\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   * @private\n   */\n  proto._pointerCancel = function (event, pointer) {\n    this._pointerDone();\n    this.pointerCancel(event, pointer);\n  };\n\n  // public\n  proto.pointerCancel = function (event, pointer) {\n    this.emitEvent('pointerCancel', [event, pointer]);\n  };\n\n  // -----  ----- //\n\n  // utility function for getting x/y coords from event\n  Unipointer.getPointerPoint = function (pointer) {\n    return {\n      x: pointer.pageX,\n      y: pointer.pageY\n    };\n  };\n\n  // -----  ----- //\n\n  return Unipointer;\n});\n\n//# sourceURL=webpack:///./node_modules/unipointer/unipointer.js?");

/***/ }),

/***/ "./src/js/build/product.js":
/*!*********************************!*\
  !*** ./src/js/build/product.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _plugins_scripts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../plugins/scripts */ \"./src/js/plugins/scripts.js\");\n/* harmony import */ var _plugins_scripts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_plugins_scripts__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_product_configurables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/product-configurables */ \"./src/js/lib/product-configurables.js\");\n/* harmony import */ var _lib_product_photos__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/product-photos */ \"./src/js/lib/product-photos.js\");\n/* harmony import */ var _lib_product_swatches__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/product-swatches */ \"./src/js/lib/product-swatches.js\");\n/* harmony import */ var _lib_video__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/video */ \"./src/js/lib/video.js\");\n/* harmony import */ var _lib_product_related__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/product-related */ \"./src/js/lib/product-related.js\");\n/* harmony import */ var _lib_product_shade_info__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/product-shade-info */ \"./src/js/lib/product-shade-info.js\");\n/**\n * product\n *\n * import dependencies\n * namespace\n * run\n * fire functions\n */\n// import Flickity from 'flickity';\n\n\n\n\n\n\n\n\n/**\n * product namespace\n * @type {Object}\n */\nSDG.Product = SDG.Product || {};\n\n/**\n * run\n * @type {Function}\n */\nSDG.Product.run = function () {\n\n\t// configurables\n\t_plugins_scripts__WEBPACK_IMPORTED_MODULE_0___default()([path.flickity, path.shopify_options, path.product_essentials], () => {\n\t\tObject(_lib_product_swatches__WEBPACK_IMPORTED_MODULE_3__[\"default\"])().init();\n\t\tObject(_lib_product_photos__WEBPACK_IMPORTED_MODULE_2__[\"default\"])().init();\n\t\tObject(_lib_product_configurables__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n\t\t\tuse: {\n\t\t\t\tcolor_label: true,\n\t\t\t\tconfig_label: true\n\t\t\t}\n\t\t});\n\t});\n\n\t// add to bag\n\tSDG.Bag.form();\n\n\t// video\n\tconst videoEmbed = Object(_lib_video__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n\tvideoEmbed.init();\n\n\t// related products\n\tObject(_lib_product_related__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n\n\t// open shade info tab\n\tconst shade = Object(_lib_product_shade_info__WEBPACK_IMPORTED_MODULE_6__[\"default\"])();\n\tshade.init();\n\n\t// ingredients list modal\n\tconst modalOptsIngr = {\n\t\tdom: {\n\t\t\tmodal_id: 'ingredientsListModal',\n\t\t\toverlay: 'ingredientsListOverlay',\n\t\t\ttrigger: 'ingredientsListTrigger'\n\t\t}\n\t};\n\tconst modalIngr = SDG.Modal.init(modalOptsIngr);\n\tmodalIngr.init();\n};\n\n/**\n * fire functions\n */\nSDG.Product.run();\n\n//# sourceURL=webpack:///./src/js/build/product.js?");

/***/ }),

/***/ "./src/js/lib/product-configurables.js":
/*!*********************************************!*\
  !*** ./src/js/lib/product-configurables.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_format_money__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/format-money */ \"./src/js/util/format-money.js\");\n/**\r\n* product configurables\r\n*\r\n* import dependencies\r\n* product namespace\r\n* product config\r\n* config\r\n* extend product config\r\n* state\r\n* configurables\r\n*/\n\n/**\r\n * import dependencies\r\n */\n\n\n/**\r\n * product namespace\r\n * @type {Object}\r\n */\nSDG.Product = SDG.Product || {};\n\n/**\r\n * product config\r\n * @type {Object}\r\n */\nSDG.Product.config = SDG.Product.config || {};\n\n/**\r\n * config\r\n * @type {Object}\r\n */\nSDG.Product.config_cfgs = {\n\tcls: {\n\t\tactive: 'is-active',\n\t\tdisabled: 'is-disabled',\n\t\tspecial_price: 'has-special-price',\n\t\tvisible: 'is-visible'\n\t},\n\tdom: {\n\t\tbtn: 'js-config-btn',\n\t\tbtn_color: 'js-config-btn-color',\n\t\tgroup: 'js-config-group',\n\t\tlabel: 'js-config-label',\n\t\tprice_original: '.js-price-original',\n\t\tprice_compare: '.js-price-compare',\n\t\tradio: 'js-config-radio',\n\t\tselect_beta: '.single-option-selector',\n\t\tvariant: '.js-config-variant'\n\n\t},\n\thide_bag_btn: true,\n\tid: {\n\t\tbag_btn: 'btnAddToBag',\n\t\tbag_text: 'btnAddToBagText',\n\t\tcolor_label: 'colorLabel',\n\t\tconfig_options: 'configOptions',\n\t\tform: 'addToBagForm',\n\t\tprice_container: ['productPrice'],\n\t\tselect_alpha: 'productSelect'\n\t},\n\tnamespace: null,\n\timage_json: '',\n\tproduct_json: '',\n\ttext: {\n\t\tbag_default: 'Add to Bag',\n\t\tbag_outofstock: 'Sold Out'\n\t},\n\tuse: {\n\t\tcolor_label: false,\n\t\tconfig_label: false,\n\t\tconfig_label_remap: false,\n\t\tnotify: true,\n\t\tupdate_price: true\n\t}\n};\n\n/**\r\n * extend product config\r\n * @type {Object}\r\n */\nSDG.Product.config = _.extend(SDG.Product.config, SDG.Product.config_cfgs);\n\n/**\r\n * state\r\n * @type {Object}\r\n */\nSDG.Product.state = {\n\tbag_btn: {\n\t\tis_default: true\n\t}\n};\n\n/**\r\n * configurables\r\n * @param  {Object} opts\r\n * @return {productConfigurables~init}\r\n */\nfunction productConfigurables(opts) {\n\tconst c = _.extend(SDG.Product.config, opts);\n\n\t// namespace\n\tif (c.namespace) {\n\t\tc.id = _.namespace(c.id, c.namespace);\n\t}\n\n\t// state\n\tconst { state } = SDG.Product;\n\n\t// cached globals\n\tconst $form = document.getElementById(c.id.form);\n\tconst $allGroups = $form.querySelectorAll(`.${c.dom.group}`);\n\tconst $allBtns = $form.querySelectorAll(`.${c.dom.btn}`);\n\tconst $bagBtn = document.getElementById(c.id.bag_btn);\n\tconst $bagText = document.getElementById(c.id.bag_text);\n\tconst $configOptions = document.getElementById(c.id.config_options);\n\tconst productIsDefaultOption = isDefaultOption();\n\tlet notify;\n\n\t// set product data\n\tconst imageData = c.product_json ? c.product_json : imageJson;\n\tconst productData = c.product_json ? c.product_json : productJson;\n\n\t/**\r\n  * init\r\n  * @type {Function}\r\n  */\n\tfunction init() {\n\n\t\t// select first\n\t\tselectFirst();\n\n\t\tif ($configOptions) {\n\t\t\t// eslint-disable-next-line\n\t\t\tnew Shopify.OptionSelectors(c.id.select_alpha, {\n\t\t\t\tproduct: productData,\n\t\t\t\tonVariantSelected: selectCallback\n\t\t\t});\n\t\t}\n\n\t\t// add events\n\t\taddEvents();\n\n\t\t// set notify\n\t\tif (typeof ProductNotify === 'function' && c.use.notify) {\n\t\t\tnotify = ProductNotify(); // eslint-disable-line\n\t\t}\n\t}\n\n\t/**\r\n  * add events\r\n  */\n\tfunction addEvents() {\n\n\t\t// radio change\n\t\t_.addEvent({\n\t\t\tid: $form,\n\t\t\tclassName: c.dom.radio,\n\t\t\tevent: 'change',\n\t\t\tfn: updateSelect\n\t\t});\n\n\t\t// button click\n\t\t_.addEvent({\n\t\t\tid: $form,\n\t\t\tclassName: c.dom.btn,\n\t\t\tevent: 'click',\n\t\t\tfn: onButtonClick\n\t\t});\n\t}\n\n\t/**\r\n  * shopify select callback\r\n  * @type {Function}\r\n  */\n\tfunction selectCallback(variant, selector) {\n\n\t\t// only continue if variant exists\n\t\tif (!variant) return;\n\n\t\t// set active radios\n\t\tsetActiveRadios();\n\n\t\t// check stock\n\t\tcheckStock(variant, selector);\n\n\t\t// update price\n\t\tif (c.use.update_price) {\n\t\t\tupdatePrice(variant);\n\t\t}\n\n\t\t// update color label\n\t\tif (c.use.color_label) {\n\t\t\tupdateColorLabel();\n\t\t}\n\n\t\t// update config label\n\t\tif (c.use.config_label) {\n\t\t\tupdateConfigLabel();\n\t\t}\n\n\t\t// update photos\n\t\t/* eslint-disable */\n\t\tif (SDG.Product.swatches) {\n\t\t\tSDG.Product.swatches({\n\t\t\t\timage_json: imageData,\n\t\t\t\tproduct_json: productData\n\t\t\t}).update(variant);\n\t\t}\n\t\t/* eslint-enable */\n\t}\n\n\t/**\r\n  * on button click\r\n  */\n\tfunction onButtonClick() {\n\t\tsetActiveButton(this);\n\t}\n\n\t/**\r\n  * update select\r\n  * @type {Function}\r\n  */\n\tfunction updateSelect() {\n\t\tconst $opt = _.parents(this, `.${c.dom.group}`)[0];\n\t\tconst val = this.value;\n\t\tconst idx = $opt.getAttribute('data-option-index');\n\t\tconst $select = $form.querySelectorAll(c.dom.select_beta)[idx];\n\t\tconst $option = $select.querySelector(`option[value=\"${val}\"]`);\n\n\t\t$option.selected = true;\n\t\t_.trigger($select, 'change');\n\t}\n\n\t/**\r\n  * set active button\r\n  */\n\tfunction setActiveButton($btn) {\n\t\tconst isActive = _.hasClass($btn, c.cls.active);\n\n\t\t// if already active, exit function\n\t\tif (isActive) return;\n\n\t\t// get active button\n\t\tconst $parentGroup = _.parents($btn, `.${c.dom.group}`)[0];\n\t\tconst $active = $parentGroup.querySelector(`.${c.cls.active}`);\n\n\t\t// remove currently selected active class\n\t\tif ($active) {\n\t\t\t_.removeClass($active, c.cls.active);\n\t\t}\n\n\t\t// add active class to newly selected button\n\t\t_.addClass($btn, c.cls.active);\n\t}\n\n\t/**\r\n  * set active radios\r\n  */\n\tfunction setActiveRadios() {\n\n\t\t// if product is default option, exit\n\t\tif (productIsDefaultOption) return;\n\n\t\t// get active buttons\n\t\tconst $btns = $configOptions.querySelectorAll(`.${c.dom.btn}.${c.cls.active}`);\n\n\t\t// if there are no active buttons, exit\n\t\tif (!$btns) return;\n\n\t\t// loop over buttons, checking its radio\n\t\t$btns.forEach($btn => {\n\t\t\t$btn.previousElementSibling.checked = true;\n\t\t});\n\t}\n\n\t/**\r\n  * check stock\r\n  * @param {Object} variant\r\n  * @param {Object} selector\r\n  */\n\tfunction checkStock(variant, selector) {\n\t\tconst { product } = selector;\n\t\tconst { variants } = product;\n\t\tconst variantsCount = variants.length;\n\t\tlet $groups;\n\t\tlet obj;\n\n\t\tif (variantsCount > 1) {\n\n\t\t\tif ($allGroups.length > 1) {\n\t\t\t\t$groups = getOtherGroups();\n\t\t\t\tenableAllBtns();\n\t\t\t\tdisableVariantOptions($groups);\n\t\t\t}\n\n\t\t\t$allGroups.forEach($group => {\n\t\t\t\tObject.keys(variants).forEach(key => {\n\t\t\t\t\tobj = variants[key];\n\n\t\t\t\t\tif (variant.option1 === obj.option1) {\n\n\t\t\t\t\t\thandleVariantOptions($group, obj);\n\n\t\t\t\t\t\tconst { id, available } = variant;\n\n\t\t\t\t\t\tsetStockStatus(available, id);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\n\t\t\tsetStockStatus(variant.available, variant.id);\n\t\t}\n\t}\n\n\t/**\r\n  * handle variant options\r\n  * @param {Object} obj\r\n  */\n\tfunction handleVariantOptions($group, obj) {\n\t\tconst str = 'option';\n\t\tlet i;\n\t\tlet opt;\n\t\tlet value;\n\t\tlet $btn;\n\t\tlet $variant;\n\n\t\tfor (i = 1; i < 4; i += 1) {\n\t\t\topt = str + i;\n\n\t\t\tif (obj[opt]) {\n\n\t\t\t\tvalue = obj[opt];\n\t\t\t\t$variant = $group.querySelector(`${c.dom.variant}[data-value=\"${value}\"]`);\n\t\t\t\t$btn = $group.querySelector(`.${c.dom.btn}`);\n\n\t\t\t\t_.show($btn);\n\n\t\t\t\tif (obj.available) {\n\t\t\t\t\t_.removeClass($btn, c.cls.disabled);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\r\n  * get other groups\r\n  */\n\tfunction getOtherGroups() {\n\t\tconst $groups = [];\n\t\tlet $group;\n\n\t\tObject.keys($allGroups).forEach(key => {\n\t\t\tif (key !== '0') {\n\t\t\t\t$group = $allGroups[key];\n\t\t\t\t$groups.push($group);\n\t\t\t}\n\t\t});\n\n\t\treturn $groups;\n\t}\n\n\t/**\r\n  * disable variant options\r\n  * @param {Array} groups\r\n  */\n\n\tfunction disableVariantOptions($groups) {\n\n\t\tfunction initLoop() {\n\t\t\tlet $group;\n\t\t\tlet $btn;\n\n\t\t\tif ($groups && $groups.length > 0) {\n\t\t\t\tObject.keys($groups).forEach(key => {\n\t\t\t\t\t$group = $groups[key];\n\t\t\t\t\t$btn = $group.querySelectorAll(`.${c.dom.btn}`);\n\n\t\t\t\t\tloop($btn);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction loop($btn) {\n\n\t\t\tif ($btn) {\n\t\t\t\tObject.keys($btn).forEach(i => {\n\t\t\t\t\t_.addClass($btn[i], c.cls.disabled);\n\t\t\t\t\t_.hide($btn[i]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn initLoop();\n\t}\n\n\t/**\r\n  * enable all buttons\r\n  */\n\tfunction enableAllBtns() {\n\t\tlet $btn;\n\n\t\tObject.keys($allBtns).forEach(key => {\n\t\t\t$btn = $allBtns[key];\n\t\t\t_.removeClass($btn, c.cls.disabled);\n\t\t\t_.show($btn);\n\t\t});\n\t}\n\n\t/**\r\n  * set stock status\r\n  * @param {Boolean} available\r\n  * @param {Number}  id\r\n  */\n\tfunction setStockStatus(available, id) {\n\n\t\t// if notify form\n\t\tif (notify) {\n\n\t\t\tif (available) {\n\n\t\t\t\t_.show($bagBtn);\n\t\t\t\tsetBagButtonDefault();\n\t\t\t} else if (c.hide_bag_btn) {\n\n\t\t\t\t_.hide($bagBtn);\n\t\t\t} else {\n\n\t\t\t\tsetBagButtonOutOfStock();\n\t\t\t}\n\n\t\t\tnotify.show(available, id);\n\t\t} else if (available) {\n\t\t\t// else no notify form\n\n\t\t\tsetBagButtonDefault();\n\t\t} else {\n\n\t\t\tsetBagButtonOutOfStock();\n\t\t}\n\t}\n\n\t/**\r\n  * set bag button default\r\n  */\n\tfunction setBagButtonDefault() {\n\n\t\t// if already set to default, exit function\n\t\tif (state.bag_btn.is_default) return;\n\n\t\t// set flag\n\t\tstate.bag_btn.is_default = true;\n\n\t\t// modify button\n\t\t_.removeClass($bagBtn, c.cls.disabled);\n\t\t$bagBtn.disabled = false;\n\t\t$bagText.innerHTML = c.text.bag_default;\n\t}\n\n\t/**\r\n  * set bag button out of stock\r\n  */\n\tfunction setBagButtonOutOfStock() {\n\n\t\t// if already set as not default, exit function\n\t\tif (!state.bag_btn.is_default) return;\n\n\t\t// set flag\n\t\tstate.bag_btn.is_default = false;\n\n\t\t// modify button\n\t\t_.addClass($bagBtn, c.cls.disabled);\n\t\t$bagBtn.disabled = true;\n\t\t$bagText.innerHTML = c.text.bag_outofstock;\n\t}\n\n\t/**\r\n  * update price\r\n  * @param {Object} variant\r\n  */\n\tfunction updatePrice(variant) {\n\t\tconst { price, compare_at_price: priceCompare } = variant;\n\t\tconst hasSpecialPrice = priceCompare > price;\n\t\tconst priceCompareDisplay = `${Object(_util_format_money__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(priceCompare, 'amount_with_currency_without_trailing_zeros')}`;\n\t\tconst priceCompareDisplayStyle = hasSpecialPrice ? 'inline-block' : 'none';\n\t\tconst priceCompareDisplayClassMethod = hasSpecialPrice ? 'addClass' : 'removeClass';\n\t\tconst displayPriceCompare = (el, display) => {\n\t\t\t$price = document.getElementById(el);\n\t\t\tif ($price) {\n\t\t\t\t$priceCompare = $price.querySelector(c.dom.price_compare);\n\t\t\t\t$priceCompare.style.display = display;\n\t\t\t\t_[priceCompareDisplayClassMethod]($price, c.cls.special_price);\n\t\t\t}\n\t\t};\n\t\tconst updatePriceCompare = el => {\n\t\t\t$price = document.getElementById(el);\n\t\t\tif ($price) {\n\t\t\t\t$price.querySelector(c.dom.price_compare).innerHTML = priceCompareDisplay;\n\t\t\t\t$price.querySelector(c.dom.price_original).innerHTML = priceDisplay;\n\t\t\t}\n\t\t};\n\t\tconst updatePriceOriginal = el => {\n\t\t\t$price = document.getElementById(el);\n\t\t\tif ($price) {\n\t\t\t\t$price.querySelector(c.dom.price_compare).innerHTML = '';\n\t\t\t\t$price.querySelector(c.dom.price_original).innerHTML = priceDisplay;\n\t\t\t}\n\t\t};\n\t\tlet priceDisplay = `${Object(_util_format_money__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(price, 'amount_with_currency_without_trailing_zeros')}`;\n\t\tlet $price;\n\t\tlet $priceCompare;\n\n\t\t// format price display\n\t\tif (hasSpecialPrice) {\n\t\t\tpriceDisplay = `Now ${priceDisplay}`;\n\t\t}\n\n\t\t// update prices\n\t\tif (hasSpecialPrice) {\n\t\t\tc.id.price_container.forEach(updatePriceCompare);\n\t\t} else {\n\t\t\tc.id.price_container.forEach(updatePriceOriginal);\n\t\t}\n\n\t\t// update price compare display\n\t\tc.id.price_container.forEach(el => displayPriceCompare(el, priceCompareDisplayStyle));\n\t}\n\n\t/**\r\n  * update color label\r\n  */\n\tfunction updateColorLabel() {\n\t\tconst $activeColor = $form.querySelector(`.${c.dom.btn_color}.${c.cls.active}`);\n\t\tconst $colorLabel = document.getElementById(c.id.color_label);\n\n\t\tif (!$activeColor || !$colorLabel) return;\n\n\t\t$colorLabel.innerHTML = $activeColor.getAttribute('data-val');\n\t}\n\n\t/**\r\n  * update config label\r\n  */\n\tfunction updateConfigLabel() {\n\t\tconst $activeBtns = $form.querySelectorAll(`.${c.dom.btn}.${c.cls.active}`);\n\t\tlet $active;\n\t\tlet $group;\n\t\tlet $label;\n\t\tlet val;\n\t\tlet valFormat;\n\n\t\tif ($activeBtns) {\n\t\t\tObject.keys($activeBtns).forEach(key => {\n\t\t\t\t$active = $activeBtns[key];\n\t\t\t\tval = $active.getAttribute('data-val');\n\t\t\t\tvalFormat = c.use.config_label_remap ? _.remapSizeValues(val) : val;\n\t\t\t\t[$group] = _.parents($active, `.${c.dom.group}`);\n\t\t\t\t$label = $group.querySelector(`.${c.dom.label}`);\n\n\t\t\t\t// if (valFormat.indexOf('Glow Down') > -1) {\n\t\t\t\t// \tvalFormat = `${valFormat} <span>(New Shade!)</span>`;\n\t\t\t\t// }\n\n\t\t\t\t// set label\n\t\t\t\t$label.innerHTML = valFormat;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\r\n  * select first\r\n  */\n\tfunction selectFirst() {\n\t\tlet $group;\n\t\tlet $btn;\n\n\t\tObject.keys($allGroups).forEach(key => {\n\t\t\t$group = $allGroups[key];\n\t\t\t[$btn] = $group.querySelectorAll(`.${c.dom.btn}:not(.${c.cls.disabled})`);\n\n\t\t\tif ($btn) {\n\t\t\t\t_.addClass($btn, c.cls.active);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\r\n  * is default option\r\n  * check if product has default option of 'title'\r\n  * @return {Boolean}\r\n  */\n\tfunction isDefaultOption() {\n\t\tconst lowercaseOptions = _.arrayToLower(productJson.options);\n\t\tlet isDefault = false;\n\n\t\tlowercaseOptions.forEach(option => {\n\t\t\tif (option === 'title') {\n\t\t\t\tisDefault = true;\n\t\t\t}\n\t\t});\n\n\t\treturn isDefault;\n\t}\n\n\treturn init();\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (productConfigurables);\n\n//# sourceURL=webpack:///./src/js/lib/product-configurables.js?");

/***/ }),

/***/ "./src/js/lib/product-photos.js":
/*!**************************************!*\
  !*** ./src/js/lib/product-photos.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var flickity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flickity */ \"./node_modules/flickity/js/index.js\");\n/* harmony import */ var flickity__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(flickity__WEBPACK_IMPORTED_MODULE_0__);\n/**\n* Product\n* @requires [lib/util.js]\n*\n* product namespace\n* product config\n* product carousel photos\n* product carousel thumbs\n* photos config\n* photos\n* run\n* run dom ready\n* fire functions\n*/\n\n/**\n * import dependencies\n */\n\n\n/**\n * require dependencies\n */\n__webpack_require__(/*! flickity-as-nav-for */ \"./node_modules/flickity-as-nav-for/as-nav-for.js\");\n\n/**\n * product namespace\n * @type {Object}\n */\nSDG.Product = SDG.Product || {};\n\n/**\n * product config\n * @type {Object}\n */\nSDG.Product.config = SDG.Product.config || {};\n\n/**\n * product carousel main\n * @type {Object}\n */\nSDG.Product.carouselPhotos = SDG.Product.carouselPhotos || {};\n\n/**\n * product carousel thumbs\n * @type {Object}\n */\nSDG.Product.carouselThumbs = SDG.Product.carouselThumbs || {};\n\n/**\n * product large thumbs\n * @type {Object}\n */\nSDG.Product.largePhotos = SDG.Product.largePhotos || {};\n\n/**\n * photos config\n * @type {Object}\n */\nSDG.Product.config_photos = {\n\tcls: {\n\t\tactive: 'is-active'\n\t},\n\tdom: {\n\t\tgallery: 'gallery',\n\t\tphoto: 'js-photo',\n\t\tphotos: 'photos',\n\t\tstatus: 'status',\n\t\tthumb: 'js-thumb',\n\t\tthumbs: 'thumbs',\n\n\t\tlarge_photos: 'largePhotos',\n\t\tlarge_photos_modal: 'largePhotosModal',\n\t\tzoom: 'js-zoom',\n\t\tclose: 'js-close',\n\t\tmodal_trigger: 'modalTriggerBtn',\n\t\tmodal_close: 'modalClose',\n\t\tphoto_class: 'pv__photo-modal'\n\t},\n\timage_json: '',\n\tphoto_size: {\n\t\tfull_desktop: '670x',\n\t\tfull_desktop_retina: '1340x',\n\t\tfull_desktop_zoom: '1300x',\n\n\t\tfull_phone: '690x',\n\t\tfull_phone_retina: '1380x',\n\n\t\tfull_tablet: '839x',\n\t\tfull_tablet_retina: '1678x',\n\n\t\tthumb: '62x62_crop_center',\n\t\tthumb_retina: '124x124_crop_center'\n\t}\n};\n\n/**\n * extend product config\n * @type {Object}\n */\nSDG.Product.config = _.extend(SDG.Product.config, SDG.Product.config_photos);\n\n/**\n* photos\n* @type {Function}\n* @return {init}\n*/\nSDG.Product.photos = function (opts) {\n\n\t// config\n\tconst c = _.extend(SDG.Product.config, opts);\n\n\t// flickity main config\n\tconst flickityPhotosConfig = {\n\t\tcontain: true,\n\t\tdraggable: true,\n\t\tprevNextButtons: false,\n\t\tadaptiveHeight: false,\n\t\tpageDots: false,\n\t\tcellSelector: '.js-photo'\n\t};\n\n\t// flickity thumbs config\n\tconst flickityThumbsConfig = {\n\t\tadaptiveHeight: false,\n\t\tasNavFor: `#${c.dom.photos}`,\n\t\tcellAlign: 'center',\n\t\tcontain: true,\n\t\tprevNextButtons: false,\n\t\tpageDots: false,\n\t\tdraggable: true\n\t};\n\n\t// flickity thumbs config\n\tconst flickityLargePhotosConfig = {\n\t\tcontain: true,\n\t\tprevNextButtons: true,\n\t\tadaptiveHeight: true,\n\t\tpageDots: false,\n\t\twrapAround: true\n\t};\n\n\t// modal large photos\n\tconst galleryZoom = SDG.Modal.init({\n\t\tdom: {\n\t\t\tmodal_id: c.dom.large_photos_modal,\n\t\t\ttrigger: c.dom.modal_trigger\n\t\t}\n\t});\n\n\t// cached globals\n\tconst imageData = c.image_json ? c.image_json : imageJson;\n\tconst $photos = document.getElementById(c.dom.photos);\n\tconst $thumbs = document.getElementById(c.dom.thumbs);\n\tconst $largePhotos = document.getElementById(c.dom.large_photos);\n\n\t/**\n  * init\n  */\n\tfunction init() {\n\t\tinitGallery();\n\n\t\t// build regular slides if normal images w/o color alt tags\n\t\t// otherwise, specific color galleries are built from product-swatches.js,\n\t\t// and is called from product-configurables.js\n\t\t// @see src/js/lib/product-swatches.js\n\t\t// @see src/js/lib/product-configurables.js\n\t\tconst hasAltImages = hasSomeSwatchJson();\n\n\t\tinitModalGallery();\n\n\t\tif (!hasAltImages) {\n\t\t\tbuildSlides();\n\t\t}\n\n\t\tresponsive();\n\t\t_.windowResize(responsive);\n\t}\n\n\tfunction responsive() {\n\t\t_.mq({\n\t\t\tview: 'desktop',\n\t\t\tcallback: () => {\n\t\t\t\tinitModal();\n\t\t\t\taddEvents();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n * add events\n * @type {Function}\n */\n\tfunction addEvents() {\n\t\t_.addEvent({\n\t\t\tid: c.dom.photos,\n\t\t\tclassName: c.dom.photo,\n\t\t\tevent: 'click',\n\t\t\tfn: openModal\n\t\t});\n\n\t\t_.addEvent({\n\t\t\tid: c.dom.modal_add_to_bag,\n\t\t\tevent: 'click',\n\t\t\tfn: closeModal\n\t\t});\n\t}\n\n\t/**\n * init modal\n */\n\tfunction initModal() {\n\t\tgalleryZoom.init();\n\t}\n\n\tfunction initModalGallery() {\n\t\tSDG.Product.largePhotos = new flickity__WEBPACK_IMPORTED_MODULE_0___default.a($largePhotos, flickityLargePhotosConfig);\n\t\t// buildSlides();\n\t}\n\n\t/**\n * init gallery\n * @desc global so that other product js files have access to the flkty object\n */\n\tfunction initGallery() {\n\t\tSDG.Product.carouselPhotos = new flickity__WEBPACK_IMPORTED_MODULE_0___default.a($photos, flickityPhotosConfig);\n\t\tSDG.Product.carouselThumbs = $thumbs ? new flickity__WEBPACK_IMPORTED_MODULE_0___default.a($thumbs, flickityThumbsConfig) : null;\n\t}\n\n\t/**\n  * build slides\n  * @param {Object} json\n  */\n\tfunction buildSlides(json) {\n\t\tconst photos = [];\n\t\tconst thumbs = [];\n\t\tconst largePhotos = [];\n\t\tconst isJsonEmpty = Array.isArray(json) && !json.length;\n\t\tlet firstSwatchNameWithImages;\n\t\tlet img;\n\t\tlet imgJson;\n\t\tlet photo;\n\t\tlet thumb;\n\t\tlet largePhoto;\n\n\t\t// if imgJson is empty, i.e. if some images have color alts\n\t\t// and others don't, set imgJson to first set of swatch images\n\t\t// else set as normal, i.e. as param or imageData\n\n\t\tif (isJsonEmpty) {\n\t\t\tfirstSwatchNameWithImages = getFirstSwatchNameWithImages();\n\t\t\timgJson = firstSwatchNameWithImages ? SDG.Product.swatchJson[firstSwatchNameWithImages] : imageData; // eslint-disable-line\n\t\t} else if (json) {\n\t\t\timgJson = json;\n\t\t} else {\n\t\t\timgJson = imageData;\n\t\t}\n\n\t\tObject.keys(imgJson).forEach(key => {\n\t\t\timg = imgJson[key];\n\t\t\tphoto = getPhotoHtml(img, key);\n\t\t\tthumb = getThumbHtml(img, key);\n\t\t\tlargePhoto = getPhotoHtml(img, key);\n\n\t\t\tphotos.push(photo);\n\t\t\tthumbs.push(thumb);\n\t\t\tlargePhotos.push(largePhoto);\n\t\t});\n\n\t\tif (photos.length > 0 && thumbs.length > 0 && $thumbs) {\n\t\t\tflktyEmpty();\n\t\t\tattachToFlkty(photos, thumbs);\n\t\t}\n\n\t\tresponsive();\n\t\t_.windowResize(responsive);\n\n\t\tflktyEmptyLargePhotos();\n\t\tattachToFlktyLargePhotos(largePhotos);\n\t}\n\n\tfunction flktyEmpty() {\n\t\tconst $photoSlides = $photos.querySelectorAll(`.${c.dom.photo}`);\n\t\tconst $thumbSlides = $thumbs ? $thumbs.querySelectorAll(`.${c.dom.thumb}`) : false;\n\n\t\tif ($photoSlides) {\n\t\t\tSDG.Product.carouselPhotos.remove($photoSlides);\n\t\t}\n\n\t\tif ($thumbSlides) {\n\t\t\tSDG.Product.carouselThumbs.remove($thumbSlides);\n\t\t}\n\t}\n\n\tfunction flktyEmptyLargePhotos() {\n\t\tconst $largePhotosSlides = $largePhotos.querySelectorAll(`.${c.dom.photo}`);\n\n\t\tif ($largePhotosSlides) {\n\t\t\tSDG.Product.largePhotos.remove($largePhotosSlides);\n\t\t}\n\t}\n\n\tfunction attachToFlkty(photos, thumbs) {\n\n\t\tSDG.Product.carouselPhotos.append(photos);\n\t\tSDG.Product.carouselPhotos.select(0);\n\n\t\tif ($thumbs) {\n\t\t\tSDG.Product.carouselThumbs.append(thumbs);\n\t\t\tSDG.Product.carouselThumbs.select(0);\n\t\t}\n\t}\n\n\tfunction attachToFlktyLargePhotos(largePhotos) {\n\n\t\tSDG.Product.largePhotos.insert(largePhotos);\n\t\tSDG.Product.largePhotos.select(0);\n\t}\n\n\tfunction getPhotoHtml(img, key) {\n\n\t\tlet html;\n\n\t\t// only continue if 'img' is an object\n\t\tif (typeof img === 'object') {\n\n\t\t\thtml = document.createElement('div');\n\t\t\thtml.className = 'pv-photo js-photo';\n\t\t\thtml.setAttribute('data-index', key);\n\t\t\thtml.innerHTML = `<div class=\"pv-photo__inner\">\n\t\t\t\t\t\t\t\t<div class=\"ir is-loading is-loading--pink\" style=\"padding-bottom:${img.ratio}\">\n\t\t\t\t\t\t\t\t\t<div class=\"desktop-only\">\n\t\t\t\t\t\t\t\t\t\t<img class=\"lazyload\" data-srcset=\"${_.getSizedImageUrl(img.src, c.photo_size.full)} 1x, ${_.getSizedImageUrl(img.src, c.photo_size.full_retina)} 2x\" alt=\"${img.alt} Desktop\" />\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class=\"mobile-only\">\n\t\t\t\t\t\t\t\t\t\t<img class=\"lazyload tablet-only\" data-srcset=\"${_.getSizedImageUrl(img.src, c.photo_size.full)} 1x, ${_.getSizedImageUrl(img.src, c.photo_size.full_retina)} 2x\" alt=\"${img.alt} Tablet\" />\n\t\t\t\t\t\t\t\t\t\t<img class=\"lazyload phone-only\" data-srcset=\"${_.getSizedImageUrl(img.src, c.photo_size.full)} 1x, ${_.getSizedImageUrl(img.src, c.photo_size.full_retina)} 2x\" alt=\"${img.alt} Phone\" />\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t  </div>\n\t\t\t\t\t\t\t `;\n\t\t}\n\n\t\treturn html;\n\t}\n\n\tfunction getThumbHtml(img) {\n\n\t\tlet html;\n\n\t\t// only continue if 'img' is an object\n\t\tif (typeof img === 'object') {\n\n\t\t\thtml = document.createElement('div');\n\t\t\thtml.className = 'pv-thumb js-thumb';\n\t\t\thtml.innerHTML = `<div class=\"ir ir--square is-loading is-loading--pink\">\n\t\t\t\t\t\t\t\t<div class=\"pv-thumb__inner\">\n\t\t\t\t\t\t\t\t\t<img class=\"lazyload pv-thumb__img\" data-srcset=\"${_.getSizedImageUrl(img.src, c.photo_size.thumb)} 1x, ${_.getSizedImageUrl(img.src, c.photo_size.thumb_retina)} 2x\" alt=\"${img.alt}\" />\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>`;\n\t\t}\n\n\t\treturn html;\n\t}\n\n\t/**\n  * check swatch json\n  * @return {Boolean} [description]\n  */\n\tfunction hasSomeSwatchJson() {\n\t\treturn Object.keys(SDG.Product.swatchJson).some(hasSwatchJson);\n\t}\n\n\t/**\n  * has swatch json\n  * @callback\n  * @param  {String}  color\n  * @return {Boolean}\n  */\n\tfunction hasSwatchJson(color) {\n\t\treturn SDG.Product.swatchJson[color].length;\n\t}\n\n\t/**\n  * get first swatch name with images\n  * @return {String}\n  */\n\tfunction getFirstSwatchNameWithImages() {\n\t\treturn Object.keys(SDG.Product.swatchJson).filter(hasSwatchJson)[0];\n\t}\n\n\t/**\n  * open modal\n  * @type {Function}\n  */\n\tfunction openModal() {\n\t\tgalleryZoom.open(c.dom.large_photos_modal);\n\t\t// jump to image\n\t\tconst index = this.getAttribute('data-index');\n\t\twindow.location.hash = `pi-lg-${index}`;\n\n\t\tSDG.Product.largePhotos.select(index);\n\t}\n\n\t/**\n * close modal\n * @type {Function}\n */\n\tfunction closeModal() {\n\t\tgalleryZoom.close();\n\t\t// clearing hash from url address\n\t\twindow.location.hash = '';\n\t}\n\n\treturn {\n\t\tinit,\n\t\tbuildSlides\n\t};\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SDG.Product.photos);\n\n//# sourceURL=webpack:///./src/js/lib/product-photos.js?");

/***/ }),

/***/ "./src/js/lib/product-related.js":
/*!***************************************!*\
  !*** ./src/js/lib/product-related.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var flickity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flickity */ \"./node_modules/flickity/js/index.js\");\n/* harmony import */ var flickity__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(flickity__WEBPACK_IMPORTED_MODULE_0__);\n/*\n* Product\n*\n* product namespace\n* @type {Object}\n*/\n\n\nSDG.Product = SDG.Product || {};\n\n/**\n * related carousel\n * @type {Object}\n */\nSDG.Product.relatedProducts = SDG.Product.relatedProducts || {};\n\nSDG.Product.related = function () {\n\n\t// globals\n\tconst relatedCarouselEl = document.getElementById('relatedList');\n\n\tfunction init() {\n\t\tif (relatedCarouselEl) {\n\t\t\tinitFlickity();\n\t\t\taddEvents();\n\t\t}\n\t}\n\n\tfunction addEvents() {\n\n\t\t_.addEvent({\n\t\t\tid: 'flickPrev',\n\t\t\tevent: 'click',\n\t\t\tfn: prev\n\t\t});\n\n\t\t_.addEvent({\n\t\t\tid: 'flickNext',\n\t\t\tevent: 'click',\n\t\t\tfn: next\n\t\t});\n\t}\n\n\tfunction prev() {\n\t\tSDG.Product.relatedProducts.previous();\n\t}\n\n\tfunction next() {\n\t\tSDG.Product.relatedProducts.next();\n\t}\n\n\tfunction initFlickity() {\n\n\t\tSDG.Product.relatedProducts = new flickity__WEBPACK_IMPORTED_MODULE_0___default.a(relatedCarouselEl, {\n\t\t\tcontain: true,\n\t\t\tcellAlign: 'left',\n\t\t\tpageDots: false,\n\t\t\twatchCSS: true,\n\t\t\tprevNextButtons: false,\n\t\t\tcellSelector: '.related-item'\n\t\t});\n\t}\n\n\treturn init();\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SDG.Product.related);\n\n//# sourceURL=webpack:///./src/js/lib/product-related.js?");

/***/ }),

/***/ "./src/js/lib/product-shade-info.js":
/*!******************************************!*\
  !*** ./src/js/lib/product-shade-info.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nSDG.shadeInfo = SDG.shadeInfo || {};\n\nSDG.shadeInfo.config = {\n\tdom: {\n\t\ttrigger: 'shadeInfoTrigger',\n\t\ttab_left: 'leftTabBtn',\n\t\ttab_right: 'rightTabBtn',\n\t\tlink: 'pv-link',\n\t\tlink_list: 'pvLinksList',\n\t\tshade_list: 'pvTabsList',\n\t\tshade_btn: 'js-shade-trigger',\n\t\tshade_modal: 'js-shade-modal'\n\t},\n\tmodal: {\n\t\tid: 'shadeIngredientsModal',\n\t\toverlay: 'shadeIngredientsOverlay'\n\t},\n\toffset: 134\n};\n\nSDG.shadeInfo.init = function (opts) {\n\n\tconst c = _.extend(SDG.shadeInfo.config, opts);\n\n\t// globals\n\tconst $tabList = document.getElementById(c.dom.shade_list);\n\tconst tabs = document.getElementById('pvTabs');\n\tconst $tabLeft = document.getElementById(c.dom.tab_left);\n\tconst $tabRight = document.getElementById(c.dom.tab_right);\n\tconst $modal = document.getElementById(c.modal.id);\n\tconst $modalContents = $modal.querySelectorAll(`.${c.dom.shade_modal}`);\n\n\t// shade modal\n\tconst modalOptsShade = {\n\t\tdom: {\n\t\t\tmodal_id: c.modal.id,\n\t\t\toverlay: c.modal.overlay\n\t\t}\n\t};\n\tconst modalShade = SDG.Modal.init(modalOptsShade);\n\n\t// tabs accordion\n\tconst pvTabs = SDG.accordion({\n\t\tdom: {\n\t\t\tbtn: 'js-tab-btn',\n\t\t\tid: 'pvTabs',\n\t\t\tmenu: 'js-tabs-menu'\n\t\t},\n\t\topen_option: 0,\n\t\tclose_on_trigger_click: false\n\t});\n\n\t// shade list accordion\n\tconst pvTabsList = SDG.accordion({\n\t\tdom: {\n\t\t\tbtn: 'js-tablist-btn',\n\t\t\tid: 'pvTabsList',\n\t\t\tmenu: 'js-tablist-menu'\n\t\t},\n\t\tresponsive: true,\n\t\tviews: {\n\t\t\tactive: ['mobile'], // {array}\n\t\t\tinactive: ['desktop']\n\t\t}\n\t});\n\n\tfunction init() {\n\t\tif ($tabList) {\n\n\t\t\t// shade modal\n\t\t\tmodalShade.init();\n\n\t\t\t// tabs\n\t\t\tif (tabs) {\n\t\t\t\tpvTabs.init();\n\t\t\t\tpvTabsList.init();\n\t\t\t}\n\t\t}\n\n\t\taddEvents();\n\t}\n\n\tfunction addEvents() {\n\t\topenLeftTab();\n\t\topenRightTab();\n\n\t\t_.addEvent({\n\t\t\tid: c.dom.shade_list,\n\t\t\tclassName: c.dom.shade_btn,\n\t\t\tevent: 'click',\n\t\t\tfn: openShadeModal\n\t\t});\n\t}\n\n\tfunction openLeftTab() {\n\t\t_.scrollTo({\n\t\t\tid: c.dom.link_list,\n\t\t\tclassName: c.dom.link,\n\t\t\toffset: c.offset * -1,\n\t\t\tcallback: () => {\n\t\t\t\tif ($tabLeft) {\n\t\t\t\t\t$tabLeft.click();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction openRightTab() {\n\t\t_.scrollTo({\n\t\t\tid: c.dom.trigger,\n\t\t\toffset: c.offset * -1,\n\t\t\ttarget: c.dom.tab_right,\n\t\t\tcallback: () => {\n\t\t\t\tif ($tabRight) {\n\t\t\t\t\t$tabRight.click();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction openShadeModal(e) {\n\n\t\tconst shade = e.target.getAttribute('data-shade');\n\n\t\tfor (let i = 0; i < $modalContents.length; i += 1) {\n\t\t\tconst shadeModal = $modalContents[i].getAttribute('data-shade-modal');\n\n\t\t\tif (shade === shadeModal) {\n\t\t\t\t_.removeClass($modalContents[i], 'hide');\n\t\t\t} else {\n\t\t\t\t_.addClass($modalContents[i], 'hide');\n\t\t\t}\n\t\t}\n\n\t\tmodalShade.open();\n\t}\n\n\treturn {\n\t\tinit\n\t};\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SDG.shadeInfo.init);\n\n//# sourceURL=webpack:///./src/js/lib/product-shade-info.js?");

/***/ }),

/***/ "./src/js/lib/product-swatches.js":
/*!****************************************!*\
  !*** ./src/js/lib/product-swatches.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n* namespace\n*/\nSDG.Product = SDG.Product || {};\n\n/**\n* swatch json array\n* @type {Object}\n*/\nSDG.Product.swatchJson = {};\n\n/**\n* active swatch\n*/\nSDG.Product.activeColor = '';\n\n/**\n* swatches\n* @return {Function} builds swatchJson array\n*/\nSDG.Product.swatches = function (opts) {\n\tconst config = {\n\t\timage_json: '',\n\t\tproduct_json: ''\n\t};\n\tconst c = _.extend(config, opts);\n\n\t// cached globals\n\t// const $form = document.getElementById('addToBagForm');\n\tconst productData = c.product_json ? c.product_json : productJson;\n\tconst imageData = c.image_json ? c.image_json : imageJson;\n\tconst options = _.arrayToLower(JSON.parse(JSON.stringify(productData.options)));\n\tconst idx = options.indexOf('color');\n\t/**\n * build\n */\n\tfunction init() {\n\n\t\tif (options.indexOf('color') !== -1) {\n\t\t\tbuildJson();\n\t\t}\n\t}\n\n\t/**\n * build json\n */\n\tfunction buildJson() {\n\t\taddColorNodes();\n\t\tparseImages();\n\t}\n\n\t/**\n * add color nodes\n */\n\tfunction addColorNodes() {\n\t\tconst colors = [];\n\t\tlet color;\n\t\tlet i;\n\t\tconst v = productData.variants;\n\t\tconst count = v.length;\n\n\t\tfor (i = 0; i < count; i += 1) {\n\t\t\tcolor = v[i].options[idx].toLowerCase();\n\n\t\t\tif (colors.indexOf(color) === -1) {\n\t\t\t\tcolors.push(color);\n\t\t\t\tSDG.Product.swatchJson[color] = [];\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseImages() {\n\n\t\tObject.keys(imageData).forEach(key => {\n\t\t\tconst img = imageData[key];\n\t\t\tconst color = img.alt.toLowerCase();\n\n\t\t\tif (typeof SDG.Product.swatchJson[color] !== 'undefined') {\n\t\t\t\tSDG.Product.swatchJson[color].push(img);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction update(variant) {\n\n\t\tconst color = variant.options[idx] ? variant.options[idx].toLowerCase() : null;\n\n\t\t// only continue if swatch json is properly constructed\n\t\tif (typeof SDG.Product.swatchJson[color] !== 'undefined') {\n\t\t\tif (SDG.Product.activeColor !== color) {\n\t\t\t\tSDG.Product.photos({\n\t\t\t\t\timage_json: imageData\n\t\t\t\t}).buildSlides(SDG.Product.swatchJson[color]);\n\n\t\t\t\tSDG.Product.activeColor = color;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tinit,\n\t\tupdate\n\t};\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SDG.Product.swatches);\n\n//# sourceURL=webpack:///./src/js/lib/product-swatches.js?");

/***/ }),

/***/ "./src/js/lib/video.js":
/*!*****************************!*\
  !*** ./src/js/lib/video.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * video embed\n * @param  {Object}  Config object\n * @requires [lib/util.js,lib/modal.js,lib/modal-get.js,lib/modal-clear.js]\n */\nSDG.videoEmbed = function (opts) {\n\tconst config = {\n\t\tid: 'vid',\n\t\timage: '.js-vid-image',\n\t\tclass: {\n\t\t\tembed: 'vid__embed',\n\t\t\tfade_out: 'is-fading-out',\n\t\t\thas_embed: 'has-embed',\n\t\t\tir: 'ir ir--vid'\n\t\t},\n\t\tvideo_url: {\n\t\t\tyoutube: 'https://www.youtube.com/embed/',\n\t\t\tvimeo: 'https://player.vimeo.com/video/'\n\t\t},\n\t\tshow_in_modal: false,\n\t\tmodal: null // keys: id, modifier, overlay\n\t};\n\tconst c = _.extend(config, opts);\n\n\t// globals\n\tconst video = document.getElementById(c.id);\n\n\t/**\n  * init\n  * @return {Function}\n  */\n\tfunction init() {\n\t\tbindEvents();\n\t}\n\n\t/**\n  * bind events\n  * @return {Function}\n  */\n\tfunction bindEvents() {\n\t\tif (video) {\n\t\t\tif (c.show_in_modal) {\n\t\t\t\tvideo.addEventListener('click', generateModal, false);\n\t\t\t} else {\n\t\t\t\tvideo.addEventListener('click', insertVideo, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * unbind events\n  * @return {Function}\n  */\n\tfunction unbindEvents() {\n\t\tif (c.show_in_modal) {\n\t\t\tvideo.removeEventListener('click', generateModal, false);\n\t\t} else {\n\t\t\tvideo.removeEventListener('click', insertVideo, false);\n\t\t}\n\t}\n\n\t/**\n  * insert video\n  * @return {Function}\n  */\n\tfunction insertVideo() {\n\t\tconst videoId = this.getAttribute('data-video-id');\n\t\tconst videoPlayer = this.getAttribute('data-video-player');\n\t\tconst videoImage = video.querySelector(c.image);\n\t\tconst videoEmbed = buildEmbed(videoId, videoPlayer);\n\n\t\t// unbind events\n\t\tunbindEvents();\n\n\t\t// transition image-to-video\n\t\t_.transition({\n\t\t\tbefore: () => {\n\n\t\t\t\t// add fade-out class to image\n\t\t\t\t_.addClass(videoImage, c.class.fade_out);\n\t\t\t},\n\t\t\tafter: () => {\n\t\t\t\t// hide image\n\t\t\t\tvideoImage.style.display = 'none';\n\n\t\t\t\t// remove fade-out class from image\n\t\t\t\t_.removeClass(videoImage, c.class.fade_out);\n\n\t\t\t\t// prepend video embed to video container\n\t\t\t\tvideo.insertBefore(videoEmbed, videoImage);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n  * video player chocie\n  * @param {String} videoPlayer\n  * @return {Function}\n  */\n\tfunction videoPlayerChoice(videoPlayer) {\n\t\tlet videoUrlPlayer;\n\n\t\tswitch (videoPlayer) {\n\t\t\tcase 'vimeo':\n\t\t\t\tvideoUrlPlayer = c.video_url.vimeo;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvideoUrlPlayer = c.video_url.youtube;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn videoUrlPlayer;\n\t}\n\n\t/**\n  * build embed\n  * @param  {String} videoId     Id of the video on youtube or vimeo\n  * @param  {String} videoPlayer Type of player, youtube or vimeo. Default is youtube\n  * @return {String}             Html for the iframe embed\n  */\n\tfunction buildEmbed(videoId, videoPlayer) {\n\n\t\tconst videoChoice = videoPlayerChoice(videoPlayer);\n\t\tconst videoUrl = `${videoChoice}${videoId}?autoplay=1&rel=0`;\n\t\tconst videoEmbed = document.createElement('div');\n\t\tconst videoIframe = `<iframe width=\"1280\" height=\"720\" src=\"${videoUrl}\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>`;\n\n\t\t// set class name\n\t\tvideoEmbed.className = `${c.class.embed} ${c.class.ir}`;\n\n\t\t// append iframe html to embed div\n\t\tvideoEmbed.innerHTML = videoIframe;\n\n\t\treturn videoEmbed;\n\t}\n\n\t/**\n  * generate modal\n  * @return {Function}\n  */\n\tfunction generateModal() {\n\t\tconst videoId = this.getAttribute('data-video-id');\n\t\tconst videoPlayer = this.getAttribute('data-video-player');\n\t\tconst videoChoice = videoPlayerChoice(videoPlayer);\n\t\tconst videoUrl = `${videoChoice}${videoId}?autoplay=1&rel=0`;\n\t\tconst html = `<div class=\"vid__embed ir ir--vid\">\n\t\t\t\t<iframe width=\"1280\" height=\"720\" src=\"${videoUrl}\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>\n\t\t\t</div>`;\n\n\t\tlet md;\n\t\tlet modalWrap;\n\n\t\tif (c.modal) {\n\t\t\tmd = SDG.Modal.getHtml({\n\t\t\t\tmodal: c.modal.id,\n\t\t\t\tmodifier: c.modal.modifier,\n\t\t\t\toverlay: c.modal.overlay,\n\t\t\t\thtml\n\t\t\t}).render();\n\n\t\t\tmodalWrap = document.createElement('div');\n\t\t\tmodalWrap.innerHTML = md;\n\t\t\tdocument.body.appendChild(modalWrap);\n\n\t\t\tsetTimeout(() => initVideo, 20);\n\t\t}\n\n\t\tfunction initVideo() {\n\t\t\tconst videoModal = SDG.Modal({\n\t\t\t\tdom: {\n\t\t\t\t\tmodal_id: c.modal.id\n\t\t\t\t},\n\t\t\t\tcb: {\n\t\t\t\t\tclose: attachCloseEvent\n\t\t\t\t}\n\t\t\t});\n\t\t\tvideoModal.init();\n\t\t\tvideoModal.open(c.modal.id);\n\t\t}\n\n\t\tfunction attachCloseEvent() {\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst clear = SDG.Modal.clear({\n\t\t\t\t\tmodal: c.modal.id,\n\t\t\t\t\toverlay: c.modal.overlay\n\t\t\t\t});\n\t\t\t\tclear.init();\n\t\t\t}, 500);\n\t\t}\n\t}\n\n\treturn { init };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SDG.videoEmbed);\n\n//# sourceURL=webpack:///./src/js/lib/video.js?");

/***/ }),

/***/ "./src/js/plugins/scripts.js":
/*!***********************************!*\
  !*** ./src/js/plugins/scripts.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (name, definition) {\n\tif ( true && module.exports) module.exports = definition();else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})('$script', function () {\n\tvar doc = document,\n\t    head = doc.getElementsByTagName('head')[0],\n\t    s = 'string',\n\t    f = false,\n\t    push = 'push',\n\t    readyState = 'readyState',\n\t    onreadystatechange = 'onreadystatechange',\n\t    list = {},\n\t    ids = {},\n\t    delay = {},\n\t    scripts = {},\n\t    scriptpath,\n\t    urlArgs;\n\n\tfunction every(ar, fn) {\n\t\tfor (var i = 0, j = ar.length; i < j; ++i) if (!fn(ar[i])) return f;\n\t\treturn 1;\n\t}\n\tfunction each(ar, fn) {\n\t\tevery(ar, function (el) {\n\t\t\tfn(el);\n\t\t\treturn 1;\n\t\t});\n\t}\n\n\tfunction $script(paths, idOrDone, optDone) {\n\t\tpaths = paths[push] ? paths : [paths];\n\t\tvar idOrDoneIsDone = idOrDone && idOrDone.call,\n\t\t    done = idOrDoneIsDone ? idOrDone : optDone,\n\t\t    id = idOrDoneIsDone ? paths.join('') : idOrDone,\n\t\t    queue = paths.length;\n\t\tfunction loopFn(item) {\n\t\t\treturn item.call ? item() : list[item];\n\t\t}\n\t\tfunction callback() {\n\t\t\tif (! --queue) {\n\t\t\t\tlist[id] = 1;\n\t\t\t\tdone && done();\n\t\t\t\tfor (var dset in delay) {\n\t\t\t\t\tevery(dset.split('|'), loopFn) && !each(delay[dset], loopFn) && (delay[dset] = []);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetTimeout(function () {\n\t\t\teach(paths, function loading(path, force) {\n\t\t\t\tif (path === null) return callback();\n\n\t\t\t\tif (!force && !/^https?:\\/\\//.test(path) && scriptpath) {\n\t\t\t\t\tpath = path.indexOf('.js') === -1 ? scriptpath + path + '.js' : scriptpath + path;\n\t\t\t\t}\n\n\t\t\t\tif (scripts[path]) {\n\t\t\t\t\tif (id) ids[id] = 1;\n\t\t\t\t\treturn scripts[path] == 2 ? callback() : setTimeout(function () {\n\t\t\t\t\t\tloading(path, true);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\n\t\t\t\tscripts[path] = 1;\n\t\t\t\tif (id) ids[id] = 1;\n\t\t\t\tcreate(path, callback);\n\t\t\t});\n\t\t}, 0);\n\t\treturn $script;\n\t}\n\n\tfunction create(path, fn) {\n\t\tvar el = doc.createElement('script'),\n\t\t    loaded;\n\t\tel.onload = el.onerror = el[onreadystatechange] = function () {\n\t\t\tif (el[readyState] && !/^c|loade/.test(el[readyState]) || loaded) return;\n\t\t\tel.onload = el[onreadystatechange] = null;\n\t\t\tloaded = 1;\n\t\t\tscripts[path] = 2;\n\t\t\tfn();\n\t\t};\n\t\tel.async = 1;\n\t\tel.src = urlArgs ? path + (path.indexOf('?') === -1 ? '?' : '&') + urlArgs : path;\n\t\thead.insertBefore(el, head.lastChild);\n\t}\n\n\t$script.get = create;\n\n\t$script.order = function (scripts, id, done) {\n\t\t(function callback(s) {\n\t\t\ts = scripts.shift();\n\t\t\t!scripts.length ? $script(s, id, done) : $script(s, callback);\n\t\t})();\n\t};\n\n\t$script.path = function (p) {\n\t\tscriptpath = p;\n\t};\n\t$script.urlArgs = function (str) {\n\t\turlArgs = str;\n\t};\n\t$script.ready = function (deps, ready, req) {\n\t\tdeps = deps[push] ? deps : [deps];\n\t\tvar missing = [];\n\t\t!each(deps, function (dep) {\n\t\t\tlist[dep] || missing[push](dep);\n\t\t}) && every(deps, function (dep) {\n\t\t\treturn list[dep];\n\t\t}) ? ready() : !function (key) {\n\t\t\tdelay[key] = delay[key] || [];\n\t\t\tdelay[key][push](ready);\n\t\t\treq && req(missing);\n\t\t}(deps.join('|'));\n\t\treturn $script;\n\t};\n\n\t$script.done = function (idOrDone) {\n\t\t$script([null], idOrDone);\n\t};\n\n\treturn $script;\n});\n\n//# sourceURL=webpack:///./src/js/plugins/scripts.js?");

/***/ }),

/***/ "./src/js/util/format-money.js":
/*!*************************************!*\
  !*** ./src/js/util/format-money.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * format money\n * edited version of the following script:\n * @see    https://gist.github.com/stewartknapman/8d8733ea58d2314c373e94114472d44c\n * @param  {Number|String} cents    e.g. \"1200\"\n * @param  {String}        format   e.g. \"amount_with_currency\"\n * @param  {String}        currency e.g. \"$\"\n * @return {String}\n */\nfunction formatMoney(cents, format, currency = '$') {\n\tif (typeof cents == 'string') {\n\t\tcents = cents.replace('.', '');\n\t}\n\tvar value = '';\n\tvar placeholderRegex = /\\{\\{\\s*(\\w+)\\s*\\}\\}/;\n\n\tfunction defaultOption(opt, def) {\n\t\treturn typeof opt == 'undefined' ? def : opt;\n\t}\n\n\tfunction formatWithDelimiters(number, precision, thousands, decimal) {\n\t\tprecision = defaultOption(precision, 2);\n\t\tthousands = defaultOption(thousands, ',');\n\t\tdecimal = defaultOption(decimal, '.');\n\n\t\tif (isNaN(number) || number == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tnumber = (number / 100.0).toFixed(precision);\n\n\t\tvar parts = number.split('.'),\n\t\t    dollars = parts[0].replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, '$1' + thousands),\n\t\t    cents = parts[1] ? decimal + parts[1] : '';\n\n\t\treturn dollars + cents;\n\t}\n\n\tswitch (format) {\n\t\tcase 'amount':\n\t\t\tvalue = formatWithDelimiters(cents, 2);\n\t\t\tbreak;\n\t\tcase 'amount_with_currency':\n\t\t\tvalue = currency + formatWithDelimiters(cents, 2);\n\t\t\tbreak;\n\t\tcase 'amount_with_currency_without_trailing_zeros':\n\t\t\tvalue = currency + formatWithDelimiters(cents, 2);\n\t\t\tif (value.indexOf('.00') !== -1) {\n\t\t\t\tvalue = value.replace('.00', '');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'amount_no_decimals':\n\t\t\tvalue = formatWithDelimiters(cents, 0);\n\t\t\tbreak;\n\t\tcase 'amount_with_comma_separator':\n\t\t\tvalue = formatWithDelimiters(cents, 2, '.', ',');\n\t\t\tbreak;\n\t\tcase 'amount_no_decimals_with_comma_separator':\n\t\t\tvalue = formatWithDelimiters(cents, 0, '.', ',');\n\t\t\tbreak;\n\t}\n\n\treturn value;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (formatMoney);\n\n//# sourceURL=webpack:///./src/js/util/format-money.js?");

/***/ })

/******/ });